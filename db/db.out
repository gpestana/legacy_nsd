{"source":"http://nodejs.org/api/synopsis.json","title":"Synopsis","content":"{\n  \"source\": \"doc/api/synopsis.markdown\",\n  \"miscs\": [\n    {\n      \"textRaw\": \"Synopsis\",\n      \"name\": \"Synopsis\",\n      \"type\": \"misc\",\n      \"desc\": \"<p>An example of a <a href=\\\"http.html\\\">web server</a> written with Node which responds with &#39;Hello\\nWorld&#39;:\\n\\n</p>\\n<pre><code>var http = require(&#39;http&#39;);\\n\\nhttp.createServer(function (request, response) {\\n  response.writeHead(200, {&#39;Content-Type&#39;: &#39;text/plain&#39;});\\n  response.end(&#39;Hello World\\\\n&#39;);\\n}).listen(8124);\\n\\nconsole.log(&#39;Server running at http://127.0.0.1:8124/&#39;);</code></pre>\\n<p>To run the server, put the code into a file called <code>example.js</code> and execute\\nit with the node program\\n\\n</p>\\n<pre><code>&gt; node example.js\\nServer running at http://127.0.0.1:8124/</code></pre>\\n<p>All of the examples in the documentation can be run similarly.\\n</p>\\n\"\n    }\n  ]\n}\n"}{"source":"http://nodejs.org/api/documentation.json","title":"About these Docs","content":"{\n  \"source\": \"doc/api/documentation.markdown\",\n  \"miscs\": [\n    {\n      \"textRaw\": \"About this Documentation\",\n      \"name\": \"About this Documentation\",\n      \"type\": \"misc\",\n      \"desc\": \"<p>The goal of this documentation is to comprehensively explain the Node.js\\nAPI, both from a reference as well as a conceptual point of view.  Each\\nsection describes a built-in module or high-level concept.\\n\\n</p>\\n<p>Where appropriate, property types, method arguments, and the arguments\\nprovided to event handlers are detailed in a list underneath the topic\\nheading.\\n\\n</p>\\n<p>Every <code>.html</code> document has a corresponding <code>.json</code> document presenting\\nthe same information in a structured manner.  This feature is\\nexperimental, and added for the benefit of IDEs and other utilities that\\nwish to do programmatic things with the documentation.\\n\\n</p>\\n<p>Every <code>.html</code> and <code>.json</code> file is generated based on the corresponding\\n<code>.markdown</code> file in the <code>doc/api/</code> folder in node&#39;s source tree.  The\\ndocumentation is generated using the <code>tools/doc/generate.js</code> program.\\nThe HTML template is located at <code>doc/template.html</code>.\\n\\n</p>\\n\",\n      \"miscs\": [\n        {\n          \"textRaw\": \"Stability Index\",\n          \"name\": \"Stability Index\",\n          \"type\": \"misc\",\n          \"desc\": \"<p>Throughout the documentation, you will see indications of a section&#39;s\\nstability.  The Node.js API is still somewhat changing, and as it\\nmatures, certain parts are more reliable than others.  Some are so\\nproven, and so relied upon, that they are unlikely to ever change at\\nall.  Others are brand new and experimental, or known to be hazardous\\nand in the process of being redesigned.\\n\\n</p>\\n<p>The stability indices are as follows:\\n\\n</p>\\n<pre><code>Stability: 0 - Deprecated\\nThis feature is known to be problematic, and changes are\\nplanned.  Do not rely on it.  Use of the feature may cause warnings.  Backwards\\ncompatibility should not be expected.</code></pre>\\n<pre><code>Stability: 1 - Experimental\\nThis feature was introduced recently, and may change\\nor be removed in future versions.  Please try it out and provide feedback.\\nIf it addresses a use-case that is important to you, tell the node core team.</code></pre>\\n<pre><code>Stability: 2 - Unstable\\nThe API is in the process of settling, but has not yet had\\nsufficient real-world testing to be considered stable. Backwards-compatibility\\nwill be maintained if reasonable.</code></pre>\\n<pre><code>Stability: 3 - Stable\\nThe API has proven satisfactory, but cleanup in the underlying\\ncode may cause minor changes.  Backwards-compatibility is guaranteed.</code></pre>\\n<pre><code>Stability: 4 - API Frozen\\nThis API has been tested extensively in production and is\\nunlikely to ever have to change.</code></pre>\\n<pre><code>Stability: 5 - Locked\\nUnless serious bugs are found, this code will not ever\\nchange.  Please do not suggest changes in this area; they will be refused.</code></pre>\\n\"\n        },\n        {\n          \"textRaw\": \"JSON Output\",\n          \"name\": \"json_output\",\n          \"stability\": 1,\n          \"stabilityText\": \"Experimental\",\n          \"desc\": \"<p>Every HTML file in the markdown has a corresponding JSON file with the\\nsame data.\\n\\n</p>\\n<p>This feature is new as of node v0.6.12.  It is experimental.\\n</p>\\n\",\n          \"type\": \"misc\",\n          \"displayName\": \"JSON Output\"\n        }\n      ]\n    }\n  ]\n}\n"}{"source":"http://nodejs.org/api/assert.json","title":"Assertion Testing","content":"{\n  \"source\": \"doc/api/assert.markdown\",\n  \"modules\": [\n    {\n      \"textRaw\": \"Assert\",\n      \"name\": \"assert\",\n      \"stability\": 5,\n      \"stabilityText\": \"Locked\",\n      \"desc\": \"<p>This module is used for writing unit tests for your applications, you can\\naccess it with <code>require(&#39;assert&#39;)</code>.\\n\\n</p>\\n\",\n      \"methods\": [\n        {\n          \"textRaw\": \"assert.fail(actual, expected, message, operator)\",\n          \"type\": \"method\",\n          \"name\": \"fail\",\n          \"desc\": \"<p>Throws an exception that displays the values for <code>actual</code> and <code>expected</code> separated by the provided operator.\\n\\n</p>\\n\",\n          \"signatures\": [\n            {\n              \"params\": [\n                {\n                  \"name\": \"actual\"\n                },\n                {\n                  \"name\": \"expected\"\n                },\n                {\n                  \"name\": \"message\"\n                },\n                {\n                  \"name\": \"operator\"\n                }\n              ]\n            }\n          ]\n        },\n        {\n          \"textRaw\": \"assert(value, message), assert.ok(value, [message])\",\n          \"type\": \"method\",\n          \"name\": \"ok\",\n          \"desc\": \"<p>Tests if value is truthy, it is equivalent to <code>assert.equal(true, !!value, message);</code>\\n\\n</p>\\n\",\n          \"signatures\": [\n            {\n              \"params\": [\n                {\n                  \"name\": \"value\"\n                },\n                {\n                  \"name\": \"message)\"\n                },\n                {\n                  \"name\": \"assert.ok(value\"\n                },\n                {\n                  \"name\": \"message\",\n                  \"optional\": true\n                }\n              ]\n            }\n          ]\n        },\n        {\n          \"textRaw\": \"assert.equal(actual, expected, [message])\",\n          \"type\": \"method\",\n          \"name\": \"equal\",\n          \"desc\": \"<p>Tests shallow, coercive equality with the equal comparison operator ( <code>==</code> ).\\n\\n</p>\\n\",\n          \"signatures\": [\n            {\n              \"params\": [\n                {\n                  \"name\": \"actual\"\n                },\n                {\n                  \"name\": \"expected\"\n                },\n                {\n                  \"name\": \"message\",\n                  \"optional\": true\n                }\n              ]\n            }\n          ]\n        },\n        {\n          \"textRaw\": \"assert.notEqual(actual, expected, [message])\",\n          \"type\": \"method\",\n          \"name\": \"notEqual\",\n          \"desc\": \"<p>Tests shallow, coercive non-equality with the not equal comparison operator ( <code>!=</code> ).\\n\\n</p>\\n\",\n          \"signatures\": [\n            {\n              \"params\": [\n                {\n                  \"name\": \"actual\"\n                },\n                {\n                  \"name\": \"expected\"\n                },\n                {\n                  \"name\": \"message\",\n                  \"optional\": true\n                }\n              ]\n            }\n          ]\n        },\n        {\n          \"textRaw\": \"assert.deepEqual(actual, expected, [message])\",\n          \"type\": \"method\",\n          \"name\": \"deepEqual\",\n          \"desc\": \"<p>Tests for deep equality.\\n\\n</p>\\n\",\n          \"signatures\": [\n            {\n              \"params\": [\n                {\n                  \"name\": \"actual\"\n                },\n                {\n                  \"name\": \"expected\"\n                },\n                {\n                  \"name\": \"message\",\n                  \"optional\": true\n                }\n              ]\n            }\n          ]\n        },\n        {\n          \"textRaw\": \"assert.notDeepEqual(actual, expected, [message])\",\n          \"type\": \"method\",\n          \"name\": \"notDeepEqual\",\n          \"desc\": \"<p>Tests for any deep inequality.\\n\\n</p>\\n\",\n          \"signatures\": [\n            {\n              \"params\": [\n                {\n                  \"name\": \"actual\"\n                },\n                {\n                  \"name\": \"expected\"\n                },\n                {\n                  \"name\": \"message\",\n                  \"optional\": true\n                }\n              ]\n            }\n          ]\n        },\n        {\n          \"textRaw\": \"assert.strictEqual(actual, expected, [message])\",\n          \"type\": \"method\",\n          \"name\": \"strictEqual\",\n          \"desc\": \"<p>Tests strict equality, as determined by the strict equality operator ( <code>===</code> )\\n\\n</p>\\n\",\n          \"signatures\": [\n            {\n              \"params\": [\n                {\n                  \"name\": \"actual\"\n                },\n                {\n                  \"name\": \"expected\"\n                },\n                {\n                  \"name\": \"message\",\n                  \"optional\": true\n                }\n              ]\n            }\n          ]\n        },\n        {\n          \"textRaw\": \"assert.notStrictEqual(actual, expected, [message])\",\n          \"type\": \"method\",\n          \"name\": \"notStrictEqual\",\n          \"desc\": \"<p>Tests strict non-equality, as determined by the strict not equal operator ( <code>!==</code> )\\n\\n</p>\\n\",\n          \"signatures\": [\n            {\n              \"params\": [\n                {\n                  \"name\": \"actual\"\n                },\n                {\n                  \"name\": \"expected\"\n                },\n                {\n                  \"name\": \"message\",\n                  \"optional\": true\n                }\n              ]\n            }\n          ]\n        },\n        {\n          \"textRaw\": \"assert.throws(block, [error], [message])\",\n          \"type\": \"method\",\n          \"name\": \"throws\",\n          \"desc\": \"<p>Expects <code>block</code> to throw an error. <code>error</code> can be constructor, <code>RegExp</code> or\\nvalidation function.\\n\\n</p>\\n<p>Validate instanceof using constructor:\\n\\n</p>\\n<pre><code>assert.throws(\\n  function() {\\n    throw new Error(&quot;Wrong value&quot;);\\n  },\\n  Error\\n);</code></pre>\\n<p>Validate error message using RegExp:\\n\\n</p>\\n<pre><code>assert.throws(\\n  function() {\\n    throw new Error(&quot;Wrong value&quot;);\\n  },\\n  /value/\\n);</code></pre>\\n<p>Custom error validation:\\n\\n</p>\\n<pre><code>assert.throws(\\n  function() {\\n    throw new Error(&quot;Wrong value&quot;);\\n  },\\n  function(err) {\\n    if ( (err instanceof Error) &amp;&amp; /value/.test(err) ) {\\n      return true;\\n    }\\n  },\\n  &quot;unexpected error&quot;\\n);</code></pre>\\n\",\n          \"signatures\": [\n            {\n              \"params\": [\n                {\n                  \"name\": \"block\"\n                },\n                {\n                  \"name\": \"error\",\n                  \"optional\": true\n                },\n                {\n                  \"name\": \"message\",\n                  \"optional\": true\n                }\n              ]\n            }\n          ]\n        },\n        {\n          \"textRaw\": \"assert.doesNotThrow(block, [message])\",\n          \"type\": \"method\",\n          \"name\": \"doesNotThrow\",\n          \"desc\": \"<p>Expects <code>block</code> not to throw an error, see <code>assert.throws</code> for details.\\n\\n</p>\\n\",\n          \"signatures\": [\n            {\n              \"params\": [\n                {\n                  \"name\": \"block\"\n                },\n                {\n                  \"name\": \"message\",\n                  \"optional\": true\n                }\n              ]\n            }\n          ]\n        },\n        {\n          \"textRaw\": \"assert.ifError(value)\",\n          \"type\": \"method\",\n          \"name\": \"ifError\",\n          \"desc\": \"<p>Tests if value is not a false value, throws if it is a true value. Useful when\\ntesting the first argument, <code>error</code> in callbacks.\\n</p>\\n\",\n          \"signatures\": [\n            {\n              \"params\": [\n                {\n                  \"name\": \"value\"\n                }\n              ]\n            }\n          ]\n        }\n      ],\n      \"type\": \"module\",\n      \"displayName\": \"Assert\"\n    }\n  ]\n}\n"}{"source":"http://nodejs.org/api/console.json","title":"Console","content":"{\n  \"source\": \"doc/api/console.markdown\",\n  \"globals\": [\n    {\n      \"textRaw\": \"console\",\n      \"name\": \"console\",\n      \"stability\": 4,\n      \"stabilityText\": \"API Frozen\",\n      \"type\": \"global\",\n      \"desc\": \"<p>For printing to stdout and stderr.  Similar to the console object functions\\nprovided by most web browsers, here the output is sent to stdout or stderr.\\n\\n</p>\\n<p>The console functions are synchronous when the destination is a terminal or\\na file (to avoid lost messages in case of premature exit) and asynchronous\\nwhen it&#39;s a pipe (to avoid blocking for long periods of time).\\n\\n</p>\\n<p>That is, in the following example, stdout is non-blocking while stderr\\nis blocking:\\n\\n</p>\\n<pre><code>$ node script.js 2&gt; error.log | tee info.log</code></pre>\\n<p>In daily use, the blocking/non-blocking dichotomy is not something you\\nshould worry about unless you log huge amounts of data.\\n\\n\\n</p>\\n\",\n      \"methods\": [\n        {\n          \"textRaw\": \"console.log([data], [...])\",\n          \"type\": \"method\",\n          \"name\": \"log\",\n          \"desc\": \"<p>Prints to stdout with newline. This function can take multiple arguments in a\\n<code>printf()</code>-like way. Example:\\n\\n</p>\\n<pre><code>console.log(&#39;count: %d&#39;, count);</code></pre>\\n<p>If formatting elements are not found in the first string then <code>util.inspect</code>\\nis used on each argument.  See [util.format()][] for more information.\\n\\n</p>\\n\",\n          \"signatures\": [\n            {\n              \"params\": [\n                {\n                  \"name\": \"data\",\n                  \"optional\": true\n                },\n                {\n                  \"name\": \"...\",\n                  \"optional\": true\n                }\n              ]\n            }\n          ]\n        },\n        {\n          \"textRaw\": \"console.info([data], [...])\",\n          \"type\": \"method\",\n          \"name\": \"info\",\n          \"desc\": \"<p>Same as <code>console.log</code>.\\n\\n</p>\\n\",\n          \"signatures\": [\n            {\n              \"params\": [\n                {\n                  \"name\": \"data\",\n                  \"optional\": true\n                },\n                {\n                  \"name\": \"...\",\n                  \"optional\": true\n                }\n              ]\n            }\n          ]\n        },\n        {\n          \"textRaw\": \"console.error([data], [...])\",\n          \"type\": \"method\",\n          \"name\": \"error\",\n          \"desc\": \"<p>Same as <code>console.log</code> but prints to stderr.\\n\\n</p>\\n\",\n          \"signatures\": [\n            {\n              \"params\": [\n                {\n                  \"name\": \"data\",\n                  \"optional\": true\n                },\n                {\n                  \"name\": \"...\",\n                  \"optional\": true\n                }\n              ]\n            }\n          ]\n        },\n        {\n          \"textRaw\": \"console.warn([data], [...])\",\n          \"type\": \"method\",\n          \"name\": \"warn\",\n          \"desc\": \"<p>Same as <code>console.error</code>.\\n\\n</p>\\n\",\n          \"signatures\": [\n            {\n              \"params\": [\n                {\n                  \"name\": \"data\",\n                  \"optional\": true\n                },\n                {\n                  \"name\": \"...\",\n                  \"optional\": true\n                }\n              ]\n            }\n          ]\n        },\n        {\n          \"textRaw\": \"console.dir(obj)\",\n          \"type\": \"method\",\n          \"name\": \"dir\",\n          \"desc\": \"<p>Uses <code>util.inspect</code> on <code>obj</code> and prints resulting string to stdout.\\n\\n</p>\\n\",\n          \"signatures\": [\n            {\n              \"params\": [\n                {\n                  \"name\": \"obj\"\n                }\n              ]\n            }\n          ]\n        },\n        {\n          \"textRaw\": \"console.time(label)\",\n          \"type\": \"method\",\n          \"name\": \"time\",\n          \"desc\": \"<p>Mark a time.\\n\\n</p>\\n\",\n          \"signatures\": [\n            {\n              \"params\": [\n                {\n                  \"name\": \"label\"\n                }\n              ]\n            }\n          ]\n        },\n        {\n          \"textRaw\": \"console.timeEnd(label)\",\n          \"type\": \"method\",\n          \"name\": \"timeEnd\",\n          \"desc\": \"<p>Finish timer, record output. Example:\\n\\n</p>\\n<pre><code>console.time(&#39;100-elements&#39;);\\nfor (var i = 0; i &lt; 100; i++) {\\n  ;\\n}\\nconsole.timeEnd(&#39;100-elements&#39;);</code></pre>\\n\",\n          \"signatures\": [\n            {\n              \"params\": [\n                {\n                  \"name\": \"label\"\n                }\n              ]\n            }\n          ]\n        },\n        {\n          \"textRaw\": \"console.trace(label)\",\n          \"type\": \"method\",\n          \"name\": \"trace\",\n          \"desc\": \"<p>Print a stack trace to stderr of the current position.\\n\\n</p>\\n\",\n          \"signatures\": [\n            {\n              \"params\": [\n                {\n                  \"name\": \"label\"\n                }\n              ]\n            }\n          ]\n        },\n        {\n          \"textRaw\": \"console.assert(expression, [message])\",\n          \"type\": \"method\",\n          \"name\": \"assert\",\n          \"desc\": \"<p>Same as [assert.ok()][] where if the <code>expression</code> evaluates as <code>false</code> throw an\\nAssertionError with <code>message</code>.\\n\\n</p>\\n\",\n          \"signatures\": [\n            {\n              \"params\": [\n                {\n                  \"name\": \"expression\"\n                },\n                {\n                  \"name\": \"message\",\n                  \"optional\": true\n                }\n              ]\n            }\n          ]\n        }\n      ]\n    }\n  ]\n}\n"}{"source":"http://nodejs.org/api/addons.json","title":"C/C++ Addons","content":"{\n  \"source\": \"doc/api/addons.markdown\",\n  \"modules\": [\n    {\n      \"textRaw\": \"Addons\",\n      \"name\": \"addons\",\n      \"desc\": \"<p>Addons are dynamically linked shared objects. They can provide glue to C and\\nC++ libraries. The API (at the moment) is rather complex, involving\\nknowledge of several libraries:\\n\\n</p>\\n<ul>\\n<li><p>V8 JavaScript, a C++ library. Used for interfacing with JavaScript:\\ncreating objects, calling functions, etc.  Documented mostly in the\\n<code>v8.h</code> header file (<code>deps/v8/include/v8.h</code> in the Node source\\ntree), which is also available\\n<a href=\\\"http://izs.me/v8-docs/main.html\\\">online</a>.</p>\\n</li>\\n<li><p><a href=\\\"https://github.com/joyent/libuv\\\">libuv</a>, C event loop library.\\nAnytime one needs to wait for a file descriptor to become readable,\\nwait for a timer, or wait for a signal to be received one will need\\nto interface with libuv. That is, if you perform any I/O, libuv will\\nneed to be used.</p>\\n</li>\\n<li><p>Internal Node libraries. Most importantly is the <code>node::ObjectWrap</code>\\nclass which you will likely want to derive from.</p>\\n</li>\\n<li><p>Others. Look in <code>deps/</code> for what else is available.</p>\\n</li>\\n</ul>\\n<p>Node statically compiles all its dependencies into the executable.\\nWhen compiling your module, you don&#39;t need to worry about linking to\\nany of these libraries.\\n\\n</p>\\n<p>All of the following examples are available for\\n<a href=\\\"https://github.com/rvagg/node-addon-examples\\\">download</a> and may be\\nused as a starting-point for your own Addon.\\n\\n</p>\\n\",\n      \"modules\": [\n        {\n          \"textRaw\": \"Hello world\",\n          \"name\": \"hello_world\",\n          \"desc\": \"<p>To get started let&#39;s make a small Addon which is the C++ equivalent of\\nthe following JavaScript code:\\n\\n</p>\\n<pre><code>module.exports.hello = function() { return &#39;world&#39;; };</code></pre>\\n<p>First we create a file <code>hello.cc</code>:\\n\\n</p>\\n<pre><code>#include &lt;node.h&gt;\\n#include &lt;v8.h&gt;\\n\\nusing namespace v8;\\n\\nHandle&lt;Value&gt; Method(const Arguments&amp; args) {\\n  HandleScope scope;\\n  return scope.Close(String::New(&quot;world&quot;));\\n}\\n\\nvoid init(Handle&lt;Object&gt; exports) {\\n  exports-&gt;Set(String::NewSymbol(&quot;hello&quot;),\\n      FunctionTemplate::New(Method)-&gt;GetFunction());\\n}\\n\\nNODE_MODULE(hello, init)</code></pre>\\n<p>Note that all Node addons must export an initialization function:\\n\\n</p>\\n<pre><code>void Initialize (Handle&lt;Object&gt; exports);\\nNODE_MODULE(module_name, Initialize)</code></pre>\\n<p>There is no semi-colon after <code>NODE_MODULE</code> as it&#39;s not a function (see <code>node.h</code>).\\n\\n</p>\\n<p>The <code>module_name</code> needs to match the filename of the final binary (minus the\\n.node suffix).\\n\\n</p>\\n<p>The source code needs to be built into <code>hello.node</code>, the binary Addon. To\\ndo this we create a file called <code>binding.gyp</code> which describes the configuration\\nto build your module in a JSON-like format. This file gets compiled by\\n<a href=\\\"https://github.com/TooTallNate/node-gyp\\\">node-gyp</a>.\\n\\n</p>\\n<pre><code>{\\n  &quot;targets&quot;: [\\n    {\\n      &quot;target_name&quot;: &quot;hello&quot;,\\n      &quot;sources&quot;: [ &quot;hello.cc&quot; ]\\n    }\\n  ]\\n}</code></pre>\\n<p>The next step is to generate the appropriate project build files for the\\ncurrent platform. Use <code>node-gyp configure</code> for that.\\n\\n</p>\\n<p>Now you will have either a <code>Makefile</code> (on Unix platforms) or a <code>vcxproj</code> file\\n(on Windows) in the <code>build/</code> directory. Next invoke the <code>node-gyp build</code>\\ncommand.\\n\\n</p>\\n<p>Now you have your compiled <code>.node</code> bindings file! The compiled bindings end up\\nin <code>build/Release/</code>.\\n\\n</p>\\n<p>You can now use the binary addon in a Node project <code>hello.js</code> by pointing <code>require</code> to\\nthe recently built <code>hello.node</code> module:\\n\\n</p>\\n<pre><code>var addon = require(&#39;./build/Release/hello&#39;);\\n\\nconsole.log(addon.hello()); // &#39;world&#39;</code></pre>\\n<p>Please see patterns below for further information or\\n</p>\\n<p><a href=\\\"https://github.com/arturadib/node-qt\\\">https://github.com/arturadib/node-qt</a> for an example in production.\\n\\n\\n</p>\\n\",\n          \"type\": \"module\",\n          \"displayName\": \"Hello world\"\n        },\n        {\n          \"textRaw\": \"Addon patterns\",\n          \"name\": \"addon_patterns\",\n          \"desc\": \"<p>Below are some addon patterns to help you get started. Consult the online\\n<a href=\\\"http://izs.me/v8-docs/main.html\\\">v8 reference</a> for help with the various v8\\ncalls, and v8&#39;s <a href=\\\"http://code.google.com/apis/v8/embed.html\\\">Embedder&#39;s Guide</a>\\nfor an explanation of several concepts used such as handles, scopes,\\nfunction templates, etc.\\n\\n</p>\\n<p>In order to use these examples you need to compile them using <code>node-gyp</code>.\\nCreate the following <code>binding.gyp</code> file:\\n\\n</p>\\n<pre><code>{\\n  &quot;targets&quot;: [\\n    {\\n      &quot;target_name&quot;: &quot;addon&quot;,\\n      &quot;sources&quot;: [ &quot;addon.cc&quot; ]\\n    }\\n  ]\\n}</code></pre>\\n<p>In cases where there is more than one <code>.cc</code> file, simply add the file name to the\\n<code>sources</code> array, e.g.:\\n\\n</p>\\n<pre><code>&quot;sources&quot;: [&quot;addon.cc&quot;, &quot;myexample.cc&quot;]</code></pre>\\n<p>Now that you have your <code>binding.gyp</code> ready, you can configure and build the\\naddon:\\n\\n</p>\\n<pre><code>$ node-gyp configure build</code></pre>\\n\",\n          \"modules\": [\n            {\n              \"textRaw\": \"Function arguments\",\n              \"name\": \"function_arguments\",\n              \"desc\": \"<p>The following pattern illustrates how to read arguments from JavaScript\\nfunction calls and return a result. This is the main and only needed source\\n<code>addon.cc</code>:\\n\\n</p>\\n<pre><code>#define BUILDING_NODE_EXTENSION\\n#include &lt;node.h&gt;\\n\\nusing namespace v8;\\n\\nHandle&lt;Value&gt; Add(const Arguments&amp; args) {\\n  HandleScope scope;\\n\\n  if (args.Length() &lt; 2) {\\n    ThrowException(Exception::TypeError(String::New(&quot;Wrong number of arguments&quot;)));\\n    return scope.Close(Undefined());\\n  }\\n\\n  if (!args[0]-&gt;IsNumber() || !args[1]-&gt;IsNumber()) {\\n    ThrowException(Exception::TypeError(String::New(&quot;Wrong arguments&quot;)));\\n    return scope.Close(Undefined());\\n  }\\n\\n  Local&lt;Number&gt; num = Number::New(args[0]-&gt;NumberValue() +\\n      args[1]-&gt;NumberValue());\\n  return scope.Close(num);\\n}\\n\\nvoid Init(Handle&lt;Object&gt; exports) {\\n  exports-&gt;Set(String::NewSymbol(&quot;add&quot;),\\n      FunctionTemplate::New(Add)-&gt;GetFunction());\\n}\\n\\nNODE_MODULE(addon, Init)</code></pre>\\n<p>You can test it with the following JavaScript snippet:\\n\\n</p>\\n<pre><code>var addon = require(&#39;./build/Release/addon&#39;);\\n\\nconsole.log( &#39;This should be eight:&#39;, addon.add(3,5) );</code></pre>\\n\",\n              \"type\": \"module\",\n              \"displayName\": \"Function arguments\"\n            },\n            {\n              \"textRaw\": \"Callbacks\",\n              \"name\": \"callbacks\",\n              \"desc\": \"<p>You can pass JavaScript functions to a C++ function and execute them from\\nthere. Here&#39;s <code>addon.cc</code>:\\n\\n</p>\\n<pre><code>#define BUILDING_NODE_EXTENSION\\n#include &lt;node.h&gt;\\n\\nusing namespace v8;\\n\\nHandle&lt;Value&gt; RunCallback(const Arguments&amp; args) {\\n  HandleScope scope;\\n\\n  Local&lt;Function&gt; cb = Local&lt;Function&gt;::Cast(args[0]);\\n  const unsigned argc = 1;\\n  Local&lt;Value&gt; argv[argc] = { Local&lt;Value&gt;::New(String::New(&quot;hello world&quot;)) };\\n  cb-&gt;Call(Context::GetCurrent()-&gt;Global(), argc, argv);\\n\\n  return scope.Close(Undefined());\\n}\\n\\nvoid Init(Handle&lt;Object&gt; exports, Handle&lt;Object&gt; module) {\\n  module-&gt;Set(String::NewSymbol(&quot;exports&quot;),\\n      FunctionTemplate::New(RunCallback)-&gt;GetFunction());\\n}\\n\\nNODE_MODULE(addon, Init)</code></pre>\\n<p>Note that this example uses a two-argument form of <code>Init()</code> that receives\\nthe full <code>module</code> object as the second argument. This allows the addon\\nto completely overwrite <code>exports</code> with a single function instead of\\nadding the function as a property of <code>exports</code>.\\n\\n</p>\\n<p>To test it run the following JavaScript snippet:\\n\\n</p>\\n<pre><code>var addon = require(&#39;./build/Release/addon&#39;);\\n\\naddon(function(msg){\\n  console.log(msg); // &#39;hello world&#39;\\n});</code></pre>\\n\",\n              \"type\": \"module\",\n              \"displayName\": \"Callbacks\"\n            },\n            {\n              \"textRaw\": \"Object factory\",\n              \"name\": \"object_factory\",\n              \"desc\": \"<p>You can create and return new objects from within a C++ function with this\\n<code>addon.cc</code> pattern, which returns an object with property <code>msg</code> that echoes\\nthe string passed to <code>createObject()</code>:\\n\\n</p>\\n<pre><code>#define BUILDING_NODE_EXTENSION\\n#include &lt;node.h&gt;\\n\\nusing namespace v8;\\n\\nHandle&lt;Value&gt; CreateObject(const Arguments&amp; args) {\\n  HandleScope scope;\\n\\n  Local&lt;Object&gt; obj = Object::New();\\n  obj-&gt;Set(String::NewSymbol(&quot;msg&quot;), args[0]-&gt;ToString());\\n\\n  return scope.Close(obj);\\n}\\n\\nvoid Init(Handle&lt;Object&gt; exports, Handle&lt;Object&gt; module) {\\n  module-&gt;Set(String::NewSymbol(&quot;exports&quot;),\\n      FunctionTemplate::New(CreateObject)-&gt;GetFunction());\\n}\\n\\nNODE_MODULE(addon, Init)</code></pre>\\n<p>To test it in JavaScript:\\n\\n</p>\\n<pre><code>var addon = require(&#39;./build/Release/addon&#39;);\\n\\nvar obj1 = addon(&#39;hello&#39;);\\nvar obj2 = addon(&#39;world&#39;);\\nconsole.log(obj1.msg+&#39; &#39;+obj2.msg); // &#39;hello world&#39;</code></pre>\\n\",\n              \"type\": \"module\",\n              \"displayName\": \"Object factory\"\n            },\n            {\n              \"textRaw\": \"Function factory\",\n              \"name\": \"function_factory\",\n              \"desc\": \"<p>This pattern illustrates how to create and return a JavaScript function that\\nwraps a C++ function:\\n\\n</p>\\n<pre><code>#define BUILDING_NODE_EXTENSION\\n#include &lt;node.h&gt;\\n\\nusing namespace v8;\\n\\nHandle&lt;Value&gt; MyFunction(const Arguments&amp; args) {\\n  HandleScope scope;\\n  return scope.Close(String::New(&quot;hello world&quot;));\\n}\\n\\nHandle&lt;Value&gt; CreateFunction(const Arguments&amp; args) {\\n  HandleScope scope;\\n\\n  Local&lt;FunctionTemplate&gt; tpl = FunctionTemplate::New(MyFunction);\\n  Local&lt;Function&gt; fn = tpl-&gt;GetFunction();\\n  fn-&gt;SetName(String::NewSymbol(&quot;theFunction&quot;)); // omit this to make it anonymous\\n\\n  return scope.Close(fn);\\n}\\n\\nvoid Init(Handle&lt;Object&gt; exports, Handle&lt;Object&gt; module) {\\n  module-&gt;Set(String::NewSymbol(&quot;exports&quot;),\\n      FunctionTemplate::New(CreateFunction)-&gt;GetFunction());\\n}\\n\\nNODE_MODULE(addon, Init)</code></pre>\\n<p>To test:\\n\\n</p>\\n<pre><code>var addon = require(&#39;./build/Release/addon&#39;);\\n\\nvar fn = addon();\\nconsole.log(fn()); // &#39;hello world&#39;</code></pre>\\n\",\n              \"type\": \"module\",\n              \"displayName\": \"Function factory\"\n            },\n            {\n              \"textRaw\": \"Wrapping C++ objects\",\n              \"name\": \"wrapping_c++_objects\",\n              \"desc\": \"<p>Here we will create a wrapper for a C++ object/class <code>MyObject</code> that can be\\ninstantiated in JavaScript through the <code>new</code> operator. First prepare the main\\nmodule <code>addon.cc</code>:\\n\\n</p>\\n<pre><code>#define BUILDING_NODE_EXTENSION\\n#include &lt;node.h&gt;\\n#include &quot;myobject.h&quot;\\n\\nusing namespace v8;\\n\\nvoid InitAll(Handle&lt;Object&gt; exports) {\\n  MyObject::Init(exports);\\n}\\n\\nNODE_MODULE(addon, InitAll)</code></pre>\\n<p>Then in <code>myobject.h</code> make your wrapper inherit from <code>node::ObjectWrap</code>:\\n\\n</p>\\n<pre><code>#ifndef MYOBJECT_H\\n#define MYOBJECT_H\\n\\n#include &lt;node.h&gt;\\n\\nclass MyObject : public node::ObjectWrap {\\n public:\\n  static void Init(v8::Handle&lt;v8::Object&gt; exports);\\n\\n private:\\n  explicit MyObject(double value = 0);\\n  ~MyObject();\\n\\n  static v8::Handle&lt;v8::Value&gt; New(const v8::Arguments&amp; args);\\n  static v8::Handle&lt;v8::Value&gt; PlusOne(const v8::Arguments&amp; args);\\n  static v8::Persistent&lt;v8::Function&gt; constructor;\\n  double value_;\\n};\\n\\n#endif</code></pre>\\n<p>And in <code>myobject.cc</code> implement the various methods that you want to expose.\\nHere we expose the method <code>plusOne</code> by adding it to the constructor&#39;s\\nprototype:\\n\\n</p>\\n<pre><code>#define BUILDING_NODE_EXTENSION\\n#include &lt;node.h&gt;\\n#include &quot;myobject.h&quot;\\n\\nusing namespace v8;\\n\\nPersistent&lt;Function&gt; MyObject::constructor;\\n\\nMyObject::MyObject(double value) : value_(value) {\\n}\\n\\nMyObject::~MyObject() {\\n}\\n\\nvoid MyObject::Init(Handle&lt;Object&gt; exports) {\\n  // Prepare constructor template\\n  Local&lt;FunctionTemplate&gt; tpl = FunctionTemplate::New(New);\\n  tpl-&gt;SetClassName(String::NewSymbol(&quot;MyObject&quot;));\\n  tpl-&gt;InstanceTemplate()-&gt;SetInternalFieldCount(1);\\n  // Prototype\\n  tpl-&gt;PrototypeTemplate()-&gt;Set(String::NewSymbol(&quot;plusOne&quot;),\\n      FunctionTemplate::New(PlusOne)-&gt;GetFunction());\\n  constructor = Persistent&lt;Function&gt;::New(tpl-&gt;GetFunction());\\n  exports-&gt;Set(String::NewSymbol(&quot;MyObject&quot;), constructor);\\n}\\n\\nHandle&lt;Value&gt; MyObject::New(const Arguments&amp; args) {\\n  HandleScope scope;\\n\\n  if (args.IsConstructCall()) {\\n    // Invoked as constructor: `new MyObject(...)`\\n    double value = args[0]-&gt;IsUndefined() ? 0 : args[0]-&gt;NumberValue();\\n    MyObject* obj = new MyObject(value);\\n    obj-&gt;Wrap(args.This());\\n    return args.This();\\n  } else {\\n    // Invoked as plain function `MyObject(...)`, turn into construct call.\\n    const int argc = 1;\\n    Local&lt;Value&gt; argv[argc] = { args[0] };\\n    return scope.Close(constructor-&gt;NewInstance(argc, argv));\\n  }\\n}\\n\\nHandle&lt;Value&gt; MyObject::PlusOne(const Arguments&amp; args) {\\n  HandleScope scope;\\n\\n  MyObject* obj = ObjectWrap::Unwrap&lt;MyObject&gt;(args.This());\\n  obj-&gt;value_ += 1;\\n\\n  return scope.Close(Number::New(obj-&gt;value_));\\n}</code></pre>\\n<p>Test it with:\\n\\n</p>\\n<pre><code>var addon = require(&#39;./build/Release/addon&#39;);\\n\\nvar obj = new addon.MyObject(10);\\nconsole.log( obj.plusOne() ); // 11\\nconsole.log( obj.plusOne() ); // 12\\nconsole.log( obj.plusOne() ); // 13</code></pre>\\n\",\n              \"type\": \"module\",\n              \"displayName\": \"Wrapping C++ objects\"\n            },\n            {\n              \"textRaw\": \"Factory of wrapped objects\",\n              \"name\": \"factory_of_wrapped_objects\",\n              \"desc\": \"<p>This is useful when you want to be able to create native objects without\\nexplicitly instantiating them with the <code>new</code> operator in JavaScript, e.g.\\n\\n</p>\\n<pre><code>var obj = addon.createObject();\\n// instead of:\\n// var obj = new addon.Object();</code></pre>\\n<p>Let&#39;s register our <code>createObject</code> method in <code>addon.cc</code>:\\n\\n</p>\\n<pre><code>#define BUILDING_NODE_EXTENSION\\n#include &lt;node.h&gt;\\n#include &quot;myobject.h&quot;\\n\\nusing namespace v8;\\n\\nHandle&lt;Value&gt; CreateObject(const Arguments&amp; args) {\\n  HandleScope scope;\\n  return scope.Close(MyObject::NewInstance(args));\\n}\\n\\nvoid InitAll(Handle&lt;Object&gt; exports, Handle&lt;Object&gt; module) {\\n  MyObject::Init();\\n\\n  module-&gt;Set(String::NewSymbol(&quot;exports&quot;),\\n      FunctionTemplate::New(CreateObject)-&gt;GetFunction());\\n}\\n\\nNODE_MODULE(addon, InitAll)</code></pre>\\n<p>In <code>myobject.h</code> we now introduce the static method <code>NewInstance</code> that takes\\ncare of instantiating the object (i.e. it does the job of <code>new</code> in JavaScript):\\n\\n</p>\\n<pre><code>#define BUILDING_NODE_EXTENSION\\n#ifndef MYOBJECT_H\\n#define MYOBJECT_H\\n\\n#include &lt;node.h&gt;\\n\\nclass MyObject : public node::ObjectWrap {\\n public:\\n  static void Init();\\n  static v8::Handle&lt;v8::Value&gt; NewInstance(const v8::Arguments&amp; args);\\n\\n private:\\n  explicit MyObject(double value = 0);\\n  ~MyObject();\\n\\n  static v8::Handle&lt;v8::Value&gt; New(const v8::Arguments&amp; args);\\n  static v8::Handle&lt;v8::Value&gt; PlusOne(const v8::Arguments&amp; args);\\n  static v8::Persistent&lt;v8::Function&gt; constructor;\\n  double value_;\\n};\\n\\n#endif</code></pre>\\n<p>The implementation is similar to the above in <code>myobject.cc</code>:\\n\\n</p>\\n<pre><code>#define BUILDING_NODE_EXTENSION\\n#include &lt;node.h&gt;\\n#include &quot;myobject.h&quot;\\n\\nusing namespace v8;\\n\\nPersistent&lt;Function&gt; MyObject::constructor;\\n\\nMyObject::MyObject(double value) : value_(value) {\\n}\\n\\nMyObject::~MyObject() {\\n}\\n\\nvoid MyObject::Init() {\\n  // Prepare constructor template\\n  Local&lt;FunctionTemplate&gt; tpl = FunctionTemplate::New(New);\\n  tpl-&gt;SetClassName(String::NewSymbol(&quot;MyObject&quot;));\\n  tpl-&gt;InstanceTemplate()-&gt;SetInternalFieldCount(1);\\n  // Prototype\\n  tpl-&gt;PrototypeTemplate()-&gt;Set(String::NewSymbol(&quot;plusOne&quot;),\\n      FunctionTemplate::New(PlusOne)-&gt;GetFunction());\\n  constructor = Persistent&lt;Function&gt;::New(tpl-&gt;GetFunction());\\n}\\n\\nHandle&lt;Value&gt; MyObject::New(const Arguments&amp; args) {\\n  HandleScope scope;\\n\\n  if (args.IsConstructCall()) {\\n    // Invoked as constructor: `new MyObject(...)`\\n    double value = args[0]-&gt;IsUndefined() ? 0 : args[0]-&gt;NumberValue();\\n    MyObject* obj = new MyObject(value);\\n    obj-&gt;Wrap(args.This());\\n    return args.This();\\n  } else {\\n    // Invoked as plain function `MyObject(...)`, turn into construct call.\\n    const int argc = 1;\\n    Local&lt;Value&gt; argv[argc] = { args[0] };\\n    return scope.Close(constructor-&gt;NewInstance(argc, argv));\\n  }\\n}\\n\\nHandle&lt;Value&gt; MyObject::NewInstance(const Arguments&amp; args) {\\n  HandleScope scope;\\n\\n  const unsigned argc = 1;\\n  Handle&lt;Value&gt; argv[argc] = { args[0] };\\n  Local&lt;Object&gt; instance = constructor-&gt;NewInstance(argc, argv);\\n\\n  return scope.Close(instance);\\n}\\n\\nHandle&lt;Value&gt; MyObject::PlusOne(const Arguments&amp; args) {\\n  HandleScope scope;\\n\\n  MyObject* obj = ObjectWrap::Unwrap&lt;MyObject&gt;(args.This());\\n  obj-&gt;value_ += 1;\\n\\n  return scope.Close(Number::New(obj-&gt;value_));\\n}</code></pre>\\n<p>Test it with:\\n\\n</p>\\n<pre><code>var createObject = require(&#39;./build/Release/addon&#39;);\\n\\nvar obj = createObject(10);\\nconsole.log( obj.plusOne() ); // 11\\nconsole.log( obj.plusOne() ); // 12\\nconsole.log( obj.plusOne() ); // 13\\n\\nvar obj2 = createObject(20);\\nconsole.log( obj2.plusOne() ); // 21\\nconsole.log( obj2.plusOne() ); // 22\\nconsole.log( obj2.plusOne() ); // 23</code></pre>\\n\",\n              \"type\": \"module\",\n              \"displayName\": \"Factory of wrapped objects\"\n            },\n            {\n              \"textRaw\": \"Passing wrapped objects around\",\n              \"name\": \"passing_wrapped_objects_around\",\n              \"desc\": \"<p>In addition to wrapping and returning C++ objects, you can pass them around\\nby unwrapping them with Node&#39;s <code>node::ObjectWrap::Unwrap</code> helper function.\\nIn the following <code>addon.cc</code> we introduce a function <code>add()</code> that can take on two\\n<code>MyObject</code> objects:\\n\\n</p>\\n<pre><code>#define BUILDING_NODE_EXTENSION\\n#include &lt;node.h&gt;\\n#include &quot;myobject.h&quot;\\n\\nusing namespace v8;\\n\\nHandle&lt;Value&gt; CreateObject(const Arguments&amp; args) {\\n  HandleScope scope;\\n  return scope.Close(MyObject::NewInstance(args));\\n}\\n\\nHandle&lt;Value&gt; Add(const Arguments&amp; args) {\\n  HandleScope scope;\\n\\n  MyObject* obj1 = node::ObjectWrap::Unwrap&lt;MyObject&gt;(\\n      args[0]-&gt;ToObject());\\n  MyObject* obj2 = node::ObjectWrap::Unwrap&lt;MyObject&gt;(\\n      args[1]-&gt;ToObject());\\n\\n  double sum = obj1-&gt;Value() + obj2-&gt;Value();\\n  return scope.Close(Number::New(sum));\\n}\\n\\nvoid InitAll(Handle&lt;Object&gt; exports) {\\n  MyObject::Init();\\n\\n  exports-&gt;Set(String::NewSymbol(&quot;createObject&quot;),\\n      FunctionTemplate::New(CreateObject)-&gt;GetFunction());\\n\\n  exports-&gt;Set(String::NewSymbol(&quot;add&quot;),\\n      FunctionTemplate::New(Add)-&gt;GetFunction());\\n}\\n\\nNODE_MODULE(addon, InitAll)</code></pre>\\n<p>To make things interesting we introduce a public method in <code>myobject.h</code> so we\\ncan probe private values after unwrapping the object:\\n\\n</p>\\n<pre><code>#define BUILDING_NODE_EXTENSION\\n#ifndef MYOBJECT_H\\n#define MYOBJECT_H\\n\\n#include &lt;node.h&gt;\\n\\nclass MyObject : public node::ObjectWrap {\\n public:\\n  static void Init();\\n  static v8::Handle&lt;v8::Value&gt; NewInstance(const v8::Arguments&amp; args);\\n  double Value() const { return value_; }\\n\\n private:\\n  explicit MyObject(double value = 0);\\n  ~MyObject();\\n\\n  static v8::Handle&lt;v8::Value&gt; New(const v8::Arguments&amp; args);\\n  static v8::Persistent&lt;v8::Function&gt; constructor;\\n  double value_;\\n};\\n\\n#endif</code></pre>\\n<p>The implementation of <code>myobject.cc</code> is similar as before:\\n\\n</p>\\n<pre><code>#define BUILDING_NODE_EXTENSION\\n#include &lt;node.h&gt;\\n#include &quot;myobject.h&quot;\\n\\nusing namespace v8;\\n\\nPersistent&lt;Function&gt; MyObject::constructor;\\n\\nMyObject::MyObject(double value) : value_(value) {\\n}\\n\\nMyObject::~MyObject() {\\n}\\n\\nvoid MyObject::Init() {\\n  // Prepare constructor template\\n  Local&lt;FunctionTemplate&gt; tpl = FunctionTemplate::New(New);\\n  tpl-&gt;SetClassName(String::NewSymbol(&quot;MyObject&quot;));\\n  tpl-&gt;InstanceTemplate()-&gt;SetInternalFieldCount(1);\\n  constructor = Persistent&lt;Function&gt;::New(tpl-&gt;GetFunction());\\n}\\n\\nHandle&lt;Value&gt; MyObject::New(const Arguments&amp; args) {\\n  HandleScope scope;\\n\\n  if (args.IsConstructCall()) {\\n    // Invoked as constructor: `new MyObject(...)`\\n    double value = args[0]-&gt;IsUndefined() ? 0 : args[0]-&gt;NumberValue();\\n    MyObject* obj = new MyObject(value);\\n    obj-&gt;Wrap(args.This());\\n    return args.This();\\n  } else {\\n    // Invoked as plain function `MyObject(...)`, turn into construct call.\\n    const int argc = 1;\\n    Local&lt;Value&gt; argv[argc] = { args[0] };\\n    return scope.Close(constructor-&gt;NewInstance(argc, argv));\\n  }\\n}\\n\\nHandle&lt;Value&gt; MyObject::NewInstance(const Arguments&amp; args) {\\n  HandleScope scope;\\n\\n  const unsigned argc = 1;\\n  Handle&lt;Value&gt; argv[argc] = { args[0] };\\n  Local&lt;Object&gt; instance = constructor-&gt;NewInstance(argc, argv);\\n\\n  return scope.Close(instance);\\n}</code></pre>\\n<p>Test it with:\\n\\n</p>\\n<pre><code>var addon = require(&#39;./build/Release/addon&#39;);\\n\\nvar obj1 = addon.createObject(10);\\nvar obj2 = addon.createObject(20);\\nvar result = addon.add(obj1, obj2);\\n\\nconsole.log(result); // 30</code></pre>\\n\",\n              \"type\": \"module\",\n              \"displayName\": \"Passing wrapped objects around\"\n            }\n          ],\n          \"type\": \"module\",\n          \"displayName\": \"Addon patterns\"\n        }\n      ],\n      \"type\": \"module\",\n      \"displayName\": \"Addons\"\n    }\n  ]\n}\n"}{"source":"http://nodejs.org/api/debugger.json","title":"Debugger","content":"{\n  \"source\": \"doc/api/debugger.markdown\",\n  \"stability\": 3,\n  \"stabilityText\": \"Stable\",\n  \"miscs\": [\n    {\n      \"textRaw\": \"Debugger\",\n      \"name\": \"Debugger\",\n      \"stability\": 3,\n      \"stabilityText\": \"Stable\",\n      \"type\": \"misc\",\n      \"desc\": \"<p>V8 comes with an extensive debugger which is accessible out-of-process via a\\nsimple <a href=\\\"http://code.google.com/p/v8/wiki/DebuggerProtocol\\\">TCP protocol</a>.\\nNode has a built-in client for this debugger. To use this, start Node with the\\n<code>debug</code> argument; a prompt will appear:\\n\\n</p>\\n<pre><code>% node debug myscript.js\\n&lt; debugger listening on port 5858\\nconnecting... ok\\nbreak in /home/indutny/Code/git/indutny/myscript.js:1\\n  1 x = 5;\\n  2 setTimeout(function () {\\n  3   debugger;\\ndebug&gt;</code></pre>\\n<p>Node&#39;s debugger client doesn&#39;t support the full range of commands, but\\nsimple step and inspection is possible. By putting the statement <code>debugger;</code>\\ninto the source code of your script, you will enable a breakpoint.\\n\\n</p>\\n<p>For example, suppose <code>myscript.js</code> looked like this:\\n\\n</p>\\n<pre><code>// myscript.js\\nx = 5;\\nsetTimeout(function () {\\n  debugger;\\n  console.log(&quot;world&quot;);\\n}, 1000);\\nconsole.log(&quot;hello&quot;);</code></pre>\\n<p>Then once the debugger is run, it will break on line 4.\\n\\n</p>\\n<pre><code>% node debug myscript.js\\n&lt; debugger listening on port 5858\\nconnecting... ok\\nbreak in /home/indutny/Code/git/indutny/myscript.js:1\\n  1 x = 5;\\n  2 setTimeout(function () {\\n  3   debugger;\\ndebug&gt; cont\\n&lt; hello\\nbreak in /home/indutny/Code/git/indutny/myscript.js:3\\n  1 x = 5;\\n  2 setTimeout(function () {\\n  3   debugger;\\n  4   console.log(&quot;world&quot;);\\n  5 }, 1000);\\ndebug&gt; next\\nbreak in /home/indutny/Code/git/indutny/myscript.js:4\\n  2 setTimeout(function () {\\n  3   debugger;\\n  4   console.log(&quot;world&quot;);\\n  5 }, 1000);\\n  6 console.log(&quot;hello&quot;);\\ndebug&gt; repl\\nPress Ctrl + C to leave debug repl\\n&gt; x\\n5\\n&gt; 2+2\\n4\\ndebug&gt; next\\n&lt; world\\nbreak in /home/indutny/Code/git/indutny/myscript.js:5\\n  3   debugger;\\n  4   console.log(&quot;world&quot;);\\n  5 }, 1000);\\n  6 console.log(&quot;hello&quot;);\\n  7\\ndebug&gt; quit\\n%</code></pre>\\n<p>The <code>repl</code> command allows you to evaluate code remotely. The <code>next</code> command\\nsteps over to the next line. There are a few other commands available and more\\nto come. Type <code>help</code> to see others.\\n\\n</p>\\n\",\n      \"miscs\": [\n        {\n          \"textRaw\": \"Watchers\",\n          \"name\": \"watchers\",\n          \"desc\": \"<p>You can watch expression and variable values while debugging your code.\\nOn every breakpoint each expression from the watchers list will be evaluated\\nin the current context and displayed just before the breakpoint&#39;s source code\\nlisting.\\n\\n</p>\\n<p>To start watching an expression, type <code>watch(&quot;my_expression&quot;)</code>. <code>watchers</code>\\nprints the active watchers. To remove a watcher, type\\n<code>unwatch(&quot;my_expression&quot;)</code>.\\n\\n</p>\\n\",\n          \"type\": \"misc\",\n          \"displayName\": \"Watchers\"\n        },\n        {\n          \"textRaw\": \"Commands reference\",\n          \"name\": \"commands_reference\",\n          \"modules\": [\n            {\n              \"textRaw\": \"Stepping\",\n              \"name\": \"Stepping\",\n              \"desc\": \"<p>It is also possible to set a breakpoint in a file (module) that\\nisn&#39;t loaded yet:\\n\\n</p>\\n<pre><code>% ./node debug test/fixtures/break-in-module/main.js\\n&lt; debugger listening on port 5858\\nconnecting to port 5858... ok\\nbreak in test/fixtures/break-in-module/main.js:1\\n  1 var mod = require(&#39;./mod.js&#39;);\\n  2 mod.hello();\\n  3 mod.hello();\\ndebug&gt; setBreakpoint(&#39;mod.js&#39;, 23)\\nWarning: script &#39;mod.js&#39; was not loaded yet.\\n  1 var mod = require(&#39;./mod.js&#39;);\\n  2 mod.hello();\\n  3 mod.hello();\\ndebug&gt; c\\nbreak in test/fixtures/break-in-module/mod.js:23\\n 21\\n 22 exports.hello = function() {\\n 23   return &#39;hello from module&#39;;\\n 24 };\\n 25\\ndebug&gt;</code></pre>\\n\",\n              \"type\": \"module\",\n              \"displayName\": \"Breakpoints\"\n            },\n            {\n              \"textRaw\": \"Breakpoints\",\n              \"name\": \"breakpoints\",\n              \"desc\": \"<p>It is also possible to set a breakpoint in a file (module) that\\nisn&#39;t loaded yet:\\n\\n</p>\\n<pre><code>% ./node debug test/fixtures/break-in-module/main.js\\n&lt; debugger listening on port 5858\\nconnecting to port 5858... ok\\nbreak in test/fixtures/break-in-module/main.js:1\\n  1 var mod = require(&#39;./mod.js&#39;);\\n  2 mod.hello();\\n  3 mod.hello();\\ndebug&gt; setBreakpoint(&#39;mod.js&#39;, 23)\\nWarning: script &#39;mod.js&#39; was not loaded yet.\\n  1 var mod = require(&#39;./mod.js&#39;);\\n  2 mod.hello();\\n  3 mod.hello();\\ndebug&gt; c\\nbreak in test/fixtures/break-in-module/mod.js:23\\n 21\\n 22 exports.hello = function() {\\n 23   return &#39;hello from module&#39;;\\n 24 };\\n 25\\ndebug&gt;</code></pre>\\n\",\n              \"type\": \"module\",\n              \"displayName\": \"Breakpoints\"\n            },\n            {\n              \"textRaw\": \"Execution control\",\n              \"name\": \"Execution control\",\n              \"type\": \"module\",\n              \"displayName\": \"Various\"\n            },\n            {\n              \"textRaw\": \"Various\",\n              \"name\": \"various\",\n              \"type\": \"module\",\n              \"displayName\": \"Various\"\n            }\n          ],\n          \"type\": \"misc\",\n          \"displayName\": \"Commands reference\"\n        },\n        {\n          \"textRaw\": \"Advanced Usage\",\n          \"name\": \"advanced_usage\",\n          \"desc\": \"<p>The V8 debugger can be enabled and accessed either by starting Node with\\nthe <code>--debug</code> command-line flag or by signaling an existing Node process\\nwith <code>SIGUSR1</code>.\\n\\n</p>\\n<p>Once a process has been set in debug mode with this it can be connected to\\nwith the node debugger. Either connect to the <code>pid</code> or the URI to the debugger.\\nThe syntax is:\\n\\n</p>\\n<ul>\\n<li><code>node debug -p &lt;pid&gt;</code> - Connects to the process via the <code>pid</code></li>\\n<li><code>node debug &lt;URI&gt;</code> - Connects to the process via the URI such as localhost:5858</li>\\n</ul>\\n\",\n          \"type\": \"misc\",\n          \"displayName\": \"Advanced Usage\"\n        }\n      ]\n    }\n  ]\n}\n"}{"source":"http://nodejs.org/api/cluster.json","title":"Cluster","content":"{\n  \"source\": \"doc/api/cluster.markdown\",\n  \"modules\": [\n    {\n      \"textRaw\": \"Cluster\",\n      \"name\": \"cluster\",\n      \"stability\": 1,\n      \"stabilityText\": \"Experimental\",\n      \"desc\": \"<p>A single instance of Node runs in a single thread. To take advantage of\\nmulti-core systems the user will sometimes want to launch a cluster of Node\\nprocesses to handle the load.\\n\\n</p>\\n<p>The cluster module allows you to easily create child processes that\\nall share server ports.\\n\\n</p>\\n<pre><code>var cluster = require(&#39;cluster&#39;);\\nvar http = require(&#39;http&#39;);\\nvar numCPUs = require(&#39;os&#39;).cpus().length;\\n\\nif (cluster.isMaster) {\\n  // Fork workers.\\n  for (var i = 0; i &lt; numCPUs; i++) {\\n    cluster.fork();\\n  }\\n\\n  cluster.on(&#39;exit&#39;, function(worker, code, signal) {\\n    console.log(&#39;worker &#39; + worker.process.pid + &#39; died&#39;);\\n  });\\n} else {\\n  // Workers can share any TCP connection\\n  // In this case its a HTTP server\\n  http.createServer(function(req, res) {\\n    res.writeHead(200);\\n    res.end(&quot;hello world\\\\n&quot;);\\n  }).listen(8000);\\n}</code></pre>\\n<p>Running node will now share port 8000 between the workers:\\n\\n</p>\\n<pre><code>% NODE_DEBUG=cluster node server.js\\n23521,Master Worker 23524 online\\n23521,Master Worker 23526 online\\n23521,Master Worker 23523 online\\n23521,Master Worker 23528 online</code></pre>\\n<p>This feature was introduced recently, and may change in future versions.\\nPlease try it out and provide feedback.\\n\\n</p>\\n<p>Also note that, on Windows, it is not yet possible to set up a named pipe\\nserver in a worker.\\n\\n</p>\\n\",\n      \"miscs\": [\n        {\n          \"textRaw\": \"How It Works\",\n          \"name\": \"How It Works\",\n          \"type\": \"misc\",\n          \"desc\": \"<p>The worker processes are spawned using the <code>child_process.fork</code> method,\\nso that they can communicate with the parent via IPC and pass server\\nhandles back and forth.\\n\\n</p>\\n<p>When you call <code>server.listen(...)</code> in a worker, it serializes the\\narguments and passes the request to the master process.  If the master\\nprocess already has a listening server matching the worker&#39;s\\nrequirements, then it passes the handle to the worker.  If it does not\\nalready have a listening server matching that requirement, then it will\\ncreate one, and pass the handle to the worker.\\n\\n</p>\\n<p>This causes potentially surprising behavior in three edge cases:\\n\\n</p>\\n<ol>\\n<li><code>server.listen({fd: 7})</code> Because the message is passed to the master,\\nfile descriptor 7 <strong>in the parent</strong> will be listened on, and the\\nhandle passed to the worker, rather than listening to the worker&#39;s\\nidea of what the number 7 file descriptor references.</li>\\n<li><code>server.listen(handle)</code> Listening on handles explicitly will cause\\nthe worker to use the supplied handle, rather than talk to the master\\nprocess.  If the worker already has the handle, then it&#39;s presumed\\nthat you know what you are doing.</li>\\n<li><code>server.listen(0)</code> Normally, this will cause servers to listen on a\\nrandom port.  However, in a cluster, each worker will receive the\\nsame &quot;random&quot; port each time they do <code>listen(0)</code>.  In essence, the\\nport is random the first time, but predictable thereafter.  If you\\nwant to listen on a unique port, generate a port number based on the\\ncluster worker ID.</li>\\n</ol>\\n<p>When multiple processes are all <code>accept()</code>ing on the same underlying\\nresource, the operating system load-balances across them very\\nefficiently.  There is no routing logic in Node.js, or in your program,\\nand no shared state between the workers.  Therefore, it is important to\\ndesign your program such that it does not rely too heavily on in-memory\\ndata objects for things like sessions and login.\\n\\n</p>\\n<p>Because workers are all separate processes, they can be killed or\\nre-spawned depending on your program&#39;s needs, without affecting other\\nworkers.  As long as there are some workers still alive, the server will\\ncontinue to accept connections.  Node does not automatically manage the\\nnumber of workers for you, however.  It is your responsibility to manage\\nthe worker pool for your application&#39;s needs.\\n\\n</p>\\n\"\n        }\n      ],\n      \"properties\": [\n        {\n          \"textRaw\": \"`settings` {Object} \",\n          \"name\": \"settings\",\n          \"options\": [\n            {\n              \"textRaw\": \"`execArgv` {Array} list of string arguments passed to the node executable.  (Default=`process.execArgv`) \",\n              \"name\": \"execArgv\",\n              \"default\": \"process.execArgv\",\n              \"type\": \"Array\",\n              \"desc\": \"list of string arguments passed to the node executable.\"\n            },\n            {\n              \"textRaw\": \"`exec` {String} file path to worker file.  (Default=`process.argv[1]`) \",\n              \"name\": \"exec\",\n              \"default\": \"process.argv[1]\",\n              \"type\": \"String\",\n              \"desc\": \"file path to worker file.\"\n            },\n            {\n              \"textRaw\": \"`args` {Array} string arguments passed to worker. (Default=`process.argv.slice(2)`) \",\n              \"name\": \"args\",\n              \"default\": \"process.argv.slice(2)\",\n              \"type\": \"Array\",\n              \"desc\": \"string arguments passed to worker.\"\n            },\n            {\n              \"textRaw\": \"`silent` {Boolean} whether or not to send output to parent's stdio. (Default=`false`) \",\n              \"name\": \"silent\",\n              \"default\": \"false\",\n              \"type\": \"Boolean\",\n              \"desc\": \"whether or not to send output to parent's stdio.\"\n            }\n          ],\n          \"desc\": \"<p>After calling <code>.setupMaster()</code> (or <code>.fork()</code>) this settings object will contain\\nthe settings, including the default values.\\n\\n</p>\\n<p>It is effectively frozen after being set, because <code>.setupMaster()</code> can\\nonly be called once.\\n\\n</p>\\n<p>This object is not supposed to be changed or set manually, by you.\\n\\n</p>\\n\"\n        },\n        {\n          \"textRaw\": \"`isMaster` {Boolean} \",\n          \"name\": \"isMaster\",\n          \"desc\": \"<p>True if the process is a master. This is determined\\nby the <code>process.env.NODE_UNIQUE_ID</code>. If <code>process.env.NODE_UNIQUE_ID</code> is\\nundefined, then <code>isMaster</code> is <code>true</code>.\\n\\n</p>\\n\"\n        },\n        {\n          \"textRaw\": \"`isWorker` {Boolean} \",\n          \"name\": \"isWorker\",\n          \"desc\": \"<p>True if the process is not a master (it is the negation of <code>cluster.isMaster</code>).\\n\\n</p>\\n\"\n        },\n        {\n          \"textRaw\": \"`worker` {Object} \",\n          \"name\": \"worker\",\n          \"desc\": \"<p>A reference to the current worker object. Not available in the master process.\\n\\n</p>\\n<pre><code>var cluster = require(&#39;cluster&#39;);\\n\\nif (cluster.isMaster) {\\n  console.log(&#39;I am master&#39;);\\n  cluster.fork();\\n  cluster.fork();\\n} else if (cluster.isWorker) {\\n  console.log(&#39;I am worker #&#39; + cluster.worker.id);\\n}</code></pre>\\n\"\n        },\n        {\n          \"textRaw\": \"`workers` {Object} \",\n          \"name\": \"workers\",\n          \"desc\": \"<p>A hash that stores the active worker objects, keyed by <code>id</code> field. Makes it\\neasy to loop through all the workers. It is only available in the master\\nprocess.\\n\\n</p>\\n<p>A worker is removed from cluster.workers just before the <code>&#39;disconnect&#39;</code> or\\n<code>&#39;exit&#39;</code> event is emitted.\\n\\n</p>\\n<pre><code>// Go through all workers\\nfunction eachWorker(callback) {\\n  for (var id in cluster.workers) {\\n    callback(cluster.workers[id]);\\n  }\\n}\\neachWorker(function(worker) {\\n  worker.send(&#39;big announcement to all workers&#39;);\\n});</code></pre>\\n<p>Should you wish to reference a worker over a communication channel, using\\nthe worker&#39;s unique id is the easiest way to find the worker.\\n\\n</p>\\n<pre><code>socket.on(&#39;data&#39;, function(id) {\\n  var worker = cluster.workers[id];\\n});</code></pre>\\n\"\n        }\n      ],\n      \"events\": [\n        {\n          \"textRaw\": \"Event: 'fork'\",\n          \"type\": \"event\",\n          \"name\": \"fork\",\n          \"params\": [],\n          \"desc\": \"<p>When a new worker is forked the cluster module will emit a &#39;fork&#39; event.\\nThis can be used to log worker activity, and create your own timeout.\\n\\n</p>\\n<pre><code>var timeouts = [];\\nfunction errorMsg() {\\n  console.error(&quot;Something must be wrong with the connection ...&quot;);\\n}\\n\\ncluster.on(&#39;fork&#39;, function(worker) {\\n  timeouts[worker.id] = setTimeout(errorMsg, 2000);\\n});\\ncluster.on(&#39;listening&#39;, function(worker, address) {\\n  clearTimeout(timeouts[worker.id]);\\n});\\ncluster.on(&#39;exit&#39;, function(worker, code, signal) {\\n  clearTimeout(timeouts[worker.id]);\\n  errorMsg();\\n});</code></pre>\\n\"\n        },\n        {\n          \"textRaw\": \"Event: 'online'\",\n          \"type\": \"event\",\n          \"name\": \"online\",\n          \"params\": [],\n          \"desc\": \"<p>After forking a new worker, the worker should respond with an online message.\\nWhen the master receives an online message it will emit this event.\\nThe difference between &#39;fork&#39; and &#39;online&#39; is that fork is emitted when the\\nmaster forks a worker, and &#39;online&#39; is emitted when the worker is running.\\n\\n</p>\\n<pre><code>cluster.on(&#39;online&#39;, function(worker) {\\n  console.log(&quot;Yay, the worker responded after it was forked&quot;);\\n});</code></pre>\\n\"\n        },\n        {\n          \"textRaw\": \"Event: 'listening'\",\n          \"type\": \"event\",\n          \"name\": \"listening\",\n          \"params\": [],\n          \"desc\": \"<p>After calling <code>listen()</code> from a worker, when the &#39;listening&#39; event is emitted on\\nthe server, a listening event will also be emitted on <code>cluster</code> in the master.\\n\\n</p>\\n<p>The event handler is executed with two arguments, the <code>worker</code> contains the worker\\nobject and the <code>address</code> object contains the following connection properties:\\n<code>address</code>, <code>port</code> and <code>addressType</code>. This is very useful if the worker is listening\\non more than one address.\\n\\n</p>\\n<pre><code>cluster.on(&#39;listening&#39;, function(worker, address) {\\n  console.log(&quot;A worker is now connected to &quot; + address.address + &quot;:&quot; + address.port);\\n});</code></pre>\\n<p>The <code>addressType</code> is one of:\\n\\n</p>\\n<ul>\\n<li><code>4</code> (TCPv4)</li>\\n<li><code>6</code> (TCPv6)</li>\\n<li><code>-1</code> (unix domain socket)</li>\\n<li><code>&quot;udp4&quot;</code> or <code>&quot;udp6&quot;</code> (UDP v4 or v6)</li>\\n</ul>\\n\"\n        },\n        {\n          \"textRaw\": \"Event: 'disconnect'\",\n          \"type\": \"event\",\n          \"name\": \"disconnect\",\n          \"params\": [],\n          \"desc\": \"<p>Emitted after the worker IPC channel has disconnected. This can occur when a\\nworker exits gracefully, is killed, or is disconnected manually (such as with\\nworker.disconnect()).\\n\\n</p>\\n<p>There may be a delay between the <code>disconnect</code> and <code>exit</code> events.  These events\\ncan be used to detect if the process is stuck in a cleanup or if there are\\nlong-living connections.\\n\\n</p>\\n<pre><code>cluster.on(&#39;disconnect&#39;, function(worker) {\\n  console.log(&#39;The worker #&#39; + worker.id + &#39; has disconnected&#39;);\\n});</code></pre>\\n\"\n        },\n        {\n          \"textRaw\": \"Event: 'exit'\",\n          \"type\": \"event\",\n          \"name\": \"exit\",\n          \"params\": [],\n          \"desc\": \"<p>When any of the workers die the cluster module will emit the &#39;exit&#39; event.\\n\\n</p>\\n<p>This can be used to restart the worker by calling <code>.fork()</code> again.\\n\\n</p>\\n<pre><code>cluster.on(&#39;exit&#39;, function(worker, code, signal) {\\n  console.log(&#39;worker %d died (%s). restarting...&#39;,\\n    worker.process.pid, signal || code);\\n  cluster.fork();\\n});</code></pre>\\n<p>See <a href=\\\"child_process.html#child_process_event_exit\\\">child_process event: &#39;exit&#39;</a>.\\n\\n</p>\\n\"\n        },\n        {\n          \"textRaw\": \"Event: 'setup'\",\n          \"type\": \"event\",\n          \"name\": \"setup\",\n          \"desc\": \"<p>Emitted the first time that <code>.setupMaster()</code> is called.\\n\\n</p>\\n\",\n          \"params\": []\n        }\n      ],\n      \"methods\": [\n        {\n          \"textRaw\": \"cluster.setupMaster([settings])\",\n          \"type\": \"method\",\n          \"name\": \"setupMaster\",\n          \"signatures\": [\n            {\n              \"params\": [\n                {\n                  \"textRaw\": \"`settings` {Object} \",\n                  \"options\": [\n                    {\n                      \"textRaw\": \"`exec` {String} file path to worker file.  (Default=`process.argv[1]`) \",\n                      \"name\": \"exec\",\n                      \"default\": \"process.argv[1]\",\n                      \"type\": \"String\",\n                      \"desc\": \"file path to worker file.\"\n                    },\n                    {\n                      \"textRaw\": \"`args` {Array} string arguments passed to worker. (Default=`process.argv.slice(2)`) \",\n                      \"name\": \"args\",\n                      \"default\": \"process.argv.slice(2)\",\n                      \"type\": \"Array\",\n                      \"desc\": \"string arguments passed to worker.\"\n                    },\n                    {\n                      \"textRaw\": \"`silent` {Boolean} whether or not to send output to parent's stdio. (Default=`false`) \",\n                      \"name\": \"silent\",\n                      \"default\": \"false\",\n                      \"type\": \"Boolean\",\n                      \"desc\": \"whether or not to send output to parent's stdio.\"\n                    }\n                  ],\n                  \"name\": \"settings\",\n                  \"type\": \"Object\",\n                  \"optional\": true\n                }\n              ]\n            },\n            {\n              \"params\": [\n                {\n                  \"name\": \"settings\",\n                  \"optional\": true\n                }\n              ]\n            }\n          ],\n          \"desc\": \"<p><code>setupMaster</code> is used to change the default &#39;fork&#39; behavior. Once called,\\nthe settings will be present in <code>cluster.settings</code>.\\n\\n</p>\\n<p>Note that:\\n\\n</p>\\n<ul>\\n<li>Only the first call to <code>.setupMaster()</code> has any effect, subsequent calls are\\nignored</li>\\n<li>That because of the above, the <em>only</em> attribute of a worker that may be\\ncustomized per-worker is the <code>env</code> passed to <code>.fork()</code></li>\\n<li><code>.fork()</code> calls <code>.setupMaster()</code> internally to establish the defaults, so to\\nhave any effect, <code>.setupMaster()</code> must be called <em>before</em> any calls to\\n<code>.fork()</code></li>\\n</ul>\\n<p>Example:\\n\\n</p>\\n<pre><code>var cluster = require(&quot;cluster&quot;);\\ncluster.setupMaster({\\n  exec : &quot;worker.js&quot;,\\n  args : [&quot;--use&quot;, &quot;https&quot;],\\n  silent : true\\n});\\ncluster.fork();</code></pre>\\n<p>This can only be called from the master process.\\n\\n</p>\\n\"\n        },\n        {\n          \"textRaw\": \"cluster.fork([env])\",\n          \"type\": \"method\",\n          \"name\": \"fork\",\n          \"signatures\": [\n            {\n              \"return\": {\n                \"textRaw\": \"return {Worker object} \",\n                \"name\": \"return\",\n                \"type\": \"Worker object\"\n              },\n              \"params\": [\n                {\n                  \"textRaw\": \"`env` {Object} Key/value pairs to add to worker process environment. \",\n                  \"name\": \"env\",\n                  \"type\": \"Object\",\n                  \"desc\": \"Key/value pairs to add to worker process environment.\",\n                  \"optional\": true\n                }\n              ]\n            },\n            {\n              \"params\": [\n                {\n                  \"name\": \"env\",\n                  \"optional\": true\n                }\n              ]\n            }\n          ],\n          \"desc\": \"<p>Spawn a new worker process.\\n\\n</p>\\n<p>This can only be called from the master process.\\n\\n</p>\\n\"\n        },\n        {\n          \"textRaw\": \"cluster.disconnect([callback])\",\n          \"type\": \"method\",\n          \"name\": \"disconnect\",\n          \"signatures\": [\n            {\n              \"params\": [\n                {\n                  \"textRaw\": \"`callback` {Function} called when all workers are disconnected and handles are closed \",\n                  \"name\": \"callback\",\n                  \"type\": \"Function\",\n                  \"desc\": \"called when all workers are disconnected and handles are closed\",\n                  \"optional\": true\n                }\n              ]\n            },\n            {\n              \"params\": [\n                {\n                  \"name\": \"callback\",\n                  \"optional\": true\n                }\n              ]\n            }\n          ],\n          \"desc\": \"<p>Calls <code>.disconnect()</code> on each worker in <code>cluster.workers</code>.\\n\\n</p>\\n<p>When they are disconnected all internal handles will be closed, allowing the\\nmaster process to die gracefully if no other event is waiting.\\n\\n</p>\\n<p>The method takes an optional callback argument which will be called when finished.\\n\\n</p>\\n<p>This can only be called from the master process.\\n\\n</p>\\n\"\n        }\n      ],\n      \"classes\": [\n        {\n          \"textRaw\": \"Class: Worker\",\n          \"type\": \"class\",\n          \"name\": \"Worker\",\n          \"desc\": \"<p>A Worker object contains all public information and method about a worker.\\nIn the master it can be obtained using <code>cluster.workers</code>. In a worker\\nit can be obtained using <code>cluster.worker</code>.\\n\\n</p>\\n\",\n          \"properties\": [\n            {\n              \"textRaw\": \"`id` {String} \",\n              \"name\": \"id\",\n              \"desc\": \"<p>Each new worker is given its own unique id, this id is stored in the\\n<code>id</code>.\\n\\n</p>\\n<p>While a worker is alive, this is the key that indexes it in\\ncluster.workers\\n\\n</p>\\n\"\n            },\n            {\n              \"textRaw\": \"`process` {ChildProcess object} \",\n              \"name\": \"process\",\n              \"desc\": \"<p>All workers are created using <code>child_process.fork()</code>, the returned object\\nfrom this function is stored as <code>.process</code>. In a worker, the global <code>process</code>\\nis stored.\\n\\n</p>\\n<p>See: <a href=\\\"child_process.html#child_process_child_process_fork_modulepath_args_options\\\">Child Process module</a>\\n\\n</p>\\n<p>Note that workers will call <code>process.exit(0)</code> if the <code>&#39;disconnect&#39;</code> event occurs\\non <code>process</code> and <code>.suicide</code> is not <code>true</code>. This protects against accidental\\ndisconnection.\\n\\n</p>\\n\"\n            },\n            {\n              \"textRaw\": \"`suicide` {Boolean} \",\n              \"name\": \"suicide\",\n              \"desc\": \"<p>Set by calling <code>.kill()</code> or <code>.disconnect()</code>, until then it is <code>undefined</code>.\\n\\n</p>\\n<p>The boolean <code>worker.suicide</code> lets you distinguish between voluntary and accidental\\nexit, the master may choose not to respawn a worker based on this value.\\n\\n</p>\\n<pre><code>cluster.on(&#39;exit&#39;, function(worker, code, signal) {\\n  if (worker.suicide === true) {\\n    console.log(&#39;Oh, it was just suicide\\\\&#39; – no need to worry&#39;).\\n  }\\n});\\n\\n// kill worker\\nworker.kill();</code></pre>\\n\"\n            }\n          ],\n          \"methods\": [\n            {\n              \"textRaw\": \"worker.send(message, [sendHandle])\",\n              \"type\": \"method\",\n              \"name\": \"send\",\n              \"signatures\": [\n                {\n                  \"params\": [\n                    {\n                      \"textRaw\": \"`message` {Object} \",\n                      \"name\": \"message\",\n                      \"type\": \"Object\"\n                    },\n                    {\n                      \"textRaw\": \"`sendHandle` {Handle object} \",\n                      \"name\": \"sendHandle\",\n                      \"type\": \"Handle object\",\n                      \"optional\": true\n                    }\n                  ]\n                },\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"message\"\n                    },\n                    {\n                      \"name\": \"sendHandle\",\n                      \"optional\": true\n                    }\n                  ]\n                }\n              ],\n              \"desc\": \"<p>This function is equal to the send methods provided by\\n<code>child_process.fork()</code>.  In the master you should use this function to\\nsend a message to a specific worker.\\n\\n</p>\\n<p>In a worker you can also use <code>process.send(message)</code>, it is the same function.\\n\\n</p>\\n<p>This example will echo back all messages from the master:\\n\\n</p>\\n<pre><code>if (cluster.isMaster) {\\n  var worker = cluster.fork();\\n  worker.send(&#39;hi there&#39;);\\n\\n} else if (cluster.isWorker) {\\n  process.on(&#39;message&#39;, function(msg) {\\n    process.send(msg);\\n  });\\n}</code></pre>\\n\"\n            },\n            {\n              \"textRaw\": \"worker.kill([signal='SIGTERM'])\",\n              \"type\": \"method\",\n              \"name\": \"kill\",\n              \"signatures\": [\n                {\n                  \"params\": [\n                    {\n                      \"textRaw\": \"`signal` {String} Name of the kill signal to send to the worker process. \",\n                      \"name\": \"signal\",\n                      \"type\": \"String\",\n                      \"desc\": \"Name of the kill signal to send to the worker process.\",\n                      \"optional\": true,\n                      \"default\": \"'SIGTERM'\"\n                    }\n                  ]\n                },\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"signal\",\n                      \"optional\": true,\n                      \"default\": \"'SIGTERM'\"\n                    }\n                  ]\n                }\n              ],\n              \"desc\": \"<p>This function will kill the worker. In the master, it does this by disconnecting\\nthe <code>worker.process</code>, and once disconnected, killing with <code>signal</code>. In the\\nworker, it does it by disconnecting the channel, and then exiting with code <code>0</code>.\\n\\n</p>\\n<p>Causes <code>.suicide</code> to be set.\\n\\n</p>\\n<p>This method is aliased as <code>worker.destroy()</code> for backwards compatibility.\\n\\n</p>\\n<p>Note that in a worker, <code>process.kill()</code> exists, but it is not this function,\\nit is <a href=\\\"process.html#process_process_kill_pid_signal\\\">kill</a>.\\n\\n</p>\\n\"\n            },\n            {\n              \"textRaw\": \"worker.disconnect()\",\n              \"type\": \"method\",\n              \"name\": \"disconnect\",\n              \"desc\": \"<p>In a worker, this function will close all servers, wait for the &#39;close&#39; event on\\nthose servers, and then disconnect the IPC channel.\\n\\n</p>\\n<p>In the master, an internal message is sent to the worker causing it to call\\n<code>.disconnect()</code> on itself.\\n\\n</p>\\n<p>Causes <code>.suicide</code> to be set.\\n\\n</p>\\n<p>Note that after a server is closed, it will no longer accept new connections,\\nbut connections may be accepted by any other listening worker. Existing\\nconnections will be allowed to close as usual. When no more connections exist,\\nsee <a href=\\\"net.html#net_event_close\\\">server.close()</a>, the IPC channel to the worker\\nwill close allowing it to die gracefully.\\n\\n</p>\\n<p>The above applies <em>only</em> to server connections, client connections are not\\nautomatically closed by workers, and disconnect does not wait for them to close\\nbefore exiting.\\n\\n</p>\\n<p>Note that in a worker, <code>process.disconnect</code> exists, but it is not this function,\\nit is <a href=\\\"child_process.html#child_process_child_disconnect\\\">disconnect</a>.\\n\\n</p>\\n<p>Because long living server connections may block workers from disconnecting, it\\nmay be useful to send a message, so application specific actions may be taken to\\nclose them. It also may be useful to implement a timeout, killing a worker if\\nthe <code>disconnect</code> event has not been emitted after some time.\\n\\n</p>\\n<pre><code>if (cluster.isMaster) {\\n  var worker = cluster.fork();\\n  var timeout;\\n\\n  worker.on(&#39;listening&#39;, function(address) {\\n    worker.send(&#39;shutdown&#39;);\\n    worker.disconnect();\\n    timeout = setTimeout(function() {\\n      worker.kill();\\n    }, 2000);\\n  });\\n\\n  worker.on(&#39;disconnect&#39;, function() {\\n    clearTimeout(timeout);\\n  });\\n\\n} else if (cluster.isWorker) {\\n  var net = require(&#39;net&#39;);\\n  var server = net.createServer(function(socket) {\\n    // connections never end\\n  });\\n\\n  server.listen(8000);\\n\\n  process.on(&#39;message&#39;, function(msg) {\\n    if(msg === &#39;shutdown&#39;) {\\n      // initiate graceful close of any connections to server\\n    }\\n  });\\n}</code></pre>\\n\",\n              \"signatures\": [\n                {\n                  \"params\": []\n                }\n              ]\n            }\n          ],\n          \"events\": [\n            {\n              \"textRaw\": \"Event: 'message'\",\n              \"type\": \"event\",\n              \"name\": \"message\",\n              \"params\": [],\n              \"desc\": \"<p>This event is the same as the one provided by <code>child_process.fork()</code>.\\n\\n</p>\\n<p>In a worker you can also use <code>process.on(&#39;message&#39;)</code>.\\n\\n</p>\\n<p>As an example, here is a cluster that keeps count of the number of requests\\nin the master process using the message system:\\n\\n</p>\\n<pre><code>var cluster = require(&#39;cluster&#39;);\\nvar http = require(&#39;http&#39;);\\n\\nif (cluster.isMaster) {\\n\\n  // Keep track of http requests\\n  var numReqs = 0;\\n  setInterval(function() {\\n    console.log(&quot;numReqs =&quot;, numReqs);\\n  }, 1000);\\n\\n  // Count requestes\\n  function messageHandler(msg) {\\n    if (msg.cmd &amp;&amp; msg.cmd == &#39;notifyRequest&#39;) {\\n      numReqs += 1;\\n    }\\n  }\\n\\n  // Start workers and listen for messages containing notifyRequest\\n  var numCPUs = require(&#39;os&#39;).cpus().length;\\n  for (var i = 0; i &lt; numCPUs; i++) {\\n    cluster.fork();\\n  }\\n\\n  Object.keys(cluster.workers).forEach(function(id) {\\n    cluster.workers[id].on(&#39;message&#39;, messageHandler);\\n  });\\n\\n} else {\\n\\n  // Worker processes have a http server.\\n  http.Server(function(req, res) {\\n    res.writeHead(200);\\n    res.end(&quot;hello world\\\\n&quot;);\\n\\n    // notify master about the request\\n    process.send({ cmd: &#39;notifyRequest&#39; });\\n  }).listen(8000);\\n}</code></pre>\\n\"\n            },\n            {\n              \"textRaw\": \"Event: 'online'\",\n              \"type\": \"event\",\n              \"name\": \"online\",\n              \"desc\": \"<p>Similar to the <code>cluster.on(&#39;online&#39;)</code> event, but specific to this worker.\\n\\n</p>\\n<pre><code>cluster.fork().on(&#39;online&#39;, function() {\\n  // Worker is online\\n});</code></pre>\\n<p>It is not emitted in the worker.\\n\\n</p>\\n\",\n              \"params\": []\n            },\n            {\n              \"textRaw\": \"Event: 'listening'\",\n              \"type\": \"event\",\n              \"name\": \"listening\",\n              \"params\": [],\n              \"desc\": \"<p>Similar to the <code>cluster.on(&#39;listening&#39;)</code> event, but specific to this worker.\\n\\n</p>\\n<pre><code>cluster.fork().on(&#39;listening&#39;, function(address) {\\n  // Worker is listening\\n});</code></pre>\\n<p>It is not emitted in the worker.\\n\\n</p>\\n\"\n            },\n            {\n              \"textRaw\": \"Event: 'disconnect'\",\n              \"type\": \"event\",\n              \"name\": \"disconnect\",\n              \"desc\": \"<p>Similar to the <code>cluster.on(&#39;disconnect&#39;)</code> event, but specfic to this worker.\\n\\n</p>\\n<pre><code>cluster.fork().on(&#39;disconnect&#39;, function() {\\n  // Worker has disconnected\\n});</code></pre>\\n\",\n              \"params\": []\n            },\n            {\n              \"textRaw\": \"Event: 'exit'\",\n              \"type\": \"event\",\n              \"name\": \"exit\",\n              \"params\": [],\n              \"desc\": \"<p>Similar to the <code>cluster.on(&#39;exit&#39;)</code> event, but specific to this worker.\\n\\n</p>\\n<pre><code>var worker = cluster.fork();\\nworker.on(&#39;exit&#39;, function(code, signal) {\\n  if( signal ) {\\n    console.log(&quot;worker was killed by signal: &quot;+signal);\\n  } else if( code !== 0 ) {\\n    console.log(&quot;worker exited with error code: &quot;+code);\\n  } else {\\n    console.log(&quot;worker success!&quot;);\\n  }\\n});</code></pre>\\n\"\n            },\n            {\n              \"textRaw\": \"Event: 'error'\",\n              \"type\": \"event\",\n              \"name\": \"error\",\n              \"desc\": \"<p>This event is the same as the one provided by <code>child_process.fork()</code>.\\n\\n</p>\\n<p>In a worker you can also use <code>process.on(&#39;error&#39;)</code>.\\n</p>\\n\",\n              \"params\": []\n            }\n          ]\n        }\n      ],\n      \"type\": \"module\",\n      \"displayName\": \"Cluster\"\n    }\n  ]\n}\n"}{"source":"http://nodejs.org/api/child_process.json","title":"Child Processes","content":"{\n  \"source\": \"doc/api/child_process.markdown\",\n  \"modules\": [\n    {\n      \"textRaw\": \"Child Process\",\n      \"name\": \"child_process\",\n      \"stability\": 3,\n      \"stabilityText\": \"Stable\",\n      \"desc\": \"<p>Node provides a tri-directional <code>popen(3)</code> facility through the\\n<code>child_process</code> module.\\n\\n</p>\\n<p>It is possible to stream data through a child&#39;s <code>stdin</code>, <code>stdout</code>, and\\n<code>stderr</code> in a fully non-blocking way.  (Note that some programs use\\nline-buffered I/O internally.  That doesn&#39;t affect node.js but it means\\ndata you send to the child process is not immediately consumed.)\\n\\n</p>\\n<p>To create a child process use <code>require(&#39;child_process&#39;).spawn()</code> or\\n<code>require(&#39;child_process&#39;).fork()</code>.  The semantics of each are slightly\\ndifferent, and explained below.\\n\\n</p>\\n\",\n      \"classes\": [\n        {\n          \"textRaw\": \"Class: ChildProcess\",\n          \"type\": \"class\",\n          \"name\": \"ChildProcess\",\n          \"desc\": \"<p><code>ChildProcess</code> is an [EventEmitter][].\\n\\n</p>\\n<p>Child processes always have three streams associated with them. <code>child.stdin</code>,\\n<code>child.stdout</code>, and <code>child.stderr</code>.  These may be shared with the stdio\\nstreams of the parent process, or they may be separate stream objects\\nwhich can be piped to and from.\\n\\n</p>\\n<p>The ChildProcess class is not intended to be used directly.  Use the\\n<code>spawn()</code> or <code>fork()</code> methods to create a Child Process instance.\\n\\n</p>\\n\",\n          \"events\": [\n            {\n              \"textRaw\": \"Event:  'error'\",\n              \"type\": \"event\",\n              \"name\": \"error\",\n              \"params\": [],\n              \"desc\": \"<p>Emitted when:\\n\\n</p>\\n<ol>\\n<li>The process could not be spawned, or</li>\\n<li>The process could not be killed, or</li>\\n<li>Sending a message to the child process failed for whatever reason.</li>\\n</ol>\\n<p>Note that the <code>exit</code>-event may or may not fire after an error has occured. If\\nyou are listening on both events to fire a function, remember to guard against\\ncalling your function twice.\\n\\n</p>\\n<p>See also <a href=\\\"#child_process_child_kill_signal\\\"><code>ChildProcess#kill()</code></a> and\\n<a href=\\\"#child_process_child_send_message_sendhandle\\\"><code>ChildProcess#send()</code></a>.\\n\\n</p>\\n\"\n            },\n            {\n              \"textRaw\": \"Event:  'exit'\",\n              \"type\": \"event\",\n              \"name\": \"exit\",\n              \"params\": [],\n              \"desc\": \"<p>This event is emitted after the child process ends. If the process terminated\\nnormally, <code>code</code> is the final exit code of the process, otherwise <code>null</code>. If\\nthe process terminated due to receipt of a signal, <code>signal</code> is the string name\\nof the signal, otherwise <code>null</code>.\\n\\n</p>\\n<p>Note that the child process stdio streams might still be open.\\n\\n</p>\\n<p>Also, note that node establishes signal handlers for <code>&#39;SIGINT&#39;</code> and <code>&#39;SIGTERM</code>&#39;,\\nso it will not terminate due to receipt of those signals, it will exit.\\n\\n</p>\\n<p>See <code>waitpid(2)</code>.\\n\\n</p>\\n\"\n            },\n            {\n              \"textRaw\": \"Event: 'close'\",\n              \"type\": \"event\",\n              \"name\": \"close\",\n              \"params\": [],\n              \"desc\": \"<p>This event is emitted when the stdio streams of a child process have all\\nterminated.  This is distinct from &#39;exit&#39;, since multiple processes\\nmight share the same stdio streams.\\n\\n</p>\\n\"\n            },\n            {\n              \"textRaw\": \"Event: 'disconnect'\",\n              \"type\": \"event\",\n              \"name\": \"disconnect\",\n              \"desc\": \"<p>This event is emitted after calling the <code>.disconnect()</code> method in the parent\\nor in the child. After disconnecting it is no longer possible to send messages,\\nand the <code>.connected</code> property is false.\\n\\n</p>\\n\",\n              \"params\": []\n            },\n            {\n              \"textRaw\": \"Event: 'message'\",\n              \"type\": \"event\",\n              \"name\": \"message\",\n              \"params\": [],\n              \"desc\": \"<p>Messages send by <code>.send(message, [sendHandle])</code> are obtained using the\\n<code>message</code> event.\\n\\n</p>\\n\"\n            }\n          ],\n          \"properties\": [\n            {\n              \"textRaw\": \"`stdin` {Stream object} \",\n              \"name\": \"stdin\",\n              \"desc\": \"<p>A <code>Writable Stream</code> that represents the child process&#39;s <code>stdin</code>.\\nClosing this stream via <code>end()</code> often causes the child process to terminate.\\n\\n</p>\\n<p>If the child stdio streams are shared with the parent, then this will\\nnot be set.\\n\\n</p>\\n\"\n            },\n            {\n              \"textRaw\": \"`stdout` {Stream object} \",\n              \"name\": \"stdout\",\n              \"desc\": \"<p>A <code>Readable Stream</code> that represents the child process&#39;s <code>stdout</code>.\\n\\n</p>\\n<p>If the child stdio streams are shared with the parent, then this will\\nnot be set.\\n\\n</p>\\n\"\n            },\n            {\n              \"textRaw\": \"`stderr` {Stream object} \",\n              \"name\": \"stderr\",\n              \"desc\": \"<p>A <code>Readable Stream</code> that represents the child process&#39;s <code>stderr</code>.\\n\\n</p>\\n<p>If the child stdio streams are shared with the parent, then this will\\nnot be set.\\n\\n</p>\\n\"\n            },\n            {\n              \"textRaw\": \"`pid` {Integer} \",\n              \"name\": \"pid\",\n              \"desc\": \"<p>The PID of the child process.\\n\\n</p>\\n<p>Example:\\n\\n</p>\\n<pre><code>var spawn = require(&#39;child_process&#39;).spawn,\\n    grep  = spawn(&#39;grep&#39;, [&#39;ssh&#39;]);\\n\\nconsole.log(&#39;Spawned child pid: &#39; + grep.pid);\\ngrep.stdin.end();</code></pre>\\n\"\n            },\n            {\n              \"textRaw\": \"`connected` {Boolean} Set to false after `.disconnect' is called \",\n              \"name\": \"connected\",\n              \"desc\": \"<p>If <code>.connected</code> is false, it is no longer possible to send messages.\\n\\n</p>\\n\",\n              \"shortDesc\": \"Set to false after `.disconnect' is called\"\n            }\n          ],\n          \"methods\": [\n            {\n              \"textRaw\": \"child.kill([signal])\",\n              \"type\": \"method\",\n              \"name\": \"kill\",\n              \"signatures\": [\n                {\n                  \"params\": [\n                    {\n                      \"textRaw\": \"`signal` {String} \",\n                      \"name\": \"signal\",\n                      \"type\": \"String\",\n                      \"optional\": true\n                    }\n                  ]\n                },\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"signal\",\n                      \"optional\": true\n                    }\n                  ]\n                }\n              ],\n              \"desc\": \"<p>Send a signal to the child process. If no argument is given, the process will\\nbe sent <code>&#39;SIGTERM&#39;</code>. See <code>signal(7)</code> for a list of available signals.\\n\\n</p>\\n<pre><code>var spawn = require(&#39;child_process&#39;).spawn,\\n    grep  = spawn(&#39;grep&#39;, [&#39;ssh&#39;]);\\n\\ngrep.on(&#39;close&#39;, function (code, signal) {\\n  console.log(&#39;child process terminated due to receipt of signal &#39;+signal);\\n});\\n\\n// send SIGHUP to process\\ngrep.kill(&#39;SIGHUP&#39;);</code></pre>\\n<p>May emit an <code>&#39;error&#39;</code> event when the signal cannot be delivered. Sending a\\nsignal to a child process that has already exited is not an error but may\\nhave unforeseen consequences: if the PID (the process ID) has been reassigned\\nto another process, the signal will be delivered to that process instead.\\nWhat happens next is anyone&#39;s guess.\\n\\n</p>\\n<p>Note that while the function is called <code>kill</code>, the signal delivered to the\\nchild process may not actually kill it.  <code>kill</code> really just sends a signal\\nto a process.\\n\\n</p>\\n<p>See <code>kill(2)</code>\\n\\n</p>\\n\"\n            },\n            {\n              \"textRaw\": \"child.send(message, [sendHandle])\",\n              \"type\": \"method\",\n              \"name\": \"send\",\n              \"signatures\": [\n                {\n                  \"params\": [\n                    {\n                      \"textRaw\": \"`message` {Object} \",\n                      \"name\": \"message\",\n                      \"type\": \"Object\"\n                    },\n                    {\n                      \"textRaw\": \"`sendHandle` {Handle object} \",\n                      \"name\": \"sendHandle\",\n                      \"type\": \"Handle object\",\n                      \"optional\": true\n                    }\n                  ]\n                },\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"message\"\n                    },\n                    {\n                      \"name\": \"sendHandle\",\n                      \"optional\": true\n                    }\n                  ]\n                }\n              ],\n              \"desc\": \"<p>When using <code>child_process.fork()</code> you can write to the child using\\n<code>child.send(message, [sendHandle])</code> and messages are received by\\na <code>&#39;message&#39;</code> event on the child.\\n\\n</p>\\n<p>For example:\\n\\n</p>\\n<pre><code>var cp = require(&#39;child_process&#39;);\\n\\nvar n = cp.fork(__dirname + &#39;/sub.js&#39;);\\n\\nn.on(&#39;message&#39;, function(m) {\\n  console.log(&#39;PARENT got message:&#39;, m);\\n});\\n\\nn.send({ hello: &#39;world&#39; });</code></pre>\\n<p>And then the child script, <code>&#39;sub.js&#39;</code> might look like this:\\n\\n</p>\\n<pre><code>process.on(&#39;message&#39;, function(m) {\\n  console.log(&#39;CHILD got message:&#39;, m);\\n});\\n\\nprocess.send({ foo: &#39;bar&#39; });</code></pre>\\n<p>In the child the <code>process</code> object will have a <code>send()</code> method, and <code>process</code>\\nwill emit objects each time it receives a message on its channel.\\n\\n</p>\\n<p>Please note that the <code>send()</code> method on both the parent and child are\\nsynchronous - sending large chunks of data is not advised (pipes can be used\\ninstead, see\\n<a href=\\\"#child_process_child_process_spawn_command_args_options\\\"><code>child_process.spawn</code></a>).\\n\\n</p>\\n<p>There is a special case when sending a <code>{cmd: &#39;NODE_foo&#39;}</code> message. All messages\\ncontaining a <code>NODE_</code> prefix in its <code>cmd</code> property will not be emitted in\\nthe <code>message</code> event, since they are internal messages used by node core.\\nMessages containing the prefix are emitted in the <code>internalMessage</code> event, you\\nshould by all means avoid using this feature, it is subject to change without notice.\\n\\n</p>\\n<p>The <code>sendHandle</code> option to <code>child.send()</code> is for sending a TCP server or\\nsocket object to another process. The child will receive the object as its\\nsecond argument to the <code>message</code> event.\\n\\n</p>\\n<p>Emits an <code>&#39;error&#39;</code> event if the message cannot be sent, for example because\\nthe child process has already exited.\\n\\n</p>\\n<h4>Example: sending server object</h4>\\n<p>Here is an example of sending a server:\\n\\n</p>\\n<pre><code>var child = require(&#39;child_process&#39;).fork(&#39;child.js&#39;);\\n\\n// Open up the server object and send the handle.\\nvar server = require(&#39;net&#39;).createServer();\\nserver.on(&#39;connection&#39;, function (socket) {\\n  socket.end(&#39;handled by parent&#39;);\\n});\\nserver.listen(1337, function() {\\n  child.send(&#39;server&#39;, server);\\n});</code></pre>\\n<p>And the child would the receive the server object as:\\n\\n</p>\\n<pre><code>process.on(&#39;message&#39;, function(m, server) {\\n  if (m === &#39;server&#39;) {\\n    server.on(&#39;connection&#39;, function (socket) {\\n      socket.end(&#39;handled by child&#39;);\\n    });\\n  }\\n});</code></pre>\\n<p>Note that the server is now shared between the parent and child, this means\\nthat some connections will be handled by the parent and some by the child.\\n\\n</p>\\n<p>For <code>dgram</code> servers the workflow is exactly the same.  Here you listen on\\na <code>message</code> event instead of <code>connection</code> and use <code>server.bind</code> instead of\\n<code>server.listen</code>.  (Currently only supported on UNIX platforms.)\\n\\n</p>\\n<h4>Example: sending socket object</h4>\\n<p>Here is an example of sending a socket. It will spawn two children and handle\\nconnections with the remote address <code>74.125.127.100</code> as VIP by sending the\\nsocket to a &quot;special&quot; child process. Other sockets will go to a &quot;normal&quot; process.\\n\\n</p>\\n<pre><code>var normal = require(&#39;child_process&#39;).fork(&#39;child.js&#39;, [&#39;normal&#39;]);\\nvar special = require(&#39;child_process&#39;).fork(&#39;child.js&#39;, [&#39;special&#39;]);\\n\\n// Open up the server and send sockets to child\\nvar server = require(&#39;net&#39;).createServer();\\nserver.on(&#39;connection&#39;, function (socket) {\\n\\n  // if this is a VIP\\n  if (socket.remoteAddress === &#39;74.125.127.100&#39;) {\\n    special.send(&#39;socket&#39;, socket);\\n    return;\\n  }\\n  // just the usual dudes\\n  normal.send(&#39;socket&#39;, socket);\\n});\\nserver.listen(1337);</code></pre>\\n<p>The <code>child.js</code> could look like this:\\n\\n</p>\\n<pre><code>process.on(&#39;message&#39;, function(m, socket) {\\n  if (m === &#39;socket&#39;) {\\n    socket.end(&#39;You were handled as a &#39; + process.argv[2] + &#39; person&#39;);\\n  }\\n});</code></pre>\\n<p>Note that once a single socket has been sent to a child the parent can no\\nlonger keep track of when the socket is destroyed. To indicate this condition\\nthe <code>.connections</code> property becomes <code>null</code>.\\nIt is also recommended not to use <code>.maxConnections</code> in this condition.\\n\\n</p>\\n\"\n            },\n            {\n              \"textRaw\": \"child.disconnect()\",\n              \"type\": \"method\",\n              \"name\": \"disconnect\",\n              \"desc\": \"<p>Close the IPC channel between parent and child, allowing the child to exit\\ngracefully once there are no other connections keeping it alive. After calling\\nthis method the <code>.connected</code> flag will be set to <code>false</code> in both the parent and\\nchild, and it is no longer possible to send messages.\\n\\n</p>\\n<p>The &#39;disconnect&#39; event will be emitted when there are no messages in the process\\nof being received, most likely immediately.\\n\\n</p>\\n<p>Note that you can also call <code>process.disconnect()</code> in the child process.\\n\\n</p>\\n\",\n              \"signatures\": [\n                {\n                  \"params\": []\n                }\n              ]\n            }\n          ]\n        }\n      ],\n      \"methods\": [\n        {\n          \"textRaw\": \"child_process.spawn(command, [args], [options])\",\n          \"type\": \"method\",\n          \"name\": \"spawn\",\n          \"signatures\": [\n            {\n              \"return\": {\n                \"textRaw\": \"return: {ChildProcess object} \",\n                \"name\": \"return\",\n                \"type\": \"ChildProcess object\"\n              },\n              \"params\": [\n                {\n                  \"textRaw\": \"`command` {String} The command to run \",\n                  \"name\": \"command\",\n                  \"type\": \"String\",\n                  \"desc\": \"The command to run\"\n                },\n                {\n                  \"textRaw\": \"`args` {Array} List of string arguments \",\n                  \"name\": \"args\",\n                  \"type\": \"Array\",\n                  \"desc\": \"List of string arguments\",\n                  \"optional\": true\n                },\n                {\n                  \"textRaw\": \"`options` {Object} \",\n                  \"options\": [\n                    {\n                      \"textRaw\": \"`cwd` {String} Current working directory of the child process \",\n                      \"name\": \"cwd\",\n                      \"type\": \"String\",\n                      \"desc\": \"Current working directory of the child process\"\n                    },\n                    {\n                      \"textRaw\": \"`stdio` {Array|String} Child's stdio configuration. (See below) \",\n                      \"name\": \"stdio\",\n                      \"type\": \"Array|String\",\n                      \"desc\": \"Child's stdio configuration. (See below)\"\n                    },\n                    {\n                      \"textRaw\": \"`customFds` {Array} **Deprecated** File descriptors for the child to use for stdio.  (See below) \",\n                      \"name\": \"customFds\",\n                      \"type\": \"Array\",\n                      \"desc\": \"**Deprecated** File descriptors for the child to use for stdio.  (See below)\"\n                    },\n                    {\n                      \"textRaw\": \"`env` {Object} Environment key-value pairs \",\n                      \"name\": \"env\",\n                      \"type\": \"Object\",\n                      \"desc\": \"Environment key-value pairs\"\n                    },\n                    {\n                      \"textRaw\": \"`detached` {Boolean} The child will be a process group leader.  (See below) \",\n                      \"name\": \"detached\",\n                      \"type\": \"Boolean\",\n                      \"desc\": \"The child will be a process group leader.  (See below)\"\n                    },\n                    {\n                      \"textRaw\": \"`uid` {Number} Sets the user identity of the process. (See setuid(2).) \",\n                      \"name\": \"uid\",\n                      \"type\": \"Number\",\n                      \"desc\": \"Sets the user identity of the process. (See setuid(2).)\"\n                    },\n                    {\n                      \"textRaw\": \"`gid` {Number} Sets the group identity of the process. (See setgid(2).) \",\n                      \"name\": \"gid\",\n                      \"type\": \"Number\",\n                      \"desc\": \"Sets the group identity of the process. (See setgid(2).)\"\n                    }\n                  ],\n                  \"name\": \"options\",\n                  \"type\": \"Object\",\n                  \"optional\": true\n                }\n              ]\n            },\n            {\n              \"params\": [\n                {\n                  \"name\": \"command\"\n                },\n                {\n                  \"name\": \"args\",\n                  \"optional\": true\n                },\n                {\n                  \"name\": \"options\",\n                  \"optional\": true\n                }\n              ]\n            }\n          ],\n          \"desc\": \"<p>Launches a new process with the given <code>command</code>, with  command line arguments in <code>args</code>.\\nIf omitted, <code>args</code> defaults to an empty Array.\\n\\n</p>\\n<p>The third argument is used to specify additional options, which defaults to:\\n\\n</p>\\n<pre><code>{ cwd: undefined,\\n  env: process.env\\n}</code></pre>\\n<p><code>cwd</code> allows you to specify the working directory from which the process is spawned.\\nUse <code>env</code> to specify environment variables that will be visible to the new process.\\n\\n</p>\\n<p>Example of running <code>ls -lh /usr</code>, capturing <code>stdout</code>, <code>stderr</code>, and the exit code:\\n\\n</p>\\n<pre><code>var spawn = require(&#39;child_process&#39;).spawn,\\n    ls    = spawn(&#39;ls&#39;, [&#39;-lh&#39;, &#39;/usr&#39;]);\\n\\nls.stdout.on(&#39;data&#39;, function (data) {\\n  console.log(&#39;stdout: &#39; + data);\\n});\\n\\nls.stderr.on(&#39;data&#39;, function (data) {\\n  console.log(&#39;stderr: &#39; + data);\\n});\\n\\nls.on(&#39;close&#39;, function (code) {\\n  console.log(&#39;child process exited with code &#39; + code);\\n});</code></pre>\\n<p>Example: A very elaborate way to run &#39;ps ax | grep ssh&#39;\\n\\n</p>\\n<pre><code>var spawn = require(&#39;child_process&#39;).spawn,\\n    ps    = spawn(&#39;ps&#39;, [&#39;ax&#39;]),\\n    grep  = spawn(&#39;grep&#39;, [&#39;ssh&#39;]);\\n\\nps.stdout.on(&#39;data&#39;, function (data) {\\n  grep.stdin.write(data);\\n});\\n\\nps.stderr.on(&#39;data&#39;, function (data) {\\n  console.log(&#39;ps stderr: &#39; + data);\\n});\\n\\nps.on(&#39;close&#39;, function (code) {\\n  if (code !== 0) {\\n    console.log(&#39;ps process exited with code &#39; + code);\\n  }\\n  grep.stdin.end();\\n});\\n\\ngrep.stdout.on(&#39;data&#39;, function (data) {\\n  console.log(&#39;&#39; + data);\\n});\\n\\ngrep.stderr.on(&#39;data&#39;, function (data) {\\n  console.log(&#39;grep stderr: &#39; + data);\\n});\\n\\ngrep.on(&#39;close&#39;, function (code) {\\n  if (code !== 0) {\\n    console.log(&#39;grep process exited with code &#39; + code);\\n  }\\n});</code></pre>\\n<p>Example of checking for failed exec:\\n\\n</p>\\n<pre><code>var spawn = require(&#39;child_process&#39;).spawn,\\n    child = spawn(&#39;bad_command&#39;);\\n\\nchild.stderr.setEncoding(&#39;utf8&#39;);\\nchild.stderr.on(&#39;data&#39;, function (data) {\\n  if (/^execvp\\\\(\\\\)/.test(data)) {\\n    console.log(&#39;Failed to start child process.&#39;);\\n  }\\n});</code></pre>\\n<p>Note that if spawn receives an empty options object, it will result in\\nspawning the process with an empty environment rather than using\\n<code>process.env</code>. This due to backwards compatibility issues with a deprecated\\nAPI.\\n\\n</p>\\n<p>The &#39;stdio&#39; option to <code>child_process.spawn()</code> is an array where each\\nindex corresponds to a fd in the child.  The value is one of the following:\\n\\n</p>\\n<ol>\\n<li><code>&#39;pipe&#39;</code> - Create a pipe between the child process and the parent process.\\nThe parent end of the pipe is exposed to the parent as a property on the\\n<code>child_process</code> object as <code>ChildProcess.stdio[fd]</code>. Pipes created for\\nfds 0 - 2 are also available as ChildProcess.stdin, ChildProcess.stdout\\nand ChildProcess.stderr, respectively.</li>\\n<li><code>&#39;ipc&#39;</code> - Create an IPC channel for passing messages/file descriptors\\nbetween parent and child. A ChildProcess may have at most <em>one</em> IPC stdio\\nfile descriptor. Setting this option enables the ChildProcess.send() method.\\nIf the child writes JSON messages to this file descriptor, then this will\\ntrigger ChildProcess.on(&#39;message&#39;).  If the child is a Node.js program, then\\nthe presence of an IPC channel will enable process.send() and\\nprocess.on(&#39;message&#39;).</li>\\n<li><code>&#39;ignore&#39;</code> - Do not set this file descriptor in the child. Note that Node\\nwill always open fd 0 - 2 for the processes it spawns. When any of these is\\nignored node will open <code>/dev/null</code> and attach it to the child&#39;s fd.</li>\\n<li><code>Stream</code> object - Share a readable or writable stream that refers to a tty,\\nfile, socket, or a pipe with the child process. The stream&#39;s underlying\\nfile descriptor is duplicated in the child process to the fd that \\ncorresponds to the index in the <code>stdio</code> array. Note that the stream must\\nhave an underlying descriptor (file streams do not until the <code>&#39;open&#39;</code>\\nevent has occurred).</li>\\n<li>Positive integer - The integer value is interpreted as a file descriptor \\nthat is is currently open in the parent process. It is shared with the child\\nprocess, similar to how <code>Stream</code> objects can be shared.</li>\\n<li><code>null</code>, <code>undefined</code> - Use default value. For stdio fds 0, 1 and 2 (in other\\nwords, stdin, stdout, and stderr) a pipe is created. For fd 3 and up, the\\ndefault is <code>&#39;ignore&#39;</code>.</li>\\n</ol>\\n<p>As a shorthand, the <code>stdio</code> argument may also be one of the following\\nstrings, rather than an array:\\n\\n</p>\\n<ul>\\n<li><code>ignore</code> - <code>[&#39;ignore&#39;, &#39;ignore&#39;, &#39;ignore&#39;]</code></li>\\n<li><code>pipe</code> - <code>[&#39;pipe&#39;, &#39;pipe&#39;, &#39;pipe&#39;]</code></li>\\n<li><code>inherit</code> - <code>[process.stdin, process.stdout, process.stderr]</code> or <code>[0,1,2]</code></li>\\n</ul>\\n<p>Example:\\n\\n</p>\\n<pre><code>var spawn = require(&#39;child_process&#39;).spawn;\\n\\n// Child will use parent&#39;s stdios\\nspawn(&#39;prg&#39;, [], { stdio: &#39;inherit&#39; });\\n\\n// Spawn child sharing only stderr\\nspawn(&#39;prg&#39;, [], { stdio: [&#39;pipe&#39;, &#39;pipe&#39;, process.stderr] });\\n\\n// Open an extra fd=4, to interact with programs present a\\n// startd-style interface.\\nspawn(&#39;prg&#39;, [], { stdio: [&#39;pipe&#39;, null, null, null, &#39;pipe&#39;] });</code></pre>\\n<p>If the <code>detached</code> option is set, the child process will be made the leader of a\\nnew process group.  This makes it possible for the child to continue running \\nafter the parent exits.\\n\\n</p>\\n<p>By default, the parent will wait for the detached child to exit.  To prevent\\nthe parent from waiting for a given <code>child</code>, use the <code>child.unref()</code> method,\\nand the parent&#39;s event loop will not include the child in its reference count.\\n\\n</p>\\n<p>Example of detaching a long-running process and redirecting its output to a\\nfile:\\n\\n</p>\\n<pre><code> var fs = require(&#39;fs&#39;),\\n     spawn = require(&#39;child_process&#39;).spawn,\\n     out = fs.openSync(&#39;./out.log&#39;, &#39;a&#39;),\\n     err = fs.openSync(&#39;./out.log&#39;, &#39;a&#39;);\\n\\n var child = spawn(&#39;prg&#39;, [], {\\n   detached: true,\\n   stdio: [ &#39;ignore&#39;, out, err ]\\n });\\n\\n child.unref();</code></pre>\\n<p>When using the <code>detached</code> option to start a long-running process, the process\\nwill not stay running in the background unless it is provided with a <code>stdio</code>\\nconfiguration that is not connected to the parent.  If the parent&#39;s <code>stdio</code> is\\ninherited, the child will remain attached to the controlling terminal.\\n\\n</p>\\n<p>There is a deprecated option called <code>customFds</code> which allows one to specify\\nspecific file descriptors for the stdio of the child process. This API was\\nnot portable to all platforms and therefore removed.\\nWith <code>customFds</code> it was possible to hook up the new process&#39; <code>[stdin, stdout,\\nstderr]</code> to existing streams; <code>-1</code> meant that a new stream should be created.\\nUse at your own risk.\\n\\n</p>\\n<p>See also: <code>child_process.exec()</code> and <code>child_process.fork()</code>\\n\\n</p>\\n\"\n        },\n        {\n          \"textRaw\": \"child_process.exec(command, [options], callback)\",\n          \"type\": \"method\",\n          \"name\": \"exec\",\n          \"signatures\": [\n            {\n              \"return\": {\n                \"textRaw\": \"Return: ChildProcess object \",\n                \"name\": \"return\",\n                \"desc\": \"ChildProcess object\"\n              },\n              \"params\": [\n                {\n                  \"textRaw\": \"`command` {String} The command to run, with space-separated arguments \",\n                  \"name\": \"command\",\n                  \"type\": \"String\",\n                  \"desc\": \"The command to run, with space-separated arguments\"\n                },\n                {\n                  \"textRaw\": \"`options` {Object} \",\n                  \"options\": [\n                    {\n                      \"textRaw\": \"`cwd` {String} Current working directory of the child process \",\n                      \"name\": \"cwd\",\n                      \"type\": \"String\",\n                      \"desc\": \"Current working directory of the child process\"\n                    },\n                    {\n                      \"textRaw\": \"`env` {Object} Environment key-value pairs \",\n                      \"name\": \"env\",\n                      \"type\": \"Object\",\n                      \"desc\": \"Environment key-value pairs\"\n                    },\n                    {\n                      \"textRaw\": \"`encoding` {String} (Default: 'utf8') \",\n                      \"name\": \"encoding\",\n                      \"default\": \"utf8\",\n                      \"type\": \"String\"\n                    },\n                    {\n                      \"textRaw\": \"`timeout` {Number} (Default: 0) \",\n                      \"name\": \"timeout\",\n                      \"default\": \"0\",\n                      \"type\": \"Number\"\n                    },\n                    {\n                      \"textRaw\": \"`maxBuffer` {Number} (Default: `200*1024`) \",\n                      \"name\": \"maxBuffer\",\n                      \"default\": \"200*1024\",\n                      \"type\": \"Number\"\n                    },\n                    {\n                      \"textRaw\": \"`killSignal` {String} (Default: 'SIGTERM') \",\n                      \"name\": \"killSignal\",\n                      \"default\": \"SIGTERM\",\n                      \"type\": \"String\"\n                    }\n                  ],\n                  \"name\": \"options\",\n                  \"type\": \"Object\",\n                  \"optional\": true\n                },\n                {\n                  \"textRaw\": \"`callback` {Function} called with the output when process terminates \",\n                  \"options\": [\n                    {\n                      \"textRaw\": \"`error` {Error} \",\n                      \"name\": \"error\",\n                      \"type\": \"Error\"\n                    },\n                    {\n                      \"textRaw\": \"`stdout` {Buffer} \",\n                      \"name\": \"stdout\",\n                      \"type\": \"Buffer\"\n                    },\n                    {\n                      \"textRaw\": \"`stderr` {Buffer} \",\n                      \"name\": \"stderr\",\n                      \"type\": \"Buffer\"\n                    }\n                  ],\n                  \"name\": \"callback\",\n                  \"type\": \"Function\",\n                  \"desc\": \"called with the output when process terminates\"\n                }\n              ]\n            },\n            {\n              \"params\": [\n                {\n                  \"name\": \"command\"\n                },\n                {\n                  \"name\": \"options\",\n                  \"optional\": true\n                },\n                {\n                  \"name\": \"callback\"\n                }\n              ]\n            }\n          ],\n          \"desc\": \"<p>Runs a command in a shell and buffers the output.\\n\\n</p>\\n<pre><code>var exec = require(&#39;child_process&#39;).exec,\\n    child;\\n\\nchild = exec(&#39;cat *.js bad_file | wc -l&#39;,\\n  function (error, stdout, stderr) {\\n    console.log(&#39;stdout: &#39; + stdout);\\n    console.log(&#39;stderr: &#39; + stderr);\\n    if (error !== null) {\\n      console.log(&#39;exec error: &#39; + error);\\n    }\\n});</code></pre>\\n<p>The callback gets the arguments <code>(error, stdout, stderr)</code>. On success, <code>error</code>\\nwill be <code>null</code>.  On error, <code>error</code> will be an instance of <code>Error</code> and <code>error.code</code>\\nwill be the exit code of the child process, and <code>error.signal</code> will be set to the\\nsignal that terminated the process.\\n\\n</p>\\n<p>There is a second optional argument to specify several options. The\\ndefault options are\\n\\n</p>\\n<pre><code>{ encoding: &#39;utf8&#39;,\\n  timeout: 0,\\n  maxBuffer: 200*1024,\\n  killSignal: &#39;SIGTERM&#39;,\\n  cwd: null,\\n  env: null }</code></pre>\\n<p>If <code>timeout</code> is greater than 0, then it will kill the child process\\nif it runs longer than <code>timeout</code> milliseconds. The child process is killed with\\n<code>killSignal</code> (default: <code>&#39;SIGTERM&#39;</code>). <code>maxBuffer</code> specifies the largest\\namount of data allowed on stdout or stderr - if this value is exceeded then\\nthe child process is killed.\\n\\n\\n</p>\\n\"\n        },\n        {\n          \"textRaw\": \"child_process.execFile(file, [args], [options], [callback])\",\n          \"type\": \"method\",\n          \"name\": \"execFile\",\n          \"signatures\": [\n            {\n              \"return\": {\n                \"textRaw\": \"Return: ChildProcess object \",\n                \"name\": \"return\",\n                \"desc\": \"ChildProcess object\"\n              },\n              \"params\": [\n                {\n                  \"textRaw\": \"`file` {String} The filename of the program to run \",\n                  \"name\": \"file\",\n                  \"type\": \"String\",\n                  \"desc\": \"The filename of the program to run\"\n                },\n                {\n                  \"textRaw\": \"`args` {Array} List of string arguments \",\n                  \"name\": \"args\",\n                  \"type\": \"Array\",\n                  \"desc\": \"List of string arguments\",\n                  \"optional\": true\n                },\n                {\n                  \"textRaw\": \"`options` {Object} \",\n                  \"options\": [\n                    {\n                      \"textRaw\": \"`cwd` {String} Current working directory of the child process \",\n                      \"name\": \"cwd\",\n                      \"type\": \"String\",\n                      \"desc\": \"Current working directory of the child process\"\n                    },\n                    {\n                      \"textRaw\": \"`env` {Object} Environment key-value pairs \",\n                      \"name\": \"env\",\n                      \"type\": \"Object\",\n                      \"desc\": \"Environment key-value pairs\"\n                    },\n                    {\n                      \"textRaw\": \"`encoding` {String} (Default: 'utf8') \",\n                      \"name\": \"encoding\",\n                      \"default\": \"utf8\",\n                      \"type\": \"String\"\n                    },\n                    {\n                      \"textRaw\": \"`timeout` {Number} (Default: 0) \",\n                      \"name\": \"timeout\",\n                      \"default\": \"0\",\n                      \"type\": \"Number\"\n                    },\n                    {\n                      \"textRaw\": \"`maxBuffer` {Number} (Default: 200\\\\*1024) \",\n                      \"name\": \"maxBuffer\",\n                      \"default\": \"200\\\\*1024\",\n                      \"type\": \"Number\"\n                    },\n                    {\n                      \"textRaw\": \"`killSignal` {String} (Default: 'SIGTERM') \",\n                      \"name\": \"killSignal\",\n                      \"default\": \"SIGTERM\",\n                      \"type\": \"String\"\n                    }\n                  ],\n                  \"name\": \"options\",\n                  \"type\": \"Object\",\n                  \"optional\": true\n                },\n                {\n                  \"textRaw\": \"`callback` {Function} called with the output when process terminates \",\n                  \"options\": [\n                    {\n                      \"textRaw\": \"`error` {Error} \",\n                      \"name\": \"error\",\n                      \"type\": \"Error\"\n                    },\n                    {\n                      \"textRaw\": \"`stdout` {Buffer} \",\n                      \"name\": \"stdout\",\n                      \"type\": \"Buffer\"\n                    },\n                    {\n                      \"textRaw\": \"`stderr` {Buffer} \",\n                      \"name\": \"stderr\",\n                      \"type\": \"Buffer\"\n                    }\n                  ],\n                  \"name\": \"callback\",\n                  \"type\": \"Function\",\n                  \"desc\": \"called with the output when process terminates\",\n                  \"optional\": true\n                }\n              ]\n            },\n            {\n              \"params\": [\n                {\n                  \"name\": \"file\"\n                },\n                {\n                  \"name\": \"args\",\n                  \"optional\": true\n                },\n                {\n                  \"name\": \"options\",\n                  \"optional\": true\n                },\n                {\n                  \"name\": \"callback\",\n                  \"optional\": true\n                }\n              ]\n            }\n          ],\n          \"desc\": \"<p>This is similar to <code>child_process.exec()</code> except it does not execute a\\nsubshell but rather the specified file directly. This makes it slightly\\nleaner than <code>child_process.exec</code>. It has the same options.\\n\\n\\n</p>\\n\"\n        },\n        {\n          \"textRaw\": \"child_process.fork(modulePath, [args], [options])\",\n          \"type\": \"method\",\n          \"name\": \"fork\",\n          \"signatures\": [\n            {\n              \"return\": {\n                \"textRaw\": \"Return: ChildProcess object \",\n                \"name\": \"return\",\n                \"desc\": \"ChildProcess object\"\n              },\n              \"params\": [\n                {\n                  \"textRaw\": \"`modulePath` {String} The module to run in the child \",\n                  \"name\": \"modulePath\",\n                  \"type\": \"String\",\n                  \"desc\": \"The module to run in the child\"\n                },\n                {\n                  \"textRaw\": \"`args` {Array} List of string arguments \",\n                  \"name\": \"args\",\n                  \"type\": \"Array\",\n                  \"desc\": \"List of string arguments\",\n                  \"optional\": true\n                },\n                {\n                  \"textRaw\": \"`options` {Object} \",\n                  \"options\": [\n                    {\n                      \"textRaw\": \"`cwd` {String} Current working directory of the child process \",\n                      \"name\": \"cwd\",\n                      \"type\": \"String\",\n                      \"desc\": \"Current working directory of the child process\"\n                    },\n                    {\n                      \"textRaw\": \"`env` {Object} Environment key-value pairs \",\n                      \"name\": \"env\",\n                      \"type\": \"Object\",\n                      \"desc\": \"Environment key-value pairs\"\n                    },\n                    {\n                      \"textRaw\": \"`encoding` {String} (Default: 'utf8') \",\n                      \"name\": \"encoding\",\n                      \"default\": \"utf8\",\n                      \"type\": \"String\"\n                    },\n                    {\n                      \"textRaw\": \"`execPath` {String} Executable used to create the child process \",\n                      \"name\": \"execPath\",\n                      \"type\": \"String\",\n                      \"desc\": \"Executable used to create the child process\"\n                    },\n                    {\n                      \"textRaw\": \"`execArgv` {Array} List of string arguments passed to the executable (Default: `process.execArgv`) \",\n                      \"name\": \"execArgv\",\n                      \"default\": \"process.execArgv\",\n                      \"type\": \"Array\",\n                      \"desc\": \"List of string arguments passed to the executable\"\n                    },\n                    {\n                      \"textRaw\": \"`silent` {Boolean} If true, stdin, stdout, and stderr of the child will be piped to the parent, otherwise they will be inherited from the parent, see the \\\"pipe\\\" and \\\"inherit\\\" options for `spawn()`'s `stdio` for more details (default is false) \",\n                      \"name\": \"silent\",\n                      \"type\": \"Boolean\",\n                      \"desc\": \"If true, stdin, stdout, and stderr of the child will be piped to the parent, otherwise they will be inherited from the parent, see the \\\"pipe\\\" and \\\"inherit\\\" options for `spawn()`'s `stdio` for more details (default is false)\"\n                    }\n                  ],\n                  \"name\": \"options\",\n                  \"type\": \"Object\",\n                  \"optional\": true\n                }\n              ]\n            },\n            {\n              \"params\": [\n                {\n                  \"name\": \"modulePath\"\n                },\n                {\n                  \"name\": \"args\",\n                  \"optional\": true\n                },\n                {\n                  \"name\": \"options\",\n                  \"optional\": true\n                }\n              ]\n            }\n          ],\n          \"desc\": \"<p>This is a special case of the <code>spawn()</code> functionality for spawning Node\\nprocesses. In addition to having all the methods in a normal ChildProcess\\ninstance, the returned object has a communication channel built-in. See\\n<code>child.send(message, [sendHandle])</code> for details.\\n\\n</p>\\n<p>These child Nodes are still whole new instances of V8. Assume at least 30ms\\nstartup and 10mb memory for each new Node. That is, you cannot create many\\nthousands of them.\\n\\n</p>\\n<p>The <code>execPath</code> property in the <code>options</code> object allows for a process to be\\ncreated for the child rather than the current <code>node</code> executable. This should be\\ndone with care and by default will talk over the fd represented an\\nenvironmental variable <code>NODE_CHANNEL_FD</code> on the child process. The input and\\noutput on this fd is expected to be line delimited JSON objects.\\n\\n</p>\\n\"\n        }\n      ],\n      \"type\": \"module\",\n      \"displayName\": \"Child Process\"\n    }\n  ]\n}\n"}{"source":"http://nodejs.org/api/crypto.json","title":"Crypto","content":"{\n  \"source\": \"doc/api/crypto.markdown\",\n  \"modules\": [\n    {\n      \"textRaw\": \"Crypto\",\n      \"name\": \"crypto\",\n      \"desc\": \"<pre><code>Stability: 2 - Unstable; API changes are being discussed for\\nfuture versions.  Breaking changes will be minimized.  See below.</code></pre>\\n<p>Use <code>require(&#39;crypto&#39;)</code> to access this module.\\n\\n</p>\\n<p>The crypto module offers a way of encapsulating secure credentials to be\\nused as part of a secure HTTPS net or http connection.\\n\\n</p>\\n<p>It also offers a set of wrappers for OpenSSL&#39;s hash, hmac, cipher,\\ndecipher, sign and verify methods.\\n\\n\\n</p>\\n\",\n      \"methods\": [\n        {\n          \"textRaw\": \"crypto.getCiphers()\",\n          \"type\": \"method\",\n          \"name\": \"getCiphers\",\n          \"desc\": \"<p>Returns an array with the names of the supported ciphers.\\n\\n</p>\\n<p>Example:\\n\\n</p>\\n<pre><code>var ciphers = crypto.getCiphers();\\nconsole.log(ciphers); // [&#39;AES-128-CBC&#39;, &#39;AES-128-CBC-HMAC-SHA1&#39;, ...]</code></pre>\\n\",\n          \"signatures\": [\n            {\n              \"params\": []\n            }\n          ]\n        },\n        {\n          \"textRaw\": \"crypto.getHashes()\",\n          \"type\": \"method\",\n          \"name\": \"getHashes\",\n          \"desc\": \"<p>Returns an array with the names of the supported hash algorithms.\\n\\n</p>\\n<p>Example:\\n\\n</p>\\n<pre><code>var hashes = crypto.getHashes();\\nconsole.log(hashes); // [&#39;sha&#39;, &#39;sha1&#39;, &#39;sha1WithRSAEncryption&#39;, ...]</code></pre>\\n\",\n          \"signatures\": [\n            {\n              \"params\": []\n            }\n          ]\n        },\n        {\n          \"textRaw\": \"crypto.createCredentials(details)\",\n          \"type\": \"method\",\n          \"name\": \"createCredentials\",\n          \"desc\": \"<p>Creates a credentials object, with the optional details being a\\ndictionary with keys:\\n\\n</p>\\n<ul>\\n<li><code>pfx</code> : A string or buffer holding the PFX or PKCS12 encoded private\\nkey, certificate and CA certificates</li>\\n<li><code>key</code> : A string holding the PEM encoded private key</li>\\n<li><code>passphrase</code> : A string of passphrase for the private key or pfx</li>\\n<li><code>cert</code> : A string holding the PEM encoded certificate</li>\\n<li><code>ca</code> : Either a string or list of strings of PEM encoded CA\\ncertificates to trust.</li>\\n<li><code>crl</code> : Either a string or list of strings of PEM encoded CRLs\\n(Certificate Revocation List)</li>\\n<li><code>ciphers</code>: A string describing the ciphers to use or exclude.\\nConsult\\n<a href=\\\"http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT\\\">http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT</a>\\nfor details on the format.</li>\\n</ul>\\n<p>If no &#39;ca&#39; details are given, then node.js will use the default\\npublicly trusted list of CAs as given in\\n</p>\\n<p><a href=\\\"http://mxr.mozilla.org/mozilla/source/security/nss/lib/ckfw/builtins/certdata.txt\\\">http://mxr.mozilla.org/mozilla/source/security/nss/lib/ckfw/builtins/certdata.txt</a>.\\n\\n\\n</p>\\n\",\n          \"signatures\": [\n            {\n              \"params\": [\n                {\n                  \"name\": \"details\"\n                }\n              ]\n            }\n          ]\n        },\n        {\n          \"textRaw\": \"crypto.createHash(algorithm)\",\n          \"type\": \"method\",\n          \"name\": \"createHash\",\n          \"desc\": \"<p>Creates and returns a hash object, a cryptographic hash with the given\\nalgorithm which can be used to generate hash digests.\\n\\n</p>\\n<p><code>algorithm</code> is dependent on the available algorithms supported by the\\nversion of OpenSSL on the platform. Examples are <code>&#39;sha1&#39;</code>, <code>&#39;md5&#39;</code>,\\n<code>&#39;sha256&#39;</code>, <code>&#39;sha512&#39;</code>, etc.  On recent releases, <code>openssl\\nlist-message-digest-algorithms</code> will display the available digest\\nalgorithms.\\n\\n</p>\\n<p>Example: this program that takes the sha1 sum of a file\\n\\n</p>\\n<pre><code>var filename = process.argv[2];\\nvar crypto = require(&#39;crypto&#39;);\\nvar fs = require(&#39;fs&#39;);\\n\\nvar shasum = crypto.createHash(&#39;sha1&#39;);\\n\\nvar s = fs.ReadStream(filename);\\ns.on(&#39;data&#39;, function(d) {\\n  shasum.update(d);\\n});\\n\\ns.on(&#39;end&#39;, function() {\\n  var d = shasum.digest(&#39;hex&#39;);\\n  console.log(d + &#39;  &#39; + filename);\\n});</code></pre>\\n\",\n          \"signatures\": [\n            {\n              \"params\": [\n                {\n                  \"name\": \"algorithm\"\n                }\n              ]\n            }\n          ]\n        },\n        {\n          \"textRaw\": \"crypto.createHmac(algorithm, key)\",\n          \"type\": \"method\",\n          \"name\": \"createHmac\",\n          \"desc\": \"<p>Creates and returns a hmac object, a cryptographic hmac with the given\\nalgorithm and key.\\n\\n</p>\\n<p>It is a <a href=\\\"stream.html\\\">stream</a> that is both readable and writable.  The\\nwritten data is used to compute the hmac.  Once the writable side of\\nthe stream is ended, use the <code>read()</code> method to get the computed\\ndigest.  The legacy <code>update</code> and <code>digest</code> methods are also supported.\\n\\n</p>\\n<p><code>algorithm</code> is dependent on the available algorithms supported by\\nOpenSSL - see createHash above.  <code>key</code> is the hmac key to be used.\\n\\n</p>\\n\",\n          \"signatures\": [\n            {\n              \"params\": [\n                {\n                  \"name\": \"algorithm\"\n                },\n                {\n                  \"name\": \"key\"\n                }\n              ]\n            }\n          ]\n        },\n        {\n          \"textRaw\": \"crypto.createCipher(algorithm, password)\",\n          \"type\": \"method\",\n          \"name\": \"createCipher\",\n          \"desc\": \"<p>Creates and returns a cipher object, with the given algorithm and\\npassword.\\n\\n</p>\\n<p><code>algorithm</code> is dependent on OpenSSL, examples are <code>&#39;aes192&#39;</code>, etc.  On\\nrecent releases, <code>openssl list-cipher-algorithms</code> will display the\\navailable cipher algorithms.  <code>password</code> is used to derive key and IV,\\nwhich must be a <code>&#39;binary&#39;</code> encoded string or a <a href=\\\"buffer.html\\\">buffer</a>.\\n\\n</p>\\n<p>It is a <a href=\\\"stream.html\\\">stream</a> that is both readable and writable.  The\\nwritten data is used to compute the hash.  Once the writable side of\\nthe stream is ended, use the <code>read()</code> method to get the computed hash\\ndigest.  The legacy <code>update</code> and <code>digest</code> methods are also supported.\\n\\n</p>\\n\",\n          \"signatures\": [\n            {\n              \"params\": [\n                {\n                  \"name\": \"algorithm\"\n                },\n                {\n                  \"name\": \"password\"\n                }\n              ]\n            }\n          ]\n        },\n        {\n          \"textRaw\": \"crypto.createCipheriv(algorithm, key, iv)\",\n          \"type\": \"method\",\n          \"name\": \"createCipheriv\",\n          \"desc\": \"<p>Creates and returns a cipher object, with the given algorithm, key and\\niv.\\n\\n</p>\\n<p><code>algorithm</code> is the same as the argument to <code>createCipher()</code>.  <code>key</code> is\\nthe raw key used by the algorithm.  <code>iv</code> is an <a href=\\\"http://en.wikipedia.org/wiki/Initialization_vector\\\">initialization\\nvector</a>.\\n\\n</p>\\n<p><code>key</code> and <code>iv</code> must be <code>&#39;binary&#39;</code> encoded strings or\\n<a href=\\\"buffer.html\\\">buffers</a>.\\n\\n</p>\\n\",\n          \"signatures\": [\n            {\n              \"params\": [\n                {\n                  \"name\": \"algorithm\"\n                },\n                {\n                  \"name\": \"key\"\n                },\n                {\n                  \"name\": \"iv\"\n                }\n              ]\n            }\n          ]\n        },\n        {\n          \"textRaw\": \"crypto.createDecipher(algorithm, password)\",\n          \"type\": \"method\",\n          \"name\": \"createDecipher\",\n          \"desc\": \"<p>Creates and returns a decipher object, with the given algorithm and\\nkey.  This is the mirror of the [createCipher()][] above.\\n\\n</p>\\n\",\n          \"signatures\": [\n            {\n              \"params\": [\n                {\n                  \"name\": \"algorithm\"\n                },\n                {\n                  \"name\": \"password\"\n                }\n              ]\n            }\n          ]\n        },\n        {\n          \"textRaw\": \"crypto.createDecipheriv(algorithm, key, iv)\",\n          \"type\": \"method\",\n          \"name\": \"createDecipheriv\",\n          \"desc\": \"<p>Creates and returns a decipher object, with the given algorithm, key\\nand iv.  This is the mirror of the [createCipheriv()][] above.\\n\\n</p>\\n\",\n          \"signatures\": [\n            {\n              \"params\": [\n                {\n                  \"name\": \"algorithm\"\n                },\n                {\n                  \"name\": \"key\"\n                },\n                {\n                  \"name\": \"iv\"\n                }\n              ]\n            }\n          ]\n        },\n        {\n          \"textRaw\": \"crypto.createSign(algorithm)\",\n          \"type\": \"method\",\n          \"name\": \"createSign\",\n          \"desc\": \"<p>Creates and returns a signing object, with the given algorithm.  On\\nrecent OpenSSL releases, <code>openssl list-public-key-algorithms</code> will\\ndisplay the available signing algorithms. Examples are <code>&#39;RSA-SHA256&#39;</code>.\\n\\n</p>\\n\",\n          \"signatures\": [\n            {\n              \"params\": [\n                {\n                  \"name\": \"algorithm\"\n                }\n              ]\n            }\n          ]\n        },\n        {\n          \"textRaw\": \"crypto.createVerify(algorithm)\",\n          \"type\": \"method\",\n          \"name\": \"createVerify\",\n          \"desc\": \"<p>Creates and returns a verification object, with the given algorithm.\\nThis is the mirror of the signing object above.\\n\\n</p>\\n\",\n          \"signatures\": [\n            {\n              \"params\": [\n                {\n                  \"name\": \"algorithm\"\n                }\n              ]\n            }\n          ]\n        },\n        {\n          \"textRaw\": \"crypto.createDiffieHellman(prime_length)\",\n          \"type\": \"method\",\n          \"name\": \"createDiffieHellman\",\n          \"desc\": \"<p>Creates a Diffie-Hellman key exchange object and generates a prime of\\nthe given bit length. The generator used is <code>2</code>.\\n\\n</p>\\n\",\n          \"signatures\": [\n            {\n              \"params\": [\n                {\n                  \"name\": \"prime_length\"\n                }\n              ]\n            }\n          ]\n        },\n        {\n          \"textRaw\": \"crypto.createDiffieHellman(prime, [encoding])\",\n          \"type\": \"method\",\n          \"name\": \"createDiffieHellman\",\n          \"desc\": \"<p>Creates a Diffie-Hellman key exchange object using the supplied prime.\\nThe generator used is <code>2</code>. Encoding can be <code>&#39;binary&#39;</code>, <code>&#39;hex&#39;</code>, or\\n<code>&#39;base64&#39;</code>.  If no encoding is specified, then a buffer is expected.\\n\\n</p>\\n\",\n          \"signatures\": [\n            {\n              \"params\": [\n                {\n                  \"name\": \"prime\"\n                },\n                {\n                  \"name\": \"encoding\",\n                  \"optional\": true\n                }\n              ]\n            }\n          ]\n        },\n        {\n          \"textRaw\": \"crypto.getDiffieHellman(group_name)\",\n          \"type\": \"method\",\n          \"name\": \"getDiffieHellman\",\n          \"desc\": \"<p>Creates a predefined Diffie-Hellman key exchange object.  The\\nsupported groups are: <code>&#39;modp1&#39;</code>, <code>&#39;modp2&#39;</code>, <code>&#39;modp5&#39;</code> (defined in [RFC\\n2412][]) and <code>&#39;modp14&#39;</code>, <code>&#39;modp15&#39;</code>, <code>&#39;modp16&#39;</code>, <code>&#39;modp17&#39;</code>,\\n<code>&#39;modp18&#39;</code> (defined in [RFC 3526][]).  The returned object mimics the\\ninterface of objects created by [crypto.createDiffieHellman()][]\\nabove, but will not allow to change the keys (with\\n[diffieHellman.setPublicKey()][] for example).  The advantage of using\\nthis routine is that the parties don&#39;t have to generate nor exchange\\ngroup modulus beforehand, saving both processor and communication\\ntime.\\n\\n</p>\\n<p>Example (obtaining a shared secret):\\n\\n</p>\\n<pre><code>var crypto = require(&#39;crypto&#39;);\\nvar alice = crypto.getDiffieHellman(&#39;modp5&#39;);\\nvar bob = crypto.getDiffieHellman(&#39;modp5&#39;);\\n\\nalice.generateKeys();\\nbob.generateKeys();\\n\\nvar alice_secret = alice.computeSecret(bob.getPublicKey(), null, &#39;hex&#39;);\\nvar bob_secret = bob.computeSecret(alice.getPublicKey(), null, &#39;hex&#39;);\\n\\n/* alice_secret and bob_secret should be the same */\\nconsole.log(alice_secret == bob_secret);</code></pre>\\n\",\n          \"signatures\": [\n            {\n              \"params\": [\n                {\n                  \"name\": \"group_name\"\n                }\n              ]\n            }\n          ]\n        },\n        {\n          \"textRaw\": \"crypto.pbkdf2(password, salt, iterations, keylen, callback)\",\n          \"type\": \"method\",\n          \"name\": \"pbkdf2\",\n          \"desc\": \"<p>Asynchronous PBKDF2 applies pseudorandom function HMAC-SHA1 to derive\\na key of given length from the given password, salt and iterations.\\nThe callback gets two arguments <code>(err, derivedKey)</code>.\\n\\n</p>\\n\",\n          \"signatures\": [\n            {\n              \"params\": [\n                {\n                  \"name\": \"password\"\n                },\n                {\n                  \"name\": \"salt\"\n                },\n                {\n                  \"name\": \"iterations\"\n                },\n                {\n                  \"name\": \"keylen\"\n                },\n                {\n                  \"name\": \"callback\"\n                }\n              ]\n            }\n          ]\n        },\n        {\n          \"textRaw\": \"crypto.pbkdf2Sync(password, salt, iterations, keylen)\",\n          \"type\": \"method\",\n          \"name\": \"pbkdf2Sync\",\n          \"desc\": \"<p>Synchronous PBKDF2 function.  Returns derivedKey or throws error.\\n\\n</p>\\n\",\n          \"signatures\": [\n            {\n              \"params\": [\n                {\n                  \"name\": \"password\"\n                },\n                {\n                  \"name\": \"salt\"\n                },\n                {\n                  \"name\": \"iterations\"\n                },\n                {\n                  \"name\": \"keylen\"\n                }\n              ]\n            }\n          ]\n        },\n        {\n          \"textRaw\": \"crypto.randomBytes(size, [callback])\",\n          \"type\": \"method\",\n          \"name\": \"randomBytes\",\n          \"desc\": \"<p>Generates cryptographically strong pseudo-random data. Usage:\\n\\n</p>\\n<pre><code>// async\\ncrypto.randomBytes(256, function(ex, buf) {\\n  if (ex) throw ex;\\n  console.log(&#39;Have %d bytes of random data: %s&#39;, buf.length, buf);\\n});\\n\\n// sync\\ntry {\\n  var buf = crypto.randomBytes(256);\\n  console.log(&#39;Have %d bytes of random data: %s&#39;, buf.length, buf);\\n} catch (ex) {\\n  // handle error\\n  // most likely, entropy sources are drained\\n}</code></pre>\\n<p>NOTE: Will throw error or invoke callback with error, if there is not enough\\naccumulated entropy to generate cryptographically strong data. In other words,\\n<code>crypto.randomBytes</code> without callback will not block even if all entropy sources\\nare drained.\\n\\n</p>\\n\",\n          \"signatures\": [\n            {\n              \"params\": [\n                {\n                  \"name\": \"size\"\n                },\n                {\n                  \"name\": \"callback\",\n                  \"optional\": true\n                }\n              ]\n            }\n          ]\n        },\n        {\n          \"textRaw\": \"crypto.pseudoRandomBytes(size, [callback])\",\n          \"type\": \"method\",\n          \"name\": \"pseudoRandomBytes\",\n          \"desc\": \"<p>Generates <em>non</em>-cryptographically strong pseudo-random data. The data\\nreturned will be unique if it is sufficiently long, but is not\\nnecessarily unpredictable. For this reason, the output of this\\nfunction should never be used where unpredictability is important,\\nsuch as in the generation of encryption keys.\\n\\n</p>\\n<p>Usage is otherwise identical to <code>crypto.randomBytes</code>.\\n\\n</p>\\n\",\n          \"signatures\": [\n            {\n              \"params\": [\n                {\n                  \"name\": \"size\"\n                },\n                {\n                  \"name\": \"callback\",\n                  \"optional\": true\n                }\n              ]\n            }\n          ]\n        }\n      ],\n      \"classes\": [\n        {\n          \"textRaw\": \"Class: Hash\",\n          \"type\": \"class\",\n          \"name\": \"Hash\",\n          \"desc\": \"<p>The class for creating hash digests of data.\\n\\n</p>\\n<p>It is a <a href=\\\"stream.html\\\">stream</a> that is both readable and writable.  The\\nwritten data is used to compute the hash.  Once the writable side of\\nthe stream is ended, use the <code>read()</code> method to get the computed hash\\ndigest.  The legacy <code>update</code> and <code>digest</code> methods are also supported.\\n\\n</p>\\n<p>Returned by <code>crypto.createHash</code>.\\n\\n</p>\\n\",\n          \"methods\": [\n            {\n              \"textRaw\": \"hash.update(data, [input_encoding])\",\n              \"type\": \"method\",\n              \"name\": \"update\",\n              \"desc\": \"<p>Updates the hash content with the given <code>data</code>, the encoding of which\\nis given in <code>input_encoding</code> and can be <code>&#39;utf8&#39;</code>, <code>&#39;ascii&#39;</code> or\\n<code>&#39;binary&#39;</code>.  If no encoding is provided and the input is a string an\\nencoding of <code>&#39;binary&#39;</code> is enforced. If <code>data</code> is a <code>Buffer</code> then\\n<code>input_encoding</code> is ignored.\\n\\n</p>\\n<p>This can be called many times with new data as it is streamed.\\n\\n</p>\\n\",\n              \"signatures\": [\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"data\"\n                    },\n                    {\n                      \"name\": \"input_encoding\",\n                      \"optional\": true\n                    }\n                  ]\n                }\n              ]\n            },\n            {\n              \"textRaw\": \"hash.digest([encoding])\",\n              \"type\": \"method\",\n              \"name\": \"digest\",\n              \"desc\": \"<p>Calculates the digest of all of the passed data to be hashed.  The\\n<code>encoding</code> can be <code>&#39;hex&#39;</code>, <code>&#39;binary&#39;</code> or <code>&#39;base64&#39;</code>.  If no encoding\\nis provided, then a buffer is returned.\\n\\n</p>\\n<p>Note: <code>hash</code> object can not be used after <code>digest()</code> method has been\\ncalled.\\n\\n\\n</p>\\n\",\n              \"signatures\": [\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"encoding\",\n                      \"optional\": true\n                    }\n                  ]\n                }\n              ]\n            }\n          ]\n        },\n        {\n          \"textRaw\": \"Class: Hmac\",\n          \"type\": \"class\",\n          \"name\": \"Hmac\",\n          \"desc\": \"<p>Class for creating cryptographic hmac content.\\n\\n</p>\\n<p>Returned by <code>crypto.createHmac</code>.\\n\\n</p>\\n\",\n          \"methods\": [\n            {\n              \"textRaw\": \"hmac.update(data)\",\n              \"type\": \"method\",\n              \"name\": \"update\",\n              \"desc\": \"<p>Update the hmac content with the given <code>data</code>.  This can be called\\nmany times with new data as it is streamed.\\n\\n</p>\\n\",\n              \"signatures\": [\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"data\"\n                    }\n                  ]\n                }\n              ]\n            },\n            {\n              \"textRaw\": \"hmac.digest([encoding])\",\n              \"type\": \"method\",\n              \"name\": \"digest\",\n              \"desc\": \"<p>Calculates the digest of all of the passed data to the hmac.  The\\n<code>encoding</code> can be <code>&#39;hex&#39;</code>, <code>&#39;binary&#39;</code> or <code>&#39;base64&#39;</code>.  If no encoding\\nis provided, then a buffer is returned.\\n\\n</p>\\n<p>Note: <code>hmac</code> object can not be used after <code>digest()</code> method has been\\ncalled.\\n\\n\\n</p>\\n\",\n              \"signatures\": [\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"encoding\",\n                      \"optional\": true\n                    }\n                  ]\n                }\n              ]\n            }\n          ]\n        },\n        {\n          \"textRaw\": \"Class: Cipher\",\n          \"type\": \"class\",\n          \"name\": \"Cipher\",\n          \"desc\": \"<p>Class for encrypting data.\\n\\n</p>\\n<p>Returned by <code>crypto.createCipher</code> and <code>crypto.createCipheriv</code>.\\n\\n</p>\\n<p>Cipher objects are <a href=\\\"stream.html\\\">streams</a> that are both readable and\\nwritable.  The written plain text data is used to produce the\\nencrypted data on the readable side.  The legacy <code>update</code> and <code>final</code>\\nmethods are also supported.\\n\\n</p>\\n\",\n          \"methods\": [\n            {\n              \"textRaw\": \"cipher.update(data, [input_encoding], [output_encoding])\",\n              \"type\": \"method\",\n              \"name\": \"update\",\n              \"desc\": \"<p>Updates the cipher with <code>data</code>, the encoding of which is given in\\n<code>input_encoding</code> and can be <code>&#39;utf8&#39;</code>, <code>&#39;ascii&#39;</code> or <code>&#39;binary&#39;</code>.  If no\\nencoding is provided, then a buffer is expected.\\nIf <code>data</code> is a <code>Buffer</code> then <code>input_encoding</code> is ignored.\\n\\n</p>\\n<p>The <code>output_encoding</code> specifies the output format of the enciphered\\ndata, and can be <code>&#39;binary&#39;</code>, <code>&#39;base64&#39;</code> or <code>&#39;hex&#39;</code>.  If no encoding is\\nprovided, then a buffer is returned.\\n\\n</p>\\n<p>Returns the enciphered contents, and can be called many times with new\\ndata as it is streamed.\\n\\n</p>\\n\",\n              \"signatures\": [\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"data\"\n                    },\n                    {\n                      \"name\": \"input_encoding\",\n                      \"optional\": true\n                    },\n                    {\n                      \"name\": \"output_encoding\",\n                      \"optional\": true\n                    }\n                  ]\n                }\n              ]\n            },\n            {\n              \"textRaw\": \"cipher.final([output_encoding])\",\n              \"type\": \"method\",\n              \"name\": \"final\",\n              \"desc\": \"<p>Returns any remaining enciphered contents, with <code>output_encoding</code>\\nbeing one of: <code>&#39;binary&#39;</code>, <code>&#39;base64&#39;</code> or <code>&#39;hex&#39;</code>.  If no encoding is\\nprovided, then a buffer is returned.\\n\\n</p>\\n<p>Note: <code>cipher</code> object can not be used after <code>final()</code> method has been\\ncalled.\\n\\n</p>\\n\",\n              \"signatures\": [\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"output_encoding\",\n                      \"optional\": true\n                    }\n                  ]\n                }\n              ]\n            },\n            {\n              \"textRaw\": \"cipher.setAutoPadding(auto_padding=true)\",\n              \"type\": \"method\",\n              \"name\": \"setAutoPadding\",\n              \"desc\": \"<p>You can disable automatic padding of the input data to block size. If\\n<code>auto_padding</code> is false, the length of the entire input data must be a\\nmultiple of the cipher&#39;s block size or <code>final</code> will fail.  Useful for\\nnon-standard padding, e.g. using <code>0x0</code> instead of PKCS padding. You\\nmust call this before <code>cipher.final</code>.\\n\\n\\n</p>\\n\",\n              \"signatures\": [\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"auto_padding\",\n                      \"default\": \"true\"\n                    }\n                  ]\n                }\n              ]\n            }\n          ]\n        },\n        {\n          \"textRaw\": \"Class: Decipher\",\n          \"type\": \"class\",\n          \"name\": \"Decipher\",\n          \"desc\": \"<p>Class for decrypting data.\\n\\n</p>\\n<p>Returned by <code>crypto.createDecipher</code> and <code>crypto.createDecipheriv</code>.\\n\\n</p>\\n<p>Decipher objects are <a href=\\\"stream.html\\\">streams</a> that are both readable and\\nwritable.  The written enciphered data is used to produce the\\nplain-text data on the the readable side.  The legacy <code>update</code> and\\n<code>final</code> methods are also supported.\\n\\n</p>\\n\",\n          \"methods\": [\n            {\n              \"textRaw\": \"decipher.update(data, [input_encoding], [output_encoding])\",\n              \"type\": \"method\",\n              \"name\": \"update\",\n              \"desc\": \"<p>Updates the decipher with <code>data</code>, which is encoded in <code>&#39;binary&#39;</code>,\\n<code>&#39;base64&#39;</code> or <code>&#39;hex&#39;</code>.  If no encoding is provided, then a buffer is\\nexpected.\\nIf <code>data</code> is a <code>Buffer</code> then <code>input_encoding</code> is ignored.\\n\\n</p>\\n<p>The <code>output_decoding</code> specifies in what format to return the\\ndeciphered plaintext: <code>&#39;binary&#39;</code>, <code>&#39;ascii&#39;</code> or <code>&#39;utf8&#39;</code>.  If no\\nencoding is provided, then a buffer is returned.\\n\\n</p>\\n\",\n              \"signatures\": [\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"data\"\n                    },\n                    {\n                      \"name\": \"input_encoding\",\n                      \"optional\": true\n                    },\n                    {\n                      \"name\": \"output_encoding\",\n                      \"optional\": true\n                    }\n                  ]\n                }\n              ]\n            },\n            {\n              \"textRaw\": \"decipher.final([output_encoding])\",\n              \"type\": \"method\",\n              \"name\": \"final\",\n              \"desc\": \"<p>Returns any remaining plaintext which is deciphered, with\\n<code>output_encoding</code> being one of: <code>&#39;binary&#39;</code>, <code>&#39;ascii&#39;</code> or <code>&#39;utf8&#39;</code>.  If\\nno encoding is provided, then a buffer is returned.\\n\\n</p>\\n<p>Note: <code>decipher</code> object can not be used after <code>final()</code> method has been\\ncalled.\\n\\n</p>\\n\",\n              \"signatures\": [\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"output_encoding\",\n                      \"optional\": true\n                    }\n                  ]\n                }\n              ]\n            },\n            {\n              \"textRaw\": \"decipher.setAutoPadding(auto_padding=true)\",\n              \"type\": \"method\",\n              \"name\": \"setAutoPadding\",\n              \"desc\": \"<p>You can disable auto padding if the data has been encrypted without\\nstandard block padding to prevent <code>decipher.final</code> from checking and\\nremoving it. Can only work if the input data&#39;s length is a multiple of\\nthe ciphers block size. You must call this before streaming data to\\n<code>decipher.update</code>.\\n\\n</p>\\n\",\n              \"signatures\": [\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"auto_padding\",\n                      \"default\": \"true\"\n                    }\n                  ]\n                }\n              ]\n            }\n          ]\n        },\n        {\n          \"textRaw\": \"Class: Sign\",\n          \"type\": \"class\",\n          \"name\": \"Sign\",\n          \"desc\": \"<p>Class for generating signatures.\\n\\n</p>\\n<p>Returned by <code>crypto.createSign</code>.\\n\\n</p>\\n<p>Sign objects are writable <a href=\\\"stream.html\\\">streams</a>.  The written data is\\nused to generate the signature.  Once all of the data has been\\nwritten, the <code>sign</code> method will return the signature.  The legacy\\n<code>update</code> method is also supported.\\n\\n</p>\\n\",\n          \"methods\": [\n            {\n              \"textRaw\": \"sign.update(data)\",\n              \"type\": \"method\",\n              \"name\": \"update\",\n              \"desc\": \"<p>Updates the sign object with data.  This can be called many times\\nwith new data as it is streamed.\\n\\n</p>\\n\",\n              \"signatures\": [\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"data\"\n                    }\n                  ]\n                }\n              ]\n            },\n            {\n              \"textRaw\": \"sign.sign(private_key, [output_format])\",\n              \"type\": \"method\",\n              \"name\": \"sign\",\n              \"desc\": \"<p>Calculates the signature on all the updated data passed through the\\nsign.  <code>private_key</code> is a string containing the PEM encoded private\\nkey for signing.\\n\\n</p>\\n<p>Returns the signature in <code>output_format</code> which can be <code>&#39;binary&#39;</code>,\\n<code>&#39;hex&#39;</code> or <code>&#39;base64&#39;</code>. If no encoding is provided, then a buffer is\\nreturned.\\n\\n</p>\\n<p>Note: <code>sign</code> object can not be used after <code>sign()</code> method has been\\ncalled.\\n\\n</p>\\n\",\n              \"signatures\": [\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"private_key\"\n                    },\n                    {\n                      \"name\": \"output_format\",\n                      \"optional\": true\n                    }\n                  ]\n                }\n              ]\n            }\n          ]\n        },\n        {\n          \"textRaw\": \"Class: Verify\",\n          \"type\": \"class\",\n          \"name\": \"Verify\",\n          \"desc\": \"<p>Class for verifying signatures.\\n\\n</p>\\n<p>Returned by <code>crypto.createVerify</code>.\\n\\n</p>\\n<p>Verify objects are writable <a href=\\\"stream.html\\\">streams</a>.  The written data\\nis used to validate against the supplied signature.  Once all of the\\ndata has been written, the <code>verify</code> method will return true if the\\nsupplied signature is valid.  The legacy <code>update</code> method is also\\nsupported.\\n\\n</p>\\n\",\n          \"methods\": [\n            {\n              \"textRaw\": \"verifier.update(data)\",\n              \"type\": \"method\",\n              \"name\": \"update\",\n              \"desc\": \"<p>Updates the verifier object with data.  This can be called many times\\nwith new data as it is streamed.\\n\\n</p>\\n\",\n              \"signatures\": [\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"data\"\n                    }\n                  ]\n                }\n              ]\n            },\n            {\n              \"textRaw\": \"verifier.verify(object, signature, [signature_format])\",\n              \"type\": \"method\",\n              \"name\": \"verify\",\n              \"desc\": \"<p>Verifies the signed data by using the <code>object</code> and <code>signature</code>.\\n<code>object</code> is  a string containing a PEM encoded object, which can be\\none of RSA public key, DSA public key, or X.509 certificate.\\n<code>signature</code> is the previously calculated signature for the data, in\\nthe <code>signature_format</code> which can be <code>&#39;binary&#39;</code>, <code>&#39;hex&#39;</code> or <code>&#39;base64&#39;</code>.\\nIf no encoding is specified, then a buffer is expected.\\n\\n</p>\\n<p>Returns true or false depending on the validity of the signature for\\nthe data and public key.\\n\\n</p>\\n<p>Note: <code>verifier</code> object can not be used after <code>verify()</code> method has been\\ncalled.\\n\\n</p>\\n\",\n              \"signatures\": [\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"object\"\n                    },\n                    {\n                      \"name\": \"signature\"\n                    },\n                    {\n                      \"name\": \"signature_format\",\n                      \"optional\": true\n                    }\n                  ]\n                }\n              ]\n            }\n          ]\n        },\n        {\n          \"textRaw\": \"Class: DiffieHellman\",\n          \"type\": \"class\",\n          \"name\": \"DiffieHellman\",\n          \"desc\": \"<p>The class for creating Diffie-Hellman key exchanges.\\n\\n</p>\\n<p>Returned by <code>crypto.createDiffieHellman</code>.\\n\\n</p>\\n\",\n          \"methods\": [\n            {\n              \"textRaw\": \"diffieHellman.generateKeys([encoding])\",\n              \"type\": \"method\",\n              \"name\": \"generateKeys\",\n              \"desc\": \"<p>Generates private and public Diffie-Hellman key values, and returns\\nthe public key in the specified encoding. This key should be\\ntransferred to the other party. Encoding can be <code>&#39;binary&#39;</code>, <code>&#39;hex&#39;</code>,\\nor <code>&#39;base64&#39;</code>.  If no encoding is provided, then a buffer is returned.\\n\\n</p>\\n\",\n              \"signatures\": [\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"encoding\",\n                      \"optional\": true\n                    }\n                  ]\n                }\n              ]\n            },\n            {\n              \"textRaw\": \"diffieHellman.computeSecret(other_public_key, [input_encoding], [output_encoding])\",\n              \"type\": \"method\",\n              \"name\": \"computeSecret\",\n              \"desc\": \"<p>Computes the shared secret using <code>other_public_key</code> as the other\\nparty&#39;s public key and returns the computed shared secret. Supplied\\nkey is interpreted using specified <code>input_encoding</code>, and secret is\\nencoded using specified <code>output_encoding</code>. Encodings can be\\n<code>&#39;binary&#39;</code>, <code>&#39;hex&#39;</code>, or <code>&#39;base64&#39;</code>. If the input encoding is not\\nprovided, then a buffer is expected.\\n\\n</p>\\n<p>If no output encoding is given, then a buffer is returned.\\n\\n</p>\\n\",\n              \"signatures\": [\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"other_public_key\"\n                    },\n                    {\n                      \"name\": \"input_encoding\",\n                      \"optional\": true\n                    },\n                    {\n                      \"name\": \"output_encoding\",\n                      \"optional\": true\n                    }\n                  ]\n                }\n              ]\n            },\n            {\n              \"textRaw\": \"diffieHellman.getPrime([encoding])\",\n              \"type\": \"method\",\n              \"name\": \"getPrime\",\n              \"desc\": \"<p>Returns the Diffie-Hellman prime in the specified encoding, which can\\nbe <code>&#39;binary&#39;</code>, <code>&#39;hex&#39;</code>, or <code>&#39;base64&#39;</code>. If no encoding is provided,\\nthen a buffer is returned.\\n\\n</p>\\n\",\n              \"signatures\": [\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"encoding\",\n                      \"optional\": true\n                    }\n                  ]\n                }\n              ]\n            },\n            {\n              \"textRaw\": \"diffieHellman.getGenerator([encoding])\",\n              \"type\": \"method\",\n              \"name\": \"getGenerator\",\n              \"desc\": \"<p>Returns the Diffie-Hellman generator in the specified encoding, which can\\nbe <code>&#39;binary&#39;</code>, <code>&#39;hex&#39;</code>, or <code>&#39;base64&#39;</code>. If no encoding is provided,\\nthen a buffer is returned.\\n\\n</p>\\n\",\n              \"signatures\": [\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"encoding\",\n                      \"optional\": true\n                    }\n                  ]\n                }\n              ]\n            },\n            {\n              \"textRaw\": \"diffieHellman.getPublicKey([encoding])\",\n              \"type\": \"method\",\n              \"name\": \"getPublicKey\",\n              \"desc\": \"<p>Returns the Diffie-Hellman public key in the specified encoding, which\\ncan be <code>&#39;binary&#39;</code>, <code>&#39;hex&#39;</code>, or <code>&#39;base64&#39;</code>. If no encoding is provided,\\nthen a buffer is returned.\\n\\n</p>\\n\",\n              \"signatures\": [\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"encoding\",\n                      \"optional\": true\n                    }\n                  ]\n                }\n              ]\n            },\n            {\n              \"textRaw\": \"diffieHellman.getPrivateKey([encoding])\",\n              \"type\": \"method\",\n              \"name\": \"getPrivateKey\",\n              \"desc\": \"<p>Returns the Diffie-Hellman private key in the specified encoding,\\nwhich can be <code>&#39;binary&#39;</code>, <code>&#39;hex&#39;</code>, or <code>&#39;base64&#39;</code>. If no encoding is\\nprovided, then a buffer is returned.\\n\\n</p>\\n\",\n              \"signatures\": [\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"encoding\",\n                      \"optional\": true\n                    }\n                  ]\n                }\n              ]\n            },\n            {\n              \"textRaw\": \"diffieHellman.setPublicKey(public_key, [encoding])\",\n              \"type\": \"method\",\n              \"name\": \"setPublicKey\",\n              \"desc\": \"<p>Sets the Diffie-Hellman public key. Key encoding can be <code>&#39;binary&#39;</code>,\\n<code>&#39;hex&#39;</code> or <code>&#39;base64&#39;</code>. If no encoding is provided, then a buffer is\\nexpected.\\n\\n</p>\\n\",\n              \"signatures\": [\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"public_key\"\n                    },\n                    {\n                      \"name\": \"encoding\",\n                      \"optional\": true\n                    }\n                  ]\n                }\n              ]\n            },\n            {\n              \"textRaw\": \"diffieHellman.setPrivateKey(private_key, [encoding])\",\n              \"type\": \"method\",\n              \"name\": \"setPrivateKey\",\n              \"desc\": \"<p>Sets the Diffie-Hellman private key. Key encoding can be <code>&#39;binary&#39;</code>,\\n<code>&#39;hex&#39;</code> or <code>&#39;base64&#39;</code>. If no encoding is provided, then a buffer is\\nexpected.\\n\\n</p>\\n\",\n              \"signatures\": [\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"private_key\"\n                    },\n                    {\n                      \"name\": \"encoding\",\n                      \"optional\": true\n                    }\n                  ]\n                }\n              ]\n            }\n          ]\n        }\n      ],\n      \"properties\": [\n        {\n          \"textRaw\": \"crypto.DEFAULT_ENCODING\",\n          \"name\": \"DEFAULT_ENCODING\",\n          \"desc\": \"<p>The default encoding to use for functions that can take either strings\\nor buffers.  The default value is <code>&#39;buffer&#39;</code>, which makes it default\\nto using Buffer objects.  This is here to make the crypto module more\\neasily compatible with legacy programs that expected <code>&#39;binary&#39;</code> to be\\nthe default encoding.\\n\\n</p>\\n<p>Note that new programs will probably expect buffers, so only use this\\nas a temporary measure.\\n\\n</p>\\n\"\n        }\n      ],\n      \"modules\": [\n        {\n          \"textRaw\": \"Recent API Changes\",\n          \"name\": \"recent_api_changes\",\n          \"desc\": \"<p>The Crypto module was added to Node before there was the concept of a\\nunified Stream API, and before there were Buffer objects for handling\\nbinary data.\\n\\n</p>\\n<p>As such, the streaming classes don&#39;t have the typical methods found on\\nother Node classes, and many methods accepted and returned\\nBinary-encoded strings by default rather than Buffers.  This was\\nchanged to use Buffers by default instead.\\n\\n</p>\\n<p>This is a breaking change for some use cases, but not all.\\n\\n</p>\\n<p>For example, if you currently use the default arguments to the Sign\\nclass, and then pass the results to the Verify class, without ever\\ninspecting the data, then it will continue to work as before.  Where\\nyou once got a binary string and then presented the binary string to\\nthe Verify object, you&#39;ll now get a Buffer, and present the Buffer to\\nthe Verify object.\\n\\n</p>\\n<p>However, if you were doing things with the string data that will not\\nwork properly on Buffers (such as, concatenating them, storing in\\ndatabases, etc.), or you are passing binary strings to the crypto\\nfunctions without an encoding argument, then you will need to start\\nproviding encoding arguments to specify which encoding you&#39;d like to\\nuse.  To switch to the previous style of using binary strings by\\ndefault, set the <code>crypto.DEFAULT_ENCODING</code> field to &#39;binary&#39;.  Note\\nthat new programs will probably expect buffers, so only use this as a\\ntemporary measure.\\n\\n\\n</p>\\n\",\n          \"type\": \"module\",\n          \"displayName\": \"Recent API Changes\"\n        }\n      ],\n      \"type\": \"module\",\n      \"displayName\": \"Crypto\"\n    }\n  ]\n}\n"}{"source":"http://nodejs.org/api/events.json","title":"Events","content":"{\n  \"source\": \"doc/api/events.markdown\",\n  \"modules\": [\n    {\n      \"textRaw\": \"Events\",\n      \"name\": \"Events\",\n      \"stability\": 4,\n      \"stabilityText\": \"API Frozen\",\n      \"type\": \"module\",\n      \"desc\": \"<p>Many objects in Node emit events: a <code>net.Server</code> emits an event each time\\na peer connects to it, a <code>fs.readStream</code> emits an event when the file is\\nopened. All objects which emit events are instances of <code>events.EventEmitter</code>.\\nYou can access this module by doing: <code>require(&quot;events&quot;);</code>\\n\\n</p>\\n<p>Typically, event names are represented by a camel-cased string, however,\\nthere aren&#39;t any strict restrictions on that, as any string will be accepted.\\n\\n</p>\\n<p>Functions can then be attached to objects, to be executed when an event\\nis emitted. These functions are called <em>listeners</em>. Inside a listener\\nfunction, <code>this</code> refers to the <code>EventEmitter</code> that the listener was\\nattached to.\\n\\n\\n</p>\\n\",\n      \"classes\": [\n        {\n          \"textRaw\": \"Class: events.EventEmitter\",\n          \"type\": \"class\",\n          \"name\": \"events.EventEmitter\",\n          \"desc\": \"<p>To access the EventEmitter class, <code>require(&#39;events&#39;).EventEmitter</code>.\\n\\n</p>\\n<p>When an <code>EventEmitter</code> instance experiences an error, the typical action is\\nto emit an <code>&#39;error&#39;</code> event.  Error events are treated as a special case in node.\\nIf there is no listener for it, then the default action is to print a stack\\ntrace and exit the program.\\n\\n</p>\\n<p>All EventEmitters emit the event <code>&#39;newListener&#39;</code> when new listeners are\\nadded and <code>&#39;removeListener&#39;</code> when a listener is removed.\\n\\n</p>\\n\",\n          \"methods\": [\n            {\n              \"textRaw\": \"emitter.addListener(event, listener)\",\n              \"type\": \"method\",\n              \"name\": \"addListener\",\n              \"desc\": \"<p>Adds a listener to the end of the listeners array for the specified event.\\n\\n</p>\\n<pre><code>server.on(&#39;connection&#39;, function (stream) {\\n  console.log(&#39;someone connected!&#39;);\\n});</code></pre>\\n<p>Returns emitter, so calls can be chained.\\n\\n</p>\\n\",\n              \"signatures\": [\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"event\"\n                    },\n                    {\n                      \"name\": \"listener\"\n                    }\n                  ]\n                },\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"event\"\n                    },\n                    {\n                      \"name\": \"listener\"\n                    }\n                  ]\n                }\n              ]\n            },\n            {\n              \"textRaw\": \"emitter.on(event, listener)\",\n              \"type\": \"method\",\n              \"name\": \"on\",\n              \"desc\": \"<p>Adds a listener to the end of the listeners array for the specified event.\\n\\n</p>\\n<pre><code>server.on(&#39;connection&#39;, function (stream) {\\n  console.log(&#39;someone connected!&#39;);\\n});</code></pre>\\n<p>Returns emitter, so calls can be chained.\\n\\n</p>\\n\",\n              \"signatures\": [\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"event\"\n                    },\n                    {\n                      \"name\": \"listener\"\n                    }\n                  ]\n                }\n              ]\n            },\n            {\n              \"textRaw\": \"emitter.once(event, listener)\",\n              \"type\": \"method\",\n              \"name\": \"once\",\n              \"desc\": \"<p>Adds a <strong>one time</strong> listener for the event. This listener is\\ninvoked only the next time the event is fired, after which\\nit is removed.\\n\\n</p>\\n<pre><code>server.once(&#39;connection&#39;, function (stream) {\\n  console.log(&#39;Ah, we have our first user!&#39;);\\n});</code></pre>\\n<p>Returns emitter, so calls can be chained.\\n\\n</p>\\n\",\n              \"signatures\": [\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"event\"\n                    },\n                    {\n                      \"name\": \"listener\"\n                    }\n                  ]\n                }\n              ]\n            },\n            {\n              \"textRaw\": \"emitter.removeListener(event, listener)\",\n              \"type\": \"method\",\n              \"name\": \"removeListener\",\n              \"desc\": \"<p>Remove a listener from the listener array for the specified event.\\n<strong>Caution</strong>: changes array indices in the listener array behind the listener.\\n\\n</p>\\n<pre><code>var callback = function(stream) {\\n  console.log(&#39;someone connected!&#39;);\\n};\\nserver.on(&#39;connection&#39;, callback);\\n// ...\\nserver.removeListener(&#39;connection&#39;, callback);</code></pre>\\n<p>Returns emitter, so calls can be chained.\\n\\n</p>\\n\",\n              \"signatures\": [\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"event\"\n                    },\n                    {\n                      \"name\": \"listener\"\n                    }\n                  ]\n                }\n              ]\n            },\n            {\n              \"textRaw\": \"emitter.removeAllListeners([event])\",\n              \"type\": \"method\",\n              \"name\": \"removeAllListeners\",\n              \"desc\": \"<p>Removes all listeners, or those of the specified event. It&#39;s not a good idea to\\nremove listeners that were added elsewhere in the code, especially when it&#39;s on\\nan emitter that you didn&#39;t create (e.g. sockets or file streams).\\n\\n</p>\\n<p>Returns emitter, so calls can be chained.\\n\\n</p>\\n\",\n              \"signatures\": [\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"event\",\n                      \"optional\": true\n                    }\n                  ]\n                }\n              ]\n            },\n            {\n              \"textRaw\": \"emitter.setMaxListeners(n)\",\n              \"type\": \"method\",\n              \"name\": \"setMaxListeners\",\n              \"desc\": \"<p>By default EventEmitters will print a warning if more than 10 listeners are\\nadded for a particular event. This is a useful default which helps finding memory leaks.\\nObviously not all Emitters should be limited to 10. This function allows\\nthat to be increased. Set to zero for unlimited.\\n\\n\\n</p>\\n\",\n              \"signatures\": [\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"n\"\n                    }\n                  ]\n                }\n              ]\n            },\n            {\n              \"textRaw\": \"emitter.listeners(event)\",\n              \"type\": \"method\",\n              \"name\": \"listeners\",\n              \"desc\": \"<p>Returns an array of listeners for the specified event.\\n\\n</p>\\n<pre><code>server.on(&#39;connection&#39;, function (stream) {\\n  console.log(&#39;someone connected!&#39;);\\n});\\nconsole.log(util.inspect(server.listeners(&#39;connection&#39;))); // [ [Function] ]</code></pre>\\n\",\n              \"signatures\": [\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"event\"\n                    }\n                  ]\n                }\n              ]\n            },\n            {\n              \"textRaw\": \"emitter.emit(event, [arg1], [arg2], [...])\",\n              \"type\": \"method\",\n              \"name\": \"emit\",\n              \"desc\": \"<p>Execute each of the listeners in order with the supplied arguments.\\n\\n</p>\\n<p>Returns <code>true</code> if event had listeners, <code>false</code> otherwise.\\n\\n\\n</p>\\n\",\n              \"signatures\": [\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"event\"\n                    },\n                    {\n                      \"name\": \"arg1\",\n                      \"optional\": true\n                    },\n                    {\n                      \"name\": \"arg2\",\n                      \"optional\": true\n                    },\n                    {\n                      \"name\": \"...\",\n                      \"optional\": true\n                    }\n                  ]\n                }\n              ]\n            }\n          ],\n          \"classMethods\": [\n            {\n              \"textRaw\": \"Class Method: EventEmitter.listenerCount(emitter, event)\",\n              \"type\": \"classMethod\",\n              \"name\": \"listenerCount\",\n              \"desc\": \"<p>Return the number of listeners for a given event.\\n\\n\\n</p>\\n\",\n              \"signatures\": [\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"emitter\"\n                    },\n                    {\n                      \"name\": \"event\"\n                    }\n                  ]\n                }\n              ]\n            }\n          ],\n          \"events\": [\n            {\n              \"textRaw\": \"Event: 'newListener'\",\n              \"type\": \"event\",\n              \"name\": \"newListener\",\n              \"params\": [],\n              \"desc\": \"<p>This event is emitted any time someone adds a new listener.  It is unspecified\\nif <code>listener</code> is in the list returned by <code>emitter.listeners(event)</code>.\\n\\n\\n</p>\\n\"\n            },\n            {\n              \"textRaw\": \"Event: 'removeListener'\",\n              \"type\": \"event\",\n              \"name\": \"removeListener\",\n              \"params\": [],\n              \"desc\": \"<p>This event is emitted any time someone removes a listener.  It is unspecified\\nif <code>listener</code> is in the list returned by <code>emitter.listeners(event)</code>.\\n</p>\\n\"\n            }\n          ]\n        }\n      ]\n    }\n  ]\n}\n"}{"source":"http://nodejs.org/api/dns.json","title":"DNS","content":"{\n  \"source\": \"doc/api/dns.markdown\",\n  \"modules\": [\n    {\n      \"textRaw\": \"DNS\",\n      \"name\": \"dns\",\n      \"stability\": 3,\n      \"stabilityText\": \"Stable\",\n      \"desc\": \"<p>Use <code>require(&#39;dns&#39;)</code> to access this module. All methods in the dns module\\nuse C-Ares except for <code>dns.lookup</code> which uses <code>getaddrinfo(3)</code> in a thread\\npool. C-Ares is much faster than <code>getaddrinfo</code> but the system resolver is\\nmore consistent with how other programs operate. When a user does\\n<code>net.connect(80, &#39;google.com&#39;)</code> or <code>http.get({ host: &#39;google.com&#39; })</code> the\\n<code>dns.lookup</code> method is used. Users who need to do a large number of lookups\\nquickly should use the methods that go through C-Ares.\\n\\n</p>\\n<p>Here is an example which resolves <code>&#39;www.google.com&#39;</code> then reverse\\nresolves the IP addresses which are returned.\\n\\n</p>\\n<pre><code>var dns = require(&#39;dns&#39;);\\n\\ndns.resolve4(&#39;www.google.com&#39;, function (err, addresses) {\\n  if (err) throw err;\\n\\n  console.log(&#39;addresses: &#39; + JSON.stringify(addresses));\\n\\n  addresses.forEach(function (a) {\\n    dns.reverse(a, function (err, domains) {\\n      if (err) {\\n        throw err;\\n      }\\n\\n      console.log(&#39;reverse for &#39; + a + &#39;: &#39; + JSON.stringify(domains));\\n    });\\n  });\\n});</code></pre>\\n\",\n      \"methods\": [\n        {\n          \"textRaw\": \"dns.lookup(domain, [family], callback)\",\n          \"type\": \"method\",\n          \"name\": \"lookup\",\n          \"desc\": \"<p>Resolves a domain (e.g. <code>&#39;google.com&#39;</code>) into the first found A (IPv4) or\\nAAAA (IPv6) record.\\nThe <code>family</code> can be the integer <code>4</code> or <code>6</code>. Defaults to <code>null</code> that indicates\\nboth Ip v4 and v6 address family.\\n\\n</p>\\n<p>The callback has arguments <code>(err, address, family)</code>.  The <code>address</code> argument\\nis a string representation of a IP v4 or v6 address. The <code>family</code> argument\\nis either the integer 4 or 6 and denotes the family of <code>address</code> (not\\nnecessarily the value initially passed to <code>lookup</code>).\\n\\n</p>\\n<p>On error, <code>err</code> is an <code>Error</code> object, where <code>err.code</code> is the error code.\\nKeep in mind that <code>err.code</code> will be set to <code>&#39;ENOENT&#39;</code> not only when\\nthe domain does not exist but also when the lookup fails in other ways\\nsuch as no available file descriptors.\\n\\n\\n</p>\\n\",\n          \"signatures\": [\n            {\n              \"params\": [\n                {\n                  \"name\": \"domain\"\n                },\n                {\n                  \"name\": \"family\",\n                  \"optional\": true\n                },\n                {\n                  \"name\": \"callback\"\n                }\n              ]\n            }\n          ]\n        },\n        {\n          \"textRaw\": \"dns.resolve(domain, [rrtype], callback)\",\n          \"type\": \"method\",\n          \"name\": \"resolve\",\n          \"desc\": \"<p>Resolves a domain (e.g. <code>&#39;google.com&#39;</code>) into an array of the record types\\nspecified by rrtype. Valid rrtypes are <code>&#39;A&#39;</code> (IPV4 addresses, default),\\n<code>&#39;AAAA&#39;</code> (IPV6 addresses), <code>&#39;MX&#39;</code> (mail exchange records), <code>&#39;TXT&#39;</code> (text\\nrecords), <code>&#39;SRV&#39;</code> (SRV records), <code>&#39;PTR&#39;</code> (used for reverse IP lookups),\\n<code>&#39;NS&#39;</code> (name server records) and <code>&#39;CNAME&#39;</code> (canonical name records).\\n\\n</p>\\n<p>The callback has arguments <code>(err, addresses)</code>.  The type of each item\\nin <code>addresses</code> is determined by the record type, and described in the\\ndocumentation for the corresponding lookup methods below.\\n\\n</p>\\n<p>On error, <code>err</code> is an <code>Error</code> object, where <code>err.code</code> is\\none of the error codes listed below.\\n\\n\\n</p>\\n\",\n          \"signatures\": [\n            {\n              \"params\": [\n                {\n                  \"name\": \"domain\"\n                },\n                {\n                  \"name\": \"rrtype\",\n                  \"optional\": true\n                },\n                {\n                  \"name\": \"callback\"\n                }\n              ]\n            }\n          ]\n        },\n        {\n          \"textRaw\": \"dns.resolve4(domain, callback)\",\n          \"type\": \"method\",\n          \"name\": \"resolve4\",\n          \"desc\": \"<p>The same as <code>dns.resolve()</code>, but only for IPv4 queries (<code>A</code> records).\\n<code>addresses</code> is an array of IPv4 addresses (e.g.\\n<code>[&#39;74.125.79.104&#39;, &#39;74.125.79.105&#39;, &#39;74.125.79.106&#39;]</code>).\\n\\n</p>\\n\",\n          \"signatures\": [\n            {\n              \"params\": [\n                {\n                  \"name\": \"domain\"\n                },\n                {\n                  \"name\": \"callback\"\n                }\n              ]\n            }\n          ]\n        },\n        {\n          \"textRaw\": \"dns.resolve6(domain, callback)\",\n          \"type\": \"method\",\n          \"name\": \"resolve6\",\n          \"desc\": \"<p>The same as <code>dns.resolve4()</code> except for IPv6 queries (an <code>AAAA</code> query).\\n\\n\\n</p>\\n\",\n          \"signatures\": [\n            {\n              \"params\": [\n                {\n                  \"name\": \"domain\"\n                },\n                {\n                  \"name\": \"callback\"\n                }\n              ]\n            }\n          ]\n        },\n        {\n          \"textRaw\": \"dns.resolveMx(domain, callback)\",\n          \"type\": \"method\",\n          \"name\": \"resolveMx\",\n          \"desc\": \"<p>The same as <code>dns.resolve()</code>, but only for mail exchange queries (<code>MX</code> records).\\n\\n</p>\\n<p><code>addresses</code> is an array of MX records, each with a priority and an exchange\\nattribute (e.g. <code>[{&#39;priority&#39;: 10, &#39;exchange&#39;: &#39;mx.example.com&#39;},...]</code>).\\n\\n</p>\\n\",\n          \"signatures\": [\n            {\n              \"params\": [\n                {\n                  \"name\": \"domain\"\n                },\n                {\n                  \"name\": \"callback\"\n                }\n              ]\n            }\n          ]\n        },\n        {\n          \"textRaw\": \"dns.resolveTxt(domain, callback)\",\n          \"type\": \"method\",\n          \"name\": \"resolveTxt\",\n          \"desc\": \"<p>The same as <code>dns.resolve()</code>, but only for text queries (<code>TXT</code> records).\\n<code>addresses</code> is an array of the text records available for <code>domain</code> (e.g.,\\n<code>[&#39;v=spf1 ip4:0.0.0.0 ~all&#39;]</code>).\\n\\n</p>\\n\",\n          \"signatures\": [\n            {\n              \"params\": [\n                {\n                  \"name\": \"domain\"\n                },\n                {\n                  \"name\": \"callback\"\n                }\n              ]\n            }\n          ]\n        },\n        {\n          \"textRaw\": \"dns.resolveSrv(domain, callback)\",\n          \"type\": \"method\",\n          \"name\": \"resolveSrv\",\n          \"desc\": \"<p>The same as <code>dns.resolve()</code>, but only for service records (<code>SRV</code> records).\\n<code>addresses</code> is an array of the SRV records available for <code>domain</code>. Properties\\nof SRV records are priority, weight, port, and name (e.g.,\\n<code>[{&#39;priority&#39;: 10, {&#39;weight&#39;: 5, &#39;port&#39;: 21223, &#39;name&#39;: &#39;service.example.com&#39;}, ...]</code>).\\n\\n</p>\\n\",\n          \"signatures\": [\n            {\n              \"params\": [\n                {\n                  \"name\": \"domain\"\n                },\n                {\n                  \"name\": \"callback\"\n                }\n              ]\n            }\n          ]\n        },\n        {\n          \"textRaw\": \"dns.resolveNs(domain, callback)\",\n          \"type\": \"method\",\n          \"name\": \"resolveNs\",\n          \"desc\": \"<p>The same as <code>dns.resolve()</code>, but only for name server records (<code>NS</code> records).\\n<code>addresses</code> is an array of the name server records available for <code>domain</code>\\n(e.g., <code>[&#39;ns1.example.com&#39;, &#39;ns2.example.com&#39;]</code>).\\n\\n</p>\\n\",\n          \"signatures\": [\n            {\n              \"params\": [\n                {\n                  \"name\": \"domain\"\n                },\n                {\n                  \"name\": \"callback\"\n                }\n              ]\n            }\n          ]\n        },\n        {\n          \"textRaw\": \"dns.resolveCname(domain, callback)\",\n          \"type\": \"method\",\n          \"name\": \"resolveCname\",\n          \"desc\": \"<p>The same as <code>dns.resolve()</code>, but only for canonical name records (<code>CNAME</code>\\nrecords). <code>addresses</code> is an array of the canonical name records available for\\n<code>domain</code> (e.g., <code>[&#39;bar.example.com&#39;]</code>).\\n\\n</p>\\n\",\n          \"signatures\": [\n            {\n              \"params\": [\n                {\n                  \"name\": \"domain\"\n                },\n                {\n                  \"name\": \"callback\"\n                }\n              ]\n            }\n          ]\n        },\n        {\n          \"textRaw\": \"dns.reverse(ip, callback)\",\n          \"type\": \"method\",\n          \"name\": \"reverse\",\n          \"desc\": \"<p>Reverse resolves an ip address to an array of domain names.\\n\\n</p>\\n<p>The callback has arguments <code>(err, domains)</code>.\\n\\n</p>\\n<p>On error, <code>err</code> is an <code>Error</code> object, where <code>err.code</code> is\\none of the error codes listed below.\\n\\n</p>\\n\",\n          \"signatures\": [\n            {\n              \"params\": [\n                {\n                  \"name\": \"ip\"\n                },\n                {\n                  \"name\": \"callback\"\n                }\n              ]\n            }\n          ]\n        }\n      ],\n      \"modules\": [\n        {\n          \"textRaw\": \"Error codes\",\n          \"name\": \"error_codes\",\n          \"desc\": \"<p>Each DNS query can return one of the following error codes:\\n\\n</p>\\n<ul>\\n<li><code>dns.NODATA</code>: DNS server returned answer with no data.</li>\\n<li><code>dns.FORMERR</code>: DNS server claims query was misformatted.</li>\\n<li><code>dns.SERVFAIL</code>: DNS server returned general failure.</li>\\n<li><code>dns.NOTFOUND</code>: Domain name not found.</li>\\n<li><code>dns.NOTIMP</code>: DNS server does not implement requested operation.</li>\\n<li><code>dns.REFUSED</code>: DNS server refused query.</li>\\n<li><code>dns.BADQUERY</code>: Misformatted DNS query.</li>\\n<li><code>dns.BADNAME</code>: Misformatted domain name.</li>\\n<li><code>dns.BADFAMILY</code>: Unsupported address family.</li>\\n<li><code>dns.BADRESP</code>: Misformatted DNS reply.</li>\\n<li><code>dns.CONNREFUSED</code>: Could not contact DNS servers.</li>\\n<li><code>dns.TIMEOUT</code>: Timeout while contacting DNS servers.</li>\\n<li><code>dns.EOF</code>: End of file.</li>\\n<li><code>dns.FILE</code>: Error reading file.</li>\\n<li><code>dns.NOMEM</code>: Out of memory.</li>\\n<li><code>dns.DESTRUCTION</code>: Channel is being destroyed.</li>\\n<li><code>dns.BADSTR</code>: Misformatted string.</li>\\n<li><code>dns.BADFLAGS</code>: Illegal flags specified.</li>\\n<li><code>dns.NONAME</code>: Given hostname is not numeric.</li>\\n<li><code>dns.BADHINTS</code>: Illegal hints flags specified.</li>\\n<li><code>dns.NOTINITIALIZED</code>: c-ares library initialization not yet performed.</li>\\n<li><code>dns.LOADIPHLPAPI</code>: Error loading iphlpapi.dll.</li>\\n<li><code>dns.ADDRGETNETWORKPARAMS</code>: Could not find GetNetworkParams function.</li>\\n<li><code>dns.CANCELLED</code>: DNS query cancelled.</li>\\n</ul>\\n\",\n          \"type\": \"module\",\n          \"displayName\": \"Error codes\"\n        }\n      ],\n      \"type\": \"module\",\n      \"displayName\": \"DNS\"\n    }\n  ]\n}\n"}{"source":"http://nodejs.org/api/domain.json","title":"Domain","content":"{\n  \"source\": \"doc/api/domain.markdown\",\n  \"modules\": [\n    {\n      \"textRaw\": \"Domain\",\n      \"name\": \"domain\",\n      \"stability\": 2,\n      \"stabilityText\": \"Unstable\",\n      \"desc\": \"<p>Domains provide a way to handle multiple different IO operations as a\\nsingle group.  If any of the event emitters or callbacks registered to a\\ndomain emit an <code>error</code> event, or throw an error, then the domain object\\nwill be notified, rather than losing the context of the error in the\\n<code>process.on(&#39;uncaughtException&#39;)</code> handler, or causing the program to\\nexit immediately with an error code.\\n\\n</p>\\n\",\n      \"miscs\": [\n        {\n          \"textRaw\": \"Warning: Don't Ignore Errors!\",\n          \"name\": \"Warning: Don't Ignore Errors!\",\n          \"type\": \"misc\",\n          \"desc\": \"<p>Domain error handlers are not a substitute for closing down your\\nprocess when an error occurs.\\n\\n</p>\\n<p>By the very nature of how <code>throw</code> works in JavaScript, there is almost\\nnever any way to safely &quot;pick up where you left off&quot;, without leaking\\nreferences, or creating some other sort of undefined brittle state.\\n\\n</p>\\n<p>The safest way to respond to a thrown error is to shut down the\\nprocess.  Of course, in a normal web server, you might have many\\nconnections open, and it is not reasonable to abruptly shut those down\\nbecause an error was triggered by someone else.\\n\\n</p>\\n<p>The better approach is send an error response to the request that\\ntriggered the error, while letting the others finish in their normal\\ntime, and stop listening for new requests in that worker.\\n\\n</p>\\n<p>In this way, <code>domain</code> usage goes hand-in-hand with the cluster module,\\nsince the master process can fork a new worker when a worker\\nencounters an error.  For node programs that scale to multiple\\nmachines, the terminating proxy or service registry can take note of\\nthe failure, and react accordingly.\\n\\n</p>\\n<p>For example, this is not a good idea:\\n\\n</p>\\n<pre><code class=\\\"javascript\\\">// XXX WARNING!  BAD IDEA!\\n\\nvar d = require(&#39;domain&#39;).create();\\nd.on(&#39;error&#39;, function(er) {\\n  // The error won&#39;t crash the process, but what it does is worse!\\n  // Though we&#39;ve prevented abrupt process restarting, we are leaking\\n  // resources like crazy if this ever happens.\\n  // This is no better than process.on(&#39;uncaughtException&#39;)!\\n  console.log(&#39;error, but oh well&#39;, er.message);\\n});\\nd.run(function() {\\n  require(&#39;http&#39;).createServer(function(req, res) {\\n    handleRequest(req, res);\\n  }).listen(PORT);\\n});</code></pre>\\n<p>By using the context of a domain, and the resilience of separating our\\nprogram into multiple worker processes, we can react more\\nappropriately, and handle errors with much greater safety.\\n\\n</p>\\n<pre><code class=\\\"javascript\\\">// Much better!\\n\\nvar cluster = require(&#39;cluster&#39;);\\nvar PORT = +process.env.PORT || 1337;\\n\\nif (cluster.isMaster) {\\n  // In real life, you&#39;d probably use more than just 2 workers,\\n  // and perhaps not put the master and worker in the same file.\\n  //\\n  // You can also of course get a bit fancier about logging, and\\n  // implement whatever custom logic you need to prevent DoS\\n  // attacks and other bad behavior.\\n  //\\n  // See the options in the cluster documentation.\\n  //\\n  // The important thing is that the master does very little,\\n  // increasing our resilience to unexpected errors.\\n\\n  cluster.fork();\\n  cluster.fork();\\n\\n  cluster.on(&#39;disconnect&#39;, function(worker) {\\n    console.error(&#39;disconnect!&#39;);\\n    cluster.fork();\\n  });\\n\\n} else {\\n  // the worker\\n  //\\n  // This is where we put our bugs!\\n\\n  var domain = require(&#39;domain&#39;);\\n\\n  // See the cluster documentation for more details about using\\n  // worker processes to serve requests.  How it works, caveats, etc.\\n\\n  var server = require(&#39;http&#39;).createServer(function(req, res) {\\n    var d = domain.create();\\n    d.on(&#39;error&#39;, function(er) {\\n      console.error(&#39;error&#39;, er.stack);\\n\\n      // Note: we&#39;re in dangerous territory!\\n      // By definition, something unexpected occurred,\\n      // which we probably didn&#39;t want.\\n      // Anything can happen now!  Be very careful!\\n\\n      try {\\n        // make sure we close down within 30 seconds\\n        var killtimer = setTimeout(function() {\\n          process.exit(1);\\n        }, 30000);\\n        // But don&#39;t keep the process open just for that!\\n        killtimer.unref();\\n\\n        // stop taking new requests.\\n        server.close();\\n\\n        // Let the master know we&#39;re dead.  This will trigger a\\n        // &#39;disconnect&#39; in the cluster master, and then it will fork\\n        // a new worker.\\n        cluster.worker.disconnect();\\n\\n        // try to send an error to the request that triggered the problem\\n        res.statusCode = 500;\\n        res.setHeader(&#39;content-type&#39;, &#39;text/plain&#39;);\\n        res.end(&#39;Oops, there was a problem!\\\\n&#39;);\\n      } catch (er2) {\\n        // oh well, not much we can do at this point.\\n        console.error(&#39;Error sending 500!&#39;, er2.stack);\\n      }\\n    });\\n\\n    // Because req and res were created before this domain existed,\\n    // we need to explicitly add them.\\n    // See the explanation of implicit vs explicit binding below.\\n    d.add(req);\\n    d.add(res);\\n\\n    // Now run the handler function in the domain.\\n    d.run(function() {\\n      handleRequest(req, res);\\n    });\\n  });\\n  server.listen(PORT);\\n}\\n\\n// This part isn&#39;t important.  Just an example routing thing.\\n// You&#39;d put your fancy application logic here.\\nfunction handleRequest(req, res) {\\n  switch(req.url) {\\n    case &#39;/error&#39;:\\n      // We do some async stuff, and then...\\n      setTimeout(function() {\\n        // Whoops!\\n        flerb.bark();\\n      });\\n      break;\\n    default:\\n      res.end(&#39;ok&#39;);\\n  }\\n}</code></pre>\\n\"\n        },\n        {\n          \"textRaw\": \"Additions to Error objects\",\n          \"name\": \"Additions to Error objects\",\n          \"type\": \"misc\",\n          \"desc\": \"<p>Any time an Error object is routed through a domain, a few extra fields\\nare added to it.\\n\\n</p>\\n<ul>\\n<li><code>error.domain</code> The domain that first handled the error.</li>\\n<li><code>error.domainEmitter</code> The event emitter that emitted an &#39;error&#39; event\\nwith the error object.</li>\\n<li><code>error.domainBound</code> The callback function which was bound to the\\ndomain, and passed an error as its first argument.</li>\\n<li><code>error.domainThrown</code> A boolean indicating whether the error was\\nthrown, emitted, or passed to a bound callback function.</li>\\n</ul>\\n\"\n        },\n        {\n          \"textRaw\": \"Implicit Binding\",\n          \"name\": \"Implicit Binding\",\n          \"type\": \"misc\",\n          \"desc\": \"<p>If domains are in use, then all <strong>new</strong> EventEmitter objects (including\\nStream objects, requests, responses, etc.) will be implicitly bound to\\nthe active domain at the time of their creation.\\n\\n</p>\\n<p>Additionally, callbacks passed to lowlevel event loop requests (such as\\nto fs.open, or other callback-taking methods) will automatically be\\nbound to the active domain.  If they throw, then the domain will catch\\nthe error.\\n\\n</p>\\n<p>In order to prevent excessive memory usage, Domain objects themselves\\nare not implicitly added as children of the active domain.  If they\\nwere, then it would be too easy to prevent request and response objects\\nfrom being properly garbage collected.\\n\\n</p>\\n<p>If you <em>want</em> to nest Domain objects as children of a parent Domain,\\nthen you must explicitly add them.\\n\\n</p>\\n<p>Implicit binding routes thrown errors and <code>&#39;error&#39;</code> events to the\\nDomain&#39;s <code>error</code> event, but does not register the EventEmitter on the\\nDomain, so <code>domain.dispose()</code> will not shut down the EventEmitter.\\nImplicit binding only takes care of thrown errors and <code>&#39;error&#39;</code> events.\\n\\n</p>\\n\"\n        },\n        {\n          \"textRaw\": \"Explicit Binding\",\n          \"name\": \"Explicit Binding\",\n          \"type\": \"misc\",\n          \"desc\": \"<p>Sometimes, the domain in use is not the one that ought to be used for a\\nspecific event emitter.  Or, the event emitter could have been created\\nin the context of one domain, but ought to instead be bound to some\\nother domain.\\n\\n</p>\\n<p>For example, there could be one domain in use for an HTTP server, but\\nperhaps we would like to have a separate domain to use for each request.\\n\\n</p>\\n<p>That is possible via explicit binding.\\n\\n</p>\\n<p>For example:\\n\\n</p>\\n<pre><code>// create a top-level domain for the server\\nvar serverDomain = domain.create();\\n\\nserverDomain.run(function() {\\n  // server is created in the scope of serverDomain\\n  http.createServer(function(req, res) {\\n    // req and res are also created in the scope of serverDomain\\n    // however, we&#39;d prefer to have a separate domain for each request.\\n    // create it first thing, and add req and res to it.\\n    var reqd = domain.create();\\n    reqd.add(req);\\n    reqd.add(res);\\n    reqd.on(&#39;error&#39;, function(er) {\\n      console.error(&#39;Error&#39;, er, req.url);\\n      try {\\n        res.writeHead(500);\\n        res.end(&#39;Error occurred, sorry.&#39;);\\n      } catch (er) {\\n        console.error(&#39;Error sending 500&#39;, er, req.url);\\n      }\\n    });\\n  }).listen(1337);\\n});</code></pre>\\n\"\n        }\n      ],\n      \"methods\": [\n        {\n          \"textRaw\": \"domain.create()\",\n          \"type\": \"method\",\n          \"name\": \"create\",\n          \"signatures\": [\n            {\n              \"return\": {\n                \"textRaw\": \"return: {Domain} \",\n                \"name\": \"return\",\n                \"type\": \"Domain\"\n              },\n              \"params\": []\n            },\n            {\n              \"params\": []\n            }\n          ],\n          \"desc\": \"<p>Returns a new Domain object.\\n\\n</p>\\n\"\n        }\n      ],\n      \"classes\": [\n        {\n          \"textRaw\": \"Class: Domain\",\n          \"type\": \"class\",\n          \"name\": \"Domain\",\n          \"desc\": \"<p>The Domain class encapsulates the functionality of routing errors and\\nuncaught exceptions to the active Domain object.\\n\\n</p>\\n<p>Domain is a child class of [EventEmitter][].  To handle the errors that it\\ncatches, listen to its <code>error</code> event.\\n\\n</p>\\n\",\n          \"methods\": [\n            {\n              \"textRaw\": \"domain.run(fn)\",\n              \"type\": \"method\",\n              \"name\": \"run\",\n              \"signatures\": [\n                {\n                  \"params\": [\n                    {\n                      \"textRaw\": \"`fn` {Function} \",\n                      \"name\": \"fn\",\n                      \"type\": \"Function\"\n                    }\n                  ]\n                },\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"fn\"\n                    }\n                  ]\n                }\n              ],\n              \"desc\": \"<p>Run the supplied function in the context of the domain, implicitly\\nbinding all event emitters, timers, and lowlevel requests that are\\ncreated in that context.\\n\\n</p>\\n<p>This is the most basic way to use a domain.\\n\\n</p>\\n<p>Example:\\n\\n</p>\\n<pre><code>var d = domain.create();\\nd.on(&#39;error&#39;, function(er) {\\n  console.error(&#39;Caught error!&#39;, er);\\n});\\nd.run(function() {\\n  process.nextTick(function() {\\n    setTimeout(function() { // simulating some various async stuff\\n      fs.open(&#39;non-existent file&#39;, &#39;r&#39;, function(er, fd) {\\n        if (er) throw er;\\n        // proceed...\\n      });\\n    }, 100);\\n  });\\n});</code></pre>\\n<p>In this example, the <code>d.on(&#39;error&#39;)</code> handler will be triggered, rather\\nthan crashing the program.\\n\\n</p>\\n\"\n            },\n            {\n              \"textRaw\": \"domain.add(emitter)\",\n              \"type\": \"method\",\n              \"name\": \"add\",\n              \"signatures\": [\n                {\n                  \"params\": [\n                    {\n                      \"textRaw\": \"`emitter` {EventEmitter | Timer} emitter or timer to be added to the domain \",\n                      \"name\": \"emitter\",\n                      \"type\": \"EventEmitter | Timer\",\n                      \"desc\": \"emitter or timer to be added to the domain\"\n                    }\n                  ]\n                },\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"emitter\"\n                    }\n                  ]\n                }\n              ],\n              \"desc\": \"<p>Explicitly adds an emitter to the domain.  If any event handlers called by\\nthe emitter throw an error, or if the emitter emits an <code>error</code> event, it\\nwill be routed to the domain&#39;s <code>error</code> event, just like with implicit\\nbinding.\\n\\n</p>\\n<p>This also works with timers that are returned from <code>setInterval</code> and\\n<code>setTimeout</code>.  If their callback function throws, it will be caught by\\nthe domain &#39;error&#39; handler.\\n\\n</p>\\n<p>If the Timer or EventEmitter was already bound to a domain, it is removed\\nfrom that one, and bound to this one instead.\\n\\n</p>\\n\"\n            },\n            {\n              \"textRaw\": \"domain.remove(emitter)\",\n              \"type\": \"method\",\n              \"name\": \"remove\",\n              \"signatures\": [\n                {\n                  \"params\": [\n                    {\n                      \"textRaw\": \"`emitter` {EventEmitter | Timer} emitter or timer to be removed from the domain \",\n                      \"name\": \"emitter\",\n                      \"type\": \"EventEmitter | Timer\",\n                      \"desc\": \"emitter or timer to be removed from the domain\"\n                    }\n                  ]\n                },\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"emitter\"\n                    }\n                  ]\n                }\n              ],\n              \"desc\": \"<p>The opposite of <code>domain.add(emitter)</code>.  Removes domain handling from the\\nspecified emitter.\\n\\n</p>\\n\"\n            },\n            {\n              \"textRaw\": \"domain.bind(callback)\",\n              \"type\": \"method\",\n              \"name\": \"bind\",\n              \"signatures\": [\n                {\n                  \"return\": {\n                    \"textRaw\": \"return: {Function} The bound function \",\n                    \"name\": \"return\",\n                    \"type\": \"Function\",\n                    \"desc\": \"The bound function\"\n                  },\n                  \"params\": [\n                    {\n                      \"textRaw\": \"`callback` {Function} The callback function \",\n                      \"name\": \"callback\",\n                      \"type\": \"Function\",\n                      \"desc\": \"The callback function\"\n                    }\n                  ]\n                },\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"callback\"\n                    }\n                  ]\n                }\n              ],\n              \"desc\": \"<p>The returned function will be a wrapper around the supplied callback\\nfunction.  When the returned function is called, any errors that are\\nthrown will be routed to the domain&#39;s <code>error</code> event.\\n\\n</p>\\n<h4>Example</h4>\\n<pre><code>var d = domain.create();\\n\\nfunction readSomeFile(filename, cb) {\\n  fs.readFile(filename, &#39;utf8&#39;, d.bind(function(er, data) {\\n    // if this throws, it will also be passed to the domain\\n    return cb(er, data ? JSON.parse(data) : null);\\n  }));\\n}\\n\\nd.on(&#39;error&#39;, function(er) {\\n  // an error occurred somewhere.\\n  // if we throw it now, it will crash the program\\n  // with the normal line number and stack message.\\n});</code></pre>\\n\"\n            },\n            {\n              \"textRaw\": \"domain.intercept(callback)\",\n              \"type\": \"method\",\n              \"name\": \"intercept\",\n              \"signatures\": [\n                {\n                  \"return\": {\n                    \"textRaw\": \"return: {Function} The intercepted function \",\n                    \"name\": \"return\",\n                    \"type\": \"Function\",\n                    \"desc\": \"The intercepted function\"\n                  },\n                  \"params\": [\n                    {\n                      \"textRaw\": \"`callback` {Function} The callback function \",\n                      \"name\": \"callback\",\n                      \"type\": \"Function\",\n                      \"desc\": \"The callback function\"\n                    }\n                  ]\n                },\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"callback\"\n                    }\n                  ]\n                }\n              ],\n              \"desc\": \"<p>This method is almost identical to <code>domain.bind(callback)</code>.  However, in\\naddition to catching thrown errors, it will also intercept <code>Error</code>\\nobjects sent as the first argument to the function.\\n\\n</p>\\n<p>In this way, the common <code>if (er) return callback(er);</code> pattern can be replaced\\nwith a single error handler in a single place.\\n\\n</p>\\n<h4>Example</h4>\\n<pre><code>var d = domain.create();\\n\\nfunction readSomeFile(filename, cb) {\\n  fs.readFile(filename, &#39;utf8&#39;, d.intercept(function(data) {\\n    // note, the first argument is never passed to the\\n    // callback since it is assumed to be the &#39;Error&#39; argument\\n    // and thus intercepted by the domain.\\n\\n    // if this throws, it will also be passed to the domain\\n    // so the error-handling logic can be moved to the &#39;error&#39;\\n    // event on the domain instead of being repeated throughout\\n    // the program.\\n    return cb(null, JSON.parse(data));\\n  }));\\n}\\n\\nd.on(&#39;error&#39;, function(er) {\\n  // an error occurred somewhere.\\n  // if we throw it now, it will crash the program\\n  // with the normal line number and stack message.\\n});</code></pre>\\n\"\n            },\n            {\n              \"textRaw\": \"domain.enter()\",\n              \"type\": \"method\",\n              \"name\": \"enter\",\n              \"desc\": \"<p>The <code>enter</code> method is plumbing used by the <code>run</code>, <code>bind</code>, and <code>intercept</code>\\nmethods to set the active domain. It sets <code>domain.active</code> and <code>process.domain</code>\\nto the domain, and implicitly pushes the domain onto the domain stack managed\\nby the domain module (see <code>domain.exit()</code> for details on the domain stack). The\\ncall to <code>enter</code> delimits the beginning of a chain of asynchronous calls and I/O\\noperations bound to a domain.\\n\\n</p>\\n<p>Calling <code>enter</code> changes only the active domain, and does not alter the domain\\nitself. <code>Enter</code> and <code>exit</code> can be called an arbitrary number of times on a\\nsingle domain.\\n\\n</p>\\n<p>If the domain on which <code>enter</code> is called has been disposed, <code>enter</code> will return\\nwithout setting the domain.\\n\\n</p>\\n\",\n              \"signatures\": [\n                {\n                  \"params\": []\n                }\n              ]\n            },\n            {\n              \"textRaw\": \"domain.exit()\",\n              \"type\": \"method\",\n              \"name\": \"exit\",\n              \"desc\": \"<p>The <code>exit</code> method exits the current domain, popping it off the domain stack.\\nAny time execution is going to switch to the context of a different chain of\\nasynchronous calls, it&#39;s important to ensure that the current domain is exited.\\nThe call to <code>exit</code> delimits either the end of or an interruption to the chain\\nof asynchronous calls and I/O operations bound to a domain.\\n\\n</p>\\n<p>If there are multiple, nested domains bound to the current execution context,\\n<code>exit</code> will exit any domains nested within this domain.\\n\\n</p>\\n<p>Calling <code>exit</code> changes only the active domain, and does not alter the domain\\nitself. <code>Enter</code> and <code>exit</code> can be called an arbitrary number of times on a\\nsingle domain.\\n\\n</p>\\n<p>If the domain on which <code>exit</code> is called has been disposed, <code>exit</code> will return\\nwithout exiting the domain.\\n\\n</p>\\n\",\n              \"signatures\": [\n                {\n                  \"params\": []\n                }\n              ]\n            },\n            {\n              \"textRaw\": \"domain.dispose()\",\n              \"type\": \"method\",\n              \"name\": \"dispose\",\n              \"desc\": \"<p>The dispose method destroys a domain, and makes a best effort attempt to\\nclean up any and all IO that is associated with the domain.  Streams are\\naborted, ended, closed, and/or destroyed.  Timers are cleared.\\nExplicitly bound callbacks are no longer called.  Any error events that\\nare raised as a result of this are ignored.\\n\\n</p>\\n<p>The intention of calling <code>dispose</code> is generally to prevent cascading\\nerrors when a critical part of the Domain context is found to be in an\\nerror state.\\n\\n</p>\\n<p>Once the domain is disposed the <code>dispose</code> event will emit.\\n\\n</p>\\n<p>Note that IO might still be performed.  However, to the highest degree\\npossible, once a domain is disposed, further errors from the emitters in\\nthat set will be ignored.  So, even if some remaining actions are still\\nin flight, Node.js will not communicate further about them.\\n\\n</p>\\n\",\n              \"signatures\": [\n                {\n                  \"params\": []\n                }\n              ]\n            }\n          ],\n          \"properties\": [\n            {\n              \"textRaw\": \"`members` {Array} \",\n              \"name\": \"members\",\n              \"desc\": \"<p>An array of timers and event emitters that have been explicitly added\\nto the domain.\\n\\n</p>\\n\"\n            }\n          ]\n        }\n      ],\n      \"type\": \"module\",\n      \"displayName\": \"Domain\"\n    }\n  ]\n}\n"}{"source":"http://nodejs.org/api/https.json","title":"HTTPS","content":"{\n  \"source\": \"doc/api/https.markdown\",\n  \"modules\": [\n    {\n      \"textRaw\": \"HTTPS\",\n      \"name\": \"https\",\n      \"stability\": 3,\n      \"stabilityText\": \"Stable\",\n      \"desc\": \"<p>HTTPS is the HTTP protocol over TLS/SSL. In Node this is implemented as a\\nseparate module.\\n\\n</p>\\n\",\n      \"classes\": [\n        {\n          \"textRaw\": \"Class: https.Server\",\n          \"type\": \"class\",\n          \"name\": \"https.Server\",\n          \"desc\": \"<p>This class is a subclass of <code>tls.Server</code> and emits events same as\\n<code>http.Server</code>. See <code>http.Server</code> for more information.\\n\\n</p>\\n\"\n        },\n        {\n          \"textRaw\": \"Class: https.Agent\",\n          \"type\": \"class\",\n          \"name\": \"https.Agent\",\n          \"desc\": \"<p>An Agent object for HTTPS similar to [http.Agent][].  See [https.request()][]\\nfor more information.\\n\\n\\n</p>\\n\"\n        }\n      ],\n      \"methods\": [\n        {\n          \"textRaw\": \"https.createServer(options, [requestListener])\",\n          \"type\": \"method\",\n          \"name\": \"createServer\",\n          \"desc\": \"<p>Returns a new HTTPS web server object. The <code>options</code> is similar to\\n[tls.createServer()][].  The <code>requestListener</code> is a function which is\\nautomatically added to the <code>&#39;request&#39;</code> event.\\n\\n</p>\\n<p>Example:\\n\\n</p>\\n<pre><code>// curl -k https://localhost:8000/\\nvar https = require(&#39;https&#39;);\\nvar fs = require(&#39;fs&#39;);\\n\\nvar options = {\\n  key: fs.readFileSync(&#39;test/fixtures/keys/agent2-key.pem&#39;),\\n  cert: fs.readFileSync(&#39;test/fixtures/keys/agent2-cert.pem&#39;)\\n};\\n\\nhttps.createServer(options, function (req, res) {\\n  res.writeHead(200);\\n  res.end(&quot;hello world\\\\n&quot;);\\n}).listen(8000);</code></pre>\\n<p>Or\\n\\n</p>\\n<pre><code>var https = require(&#39;https&#39;);\\nvar fs = require(&#39;fs&#39;);\\n\\nvar options = {\\n  pfx: fs.readFileSync(&#39;server.pfx&#39;)\\n};\\n\\nhttps.createServer(options, function (req, res) {\\n  res.writeHead(200);\\n  res.end(&quot;hello world\\\\n&quot;);\\n}).listen(8000);</code></pre>\\n\",\n          \"methods\": [\n            {\n              \"textRaw\": \"server.listen(path, [callback])\",\n              \"type\": \"method\",\n              \"name\": \"listen\",\n              \"desc\": \"<p>See [http.listen()][] for details.\\n\\n</p>\\n\",\n              \"signatures\": [\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"handle\"\n                    },\n                    {\n                      \"name\": \"callback\",\n                      \"optional\": true\n                    }\n                  ]\n                },\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"path\"\n                    },\n                    {\n                      \"name\": \"callback\",\n                      \"optional\": true\n                    }\n                  ]\n                }\n              ]\n            },\n            {\n              \"textRaw\": \"server.listen(handle, [callback])\",\n              \"type\": \"method\",\n              \"name\": \"listen\",\n              \"desc\": \"<p>See [http.listen()][] for details.\\n\\n</p>\\n\",\n              \"signatures\": [\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"handle\"\n                    },\n                    {\n                      \"name\": \"callback\",\n                      \"optional\": true\n                    }\n                  ]\n                }\n              ]\n            },\n            {\n              \"textRaw\": \"server.close([callback])\",\n              \"type\": \"method\",\n              \"name\": \"close\",\n              \"desc\": \"<p>See [http.close()][] for details.\\n\\n</p>\\n\",\n              \"signatures\": [\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"callback\",\n                      \"optional\": true\n                    }\n                  ]\n                }\n              ]\n            }\n          ],\n          \"signatures\": [\n            {\n              \"params\": [\n                {\n                  \"name\": \"options\"\n                },\n                {\n                  \"name\": \"requestListener\",\n                  \"optional\": true\n                }\n              ]\n            }\n          ]\n        },\n        {\n          \"textRaw\": \"https.request(options, callback)\",\n          \"type\": \"method\",\n          \"name\": \"request\",\n          \"desc\": \"<p>Makes a request to a secure web server.\\n\\n</p>\\n<p><code>options</code> can be an object or a string. If <code>options</code> is a string, it is\\nautomatically parsed with <a href=\\\"url.html#url.parse\\\">url.parse()</a>.\\n\\n</p>\\n<p>All options from [http.request()][] are valid.\\n\\n</p>\\n<p>Example:\\n\\n</p>\\n<pre><code>var https = require(&#39;https&#39;);\\n\\nvar options = {\\n  hostname: &#39;encrypted.google.com&#39;,\\n  port: 443,\\n  path: &#39;/&#39;,\\n  method: &#39;GET&#39;\\n};\\n\\nvar req = https.request(options, function(res) {\\n  console.log(&quot;statusCode: &quot;, res.statusCode);\\n  console.log(&quot;headers: &quot;, res.headers);\\n\\n  res.on(&#39;data&#39;, function(d) {\\n    process.stdout.write(d);\\n  });\\n});\\nreq.end();\\n\\nreq.on(&#39;error&#39;, function(e) {\\n  console.error(e);\\n});</code></pre>\\n<p>The options argument has the following options\\n\\n</p>\\n<ul>\\n<li><code>host</code>: A domain name or IP address of the server to issue the request to.\\nDefaults to <code>&#39;localhost&#39;</code>.</li>\\n<li><code>hostname</code>: To support <code>url.parse()</code> <code>hostname</code> is preferred over <code>host</code></li>\\n<li><code>port</code>: Port of remote server. Defaults to 443.</li>\\n<li><code>method</code>: A string specifying the HTTP request method. Defaults to <code>&#39;GET&#39;</code>.</li>\\n<li><code>path</code>: Request path. Defaults to <code>&#39;/&#39;</code>. Should include query string if any.\\nE.G. <code>&#39;/index.html?page=12&#39;</code></li>\\n<li><code>headers</code>: An object containing request headers.</li>\\n<li><code>auth</code>: Basic authentication i.e. <code>&#39;user:password&#39;</code> to compute an\\nAuthorization header.</li>\\n<li><code>agent</code>: Controls [Agent][] behavior. When an Agent is used request will\\ndefault to <code>Connection: keep-alive</code>. Possible values:<ul>\\n<li><code>undefined</code> (default): use [globalAgent][] for this host and port.</li>\\n<li><code>Agent</code> object: explicitly use the passed in <code>Agent</code>.</li>\\n<li><code>false</code>: opts out of connection pooling with an Agent, defaults request to\\n<code>Connection: close</code>.</li>\\n</ul>\\n</li>\\n</ul>\\n<p>The following options from [tls.connect()][] can also be specified. However, a\\n[globalAgent][] silently ignores these.\\n\\n</p>\\n<ul>\\n<li><code>pfx</code>: Certificate, Private key and CA certificates to use for SSL. Default <code>null</code>.</li>\\n<li><code>key</code>: Private key to use for SSL. Default <code>null</code>.</li>\\n<li><code>passphrase</code>: A string of passphrase for the private key or pfx. Default <code>null</code>.</li>\\n<li><code>cert</code>: Public x509 certificate to use. Default <code>null</code>.</li>\\n<li><code>ca</code>: An authority certificate or array of authority certificates to check\\nthe remote host against.</li>\\n<li><code>ciphers</code>: A string describing the ciphers to use or exclude. Consult\\n<a href=\\\"http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT\\\">http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT</a> for\\ndetails on the format.</li>\\n<li><code>rejectUnauthorized</code>: If <code>true</code>, the server certificate is verified against\\nthe list of supplied CAs. An <code>&#39;error&#39;</code> event is emitted if verification\\nfails. Verification happens at the connection level, <em>before</em> the HTTP\\nrequest is sent. Default <code>true</code>.</li>\\n<li><code>secureProtocol</code>: The SSL method to use, e.g. <code>SSLv3_method</code> to force\\nSSL version 3. The possible values depend on your installation of\\nOpenSSL and are defined in the constant [SSL_METHODS][].</li>\\n</ul>\\n<p>In order to specify these options, use a custom <code>Agent</code>.\\n\\n</p>\\n<p>Example:\\n\\n</p>\\n<pre><code>var options = {\\n  hostname: &#39;encrypted.google.com&#39;,\\n  port: 443,\\n  path: &#39;/&#39;,\\n  method: &#39;GET&#39;,\\n  key: fs.readFileSync(&#39;test/fixtures/keys/agent2-key.pem&#39;),\\n  cert: fs.readFileSync(&#39;test/fixtures/keys/agent2-cert.pem&#39;)\\n};\\noptions.agent = new https.Agent(options);\\n\\nvar req = https.request(options, function(res) {\\n  ...\\n}</code></pre>\\n<p>Or does not use an <code>Agent</code>.\\n\\n</p>\\n<p>Example:\\n\\n</p>\\n<pre><code>var options = {\\n  hostname: &#39;encrypted.google.com&#39;,\\n  port: 443,\\n  path: &#39;/&#39;,\\n  method: &#39;GET&#39;,\\n  key: fs.readFileSync(&#39;test/fixtures/keys/agent2-key.pem&#39;),\\n  cert: fs.readFileSync(&#39;test/fixtures/keys/agent2-cert.pem&#39;),\\n  agent: false\\n};\\n\\nvar req = https.request(options, function(res) {\\n  ...\\n}</code></pre>\\n\",\n          \"signatures\": [\n            {\n              \"params\": [\n                {\n                  \"name\": \"options\"\n                },\n                {\n                  \"name\": \"callback\"\n                }\n              ]\n            }\n          ]\n        },\n        {\n          \"textRaw\": \"https.get(options, callback)\",\n          \"type\": \"method\",\n          \"name\": \"get\",\n          \"desc\": \"<p>Like <code>http.get()</code> but for HTTPS.\\n\\n</p>\\n<p><code>options</code> can be an object or a string. If <code>options</code> is a string, it is\\nautomatically parsed with <a href=\\\"url.html#url.parse\\\">url.parse()</a>.\\n\\n</p>\\n<p>Example:\\n\\n</p>\\n<pre><code>var https = require(&#39;https&#39;);\\n\\nhttps.get(&#39;https://encrypted.google.com/&#39;, function(res) {\\n  console.log(&quot;statusCode: &quot;, res.statusCode);\\n  console.log(&quot;headers: &quot;, res.headers);\\n\\n  res.on(&#39;data&#39;, function(d) {\\n    process.stdout.write(d);\\n  });\\n\\n}).on(&#39;error&#39;, function(e) {\\n  console.error(e);\\n});</code></pre>\\n\",\n          \"signatures\": [\n            {\n              \"params\": [\n                {\n                  \"name\": \"options\"\n                },\n                {\n                  \"name\": \"callback\"\n                }\n              ]\n            }\n          ]\n        }\n      ],\n      \"properties\": [\n        {\n          \"textRaw\": \"https.globalAgent\",\n          \"name\": \"globalAgent\",\n          \"desc\": \"<p>Global instance of [https.Agent][] for all HTTPS client requests.\\n\\n</p>\\n\"\n        }\n      ],\n      \"type\": \"module\",\n      \"displayName\": \"HTTPS\"\n    }\n  ]\n}\n"}{"source":"http://nodejs.org/api/buffer.json","title":"Buffer","content":"{\n  \"source\": \"doc/api/buffer.markdown\",\n  \"modules\": [\n    {\n      \"textRaw\": \"Buffer\",\n      \"name\": \"buffer\",\n      \"stability\": 3,\n      \"stabilityText\": \"Stable\",\n      \"desc\": \"<p>Pure JavaScript is Unicode friendly but not nice to binary data.  When\\ndealing with TCP streams or the file system, it&#39;s necessary to handle octet\\nstreams. Node has several strategies for manipulating, creating, and\\nconsuming octet streams.\\n\\n</p>\\n<p>Raw data is stored in instances of the <code>Buffer</code> class. A <code>Buffer</code> is similar\\nto an array of integers but corresponds to a raw memory allocation outside\\nthe V8 heap. A <code>Buffer</code> cannot be resized.\\n\\n</p>\\n<p>The <code>Buffer</code> class is a global, making it very rare that one would need\\nto ever <code>require(&#39;buffer&#39;)</code>.\\n\\n</p>\\n<p>Converting between Buffers and JavaScript string objects requires an explicit\\nencoding method.  Here are the different string encodings.\\n\\n</p>\\n<ul>\\n<li><p><code>&#39;ascii&#39;</code> - for 7 bit ASCII data only.  This encoding method is very fast, and\\nwill strip the high bit if set.</p>\\n<p>Note that when converting from string to buffer, this encoding converts a null\\ncharacter (<code>&#39;\\\\0&#39;</code> or <code>&#39;\\\\u0000&#39;</code>) into <code>0x20</code> (character code of a space). If\\nyou want to convert a null character into <code>0x00</code>, you should use <code>&#39;utf8&#39;</code>.</p>\\n</li>\\n<li><p><code>&#39;utf8&#39;</code> - Multibyte encoded Unicode characters. Many web pages and other\\ndocument formats use UTF-8.</p>\\n</li>\\n<li><p><code>&#39;utf16le&#39;</code> - 2 or 4 bytes, little endian encoded Unicode characters.\\nSurrogate pairs (U+10000 to U+10FFFF) are supported.</p>\\n</li>\\n<li><p><code>&#39;ucs2&#39;</code> - Alias of <code>&#39;utf16le&#39;</code>.</p>\\n</li>\\n<li><p><code>&#39;base64&#39;</code> - Base64 string encoding.</p>\\n</li>\\n<li><p><code>&#39;binary&#39;</code> - A way of encoding raw binary data into strings by using only\\nthe first 8 bits of each character. This encoding method is deprecated and\\nshould be avoided in favor of <code>Buffer</code> objects where possible. This encoding\\nwill be removed in future versions of Node.</p>\\n</li>\\n<li><p><code>&#39;hex&#39;</code> - Encode each byte as two hexadecimal characters.</p>\\n</li>\\n</ul>\\n<p>A <code>Buffer</code> object can also be used with typed arrays.  The buffer object is\\ncloned to an <code>ArrayBuffer</code> that is used as the backing store for the typed\\narray.  The memory of the buffer and the <code>ArrayBuffer</code> is not shared.\\n\\n</p>\\n<p>NOTE: Node.js v0.8 simply retained a reference to the buffer in <code>array.buffer</code>\\ninstead of cloning it.\\n\\n</p>\\n<p>While more efficient, it introduces subtle incompatibilities with the typed\\narrays specification.  <code>ArrayBuffer#slice()</code> makes a copy of the slice while\\n<code>Buffer#slice()</code> creates a view.\\n\\n</p>\\n\",\n      \"classes\": [\n        {\n          \"textRaw\": \"Class: Buffer\",\n          \"type\": \"class\",\n          \"name\": \"Buffer\",\n          \"desc\": \"<p>The Buffer class is a global type for dealing with binary data directly.\\nIt can be constructed in a variety of ways.\\n\\n</p>\\n\",\n          \"classMethods\": [\n            {\n              \"textRaw\": \"Class Method: Buffer.isEncoding(encoding)\",\n              \"type\": \"classMethod\",\n              \"name\": \"isEncoding\",\n              \"signatures\": [\n                {\n                  \"params\": [\n                    {\n                      \"textRaw\": \"`encoding` {String} The encoding string to test \",\n                      \"name\": \"encoding\",\n                      \"type\": \"String\",\n                      \"desc\": \"The encoding string to test\"\n                    }\n                  ]\n                },\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"encoding\"\n                    }\n                  ]\n                }\n              ],\n              \"desc\": \"<p>Returns true if the <code>encoding</code> is a valid encoding argument, or false\\notherwise.\\n\\n</p>\\n\"\n            },\n            {\n              \"textRaw\": \"Class Method: Buffer.isBuffer(obj)\",\n              \"type\": \"classMethod\",\n              \"name\": \"isBuffer\",\n              \"signatures\": [\n                {\n                  \"return\": {\n                    \"textRaw\": \"Return: Boolean \",\n                    \"name\": \"return\",\n                    \"desc\": \"Boolean\"\n                  },\n                  \"params\": [\n                    {\n                      \"textRaw\": \"`obj` Object \",\n                      \"name\": \"obj\",\n                      \"desc\": \"Object\"\n                    }\n                  ]\n                },\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"obj\"\n                    }\n                  ]\n                }\n              ],\n              \"desc\": \"<p>Tests if <code>obj</code> is a <code>Buffer</code>.\\n\\n</p>\\n\"\n            },\n            {\n              \"textRaw\": \"Class Method: Buffer.byteLength(string, [encoding])\",\n              \"type\": \"classMethod\",\n              \"name\": \"byteLength\",\n              \"signatures\": [\n                {\n                  \"return\": {\n                    \"textRaw\": \"Return: Number \",\n                    \"name\": \"return\",\n                    \"desc\": \"Number\"\n                  },\n                  \"params\": [\n                    {\n                      \"textRaw\": \"`string` String \",\n                      \"name\": \"string\",\n                      \"desc\": \"String\"\n                    },\n                    {\n                      \"textRaw\": \"`encoding` String, Optional, Default: 'utf8' \",\n                      \"name\": \"encoding\",\n                      \"desc\": \"String, Optional, Default: 'utf8'\",\n                      \"optional\": true\n                    }\n                  ]\n                },\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"string\"\n                    },\n                    {\n                      \"name\": \"encoding\",\n                      \"optional\": true\n                    }\n                  ]\n                }\n              ],\n              \"desc\": \"<p>Gives the actual byte length of a string. <code>encoding</code> defaults to <code>&#39;utf8&#39;</code>.\\nThis is not the same as <code>String.prototype.length</code> since that returns the\\nnumber of <em>characters</em> in a string.\\n\\n</p>\\n<p>Example:\\n\\n</p>\\n<pre><code>str = &#39;\\\\u00bd + \\\\u00bc = \\\\u00be&#39;;\\n\\nconsole.log(str + &quot;: &quot; + str.length + &quot; characters, &quot; +\\n  Buffer.byteLength(str, &#39;utf8&#39;) + &quot; bytes&quot;);\\n\\n// ½ + ¼ = ¾: 9 characters, 12 bytes</code></pre>\\n\"\n            },\n            {\n              \"textRaw\": \"Class Method: Buffer.concat(list, [totalLength])\",\n              \"type\": \"classMethod\",\n              \"name\": \"concat\",\n              \"signatures\": [\n                {\n                  \"params\": [\n                    {\n                      \"textRaw\": \"`list` {Array} List of Buffer objects to concat \",\n                      \"name\": \"list\",\n                      \"type\": \"Array\",\n                      \"desc\": \"List of Buffer objects to concat\"\n                    },\n                    {\n                      \"textRaw\": \"`totalLength` {Number} Total length of the buffers when concatenated \",\n                      \"name\": \"totalLength\",\n                      \"type\": \"Number\",\n                      \"desc\": \"Total length of the buffers when concatenated\",\n                      \"optional\": true\n                    }\n                  ]\n                },\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"list\"\n                    },\n                    {\n                      \"name\": \"totalLength\",\n                      \"optional\": true\n                    }\n                  ]\n                }\n              ],\n              \"desc\": \"<p>Returns a buffer which is the result of concatenating all the buffers in\\nthe list together.\\n\\n</p>\\n<p>If the list has no items, or if the totalLength is 0, then it returns a\\nzero-length buffer.\\n\\n</p>\\n<p>If the list has exactly one item, then the first item of the list is\\nreturned.\\n\\n</p>\\n<p>If the list has more than one item, then a new Buffer is created.\\n\\n</p>\\n<p>If totalLength is not provided, it is read from the buffers in the list.\\nHowever, this adds an additional loop to the function, so it is faster\\nto provide the length explicitly.\\n\\n</p>\\n\"\n            }\n          ],\n          \"methods\": [\n            {\n              \"textRaw\": \"buf.write(string, [offset], [length], [encoding])\",\n              \"type\": \"method\",\n              \"name\": \"write\",\n              \"signatures\": [\n                {\n                  \"params\": [\n                    {\n                      \"textRaw\": \"`string` String - data to be written to buffer \",\n                      \"name\": \"string\",\n                      \"desc\": \"String - data to be written to buffer\"\n                    },\n                    {\n                      \"textRaw\": \"`offset` Number, Optional, Default: 0 \",\n                      \"name\": \"offset\",\n                      \"desc\": \"Number, Optional, Default: 0\",\n                      \"optional\": true\n                    },\n                    {\n                      \"textRaw\": \"`length` Number, Optional, Default: `buffer.length - offset` \",\n                      \"name\": \"length\",\n                      \"desc\": \"Number, Optional, Default: `buffer.length - offset`\",\n                      \"optional\": true\n                    },\n                    {\n                      \"textRaw\": \"`encoding` String, Optional, Default: 'utf8' \",\n                      \"name\": \"encoding\",\n                      \"desc\": \"String, Optional, Default: 'utf8'\",\n                      \"optional\": true\n                    }\n                  ]\n                },\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"string\"\n                    },\n                    {\n                      \"name\": \"offset\",\n                      \"optional\": true\n                    },\n                    {\n                      \"name\": \"length\",\n                      \"optional\": true\n                    },\n                    {\n                      \"name\": \"encoding\",\n                      \"optional\": true\n                    }\n                  ]\n                }\n              ],\n              \"desc\": \"<p>Writes <code>string</code> to the buffer at <code>offset</code> using the given encoding.\\n<code>offset</code> defaults to <code>0</code>, <code>encoding</code> defaults to <code>&#39;utf8&#39;</code>. <code>length</code> is\\nthe number of bytes to write. Returns number of octets written. If <code>buffer</code> did\\nnot contain enough space to fit the entire string, it will write a partial\\namount of the string. <code>length</code> defaults to <code>buffer.length - offset</code>.\\nThe method will not write partial characters.\\n\\n</p>\\n<pre><code>buf = new Buffer(256);\\nlen = buf.write(&#39;\\\\u00bd + \\\\u00bc = \\\\u00be&#39;, 0);\\nconsole.log(len + &quot; bytes: &quot; + buf.toString(&#39;utf8&#39;, 0, len));</code></pre>\\n<p>The number of characters written (which may be different than the number of\\nbytes written) is set in <code>Buffer._charsWritten</code> and will be overwritten the\\nnext time <code>buf.write()</code> is called.\\n\\n\\n</p>\\n\"\n            },\n            {\n              \"textRaw\": \"buf.toString([encoding], [start], [end])\",\n              \"type\": \"method\",\n              \"name\": \"toString\",\n              \"signatures\": [\n                {\n                  \"params\": [\n                    {\n                      \"textRaw\": \"`encoding` String, Optional, Default: 'utf8' \",\n                      \"name\": \"encoding\",\n                      \"desc\": \"String, Optional, Default: 'utf8'\",\n                      \"optional\": true\n                    },\n                    {\n                      \"textRaw\": \"`start` Number, Optional, Default: 0 \",\n                      \"name\": \"start\",\n                      \"desc\": \"Number, Optional, Default: 0\",\n                      \"optional\": true\n                    },\n                    {\n                      \"textRaw\": \"`end` Number, Optional, Default: `buffer.length` \",\n                      \"name\": \"end\",\n                      \"desc\": \"Number, Optional, Default: `buffer.length`\",\n                      \"optional\": true\n                    }\n                  ]\n                },\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"encoding\",\n                      \"optional\": true\n                    },\n                    {\n                      \"name\": \"start\",\n                      \"optional\": true\n                    },\n                    {\n                      \"name\": \"end\",\n                      \"optional\": true\n                    }\n                  ]\n                }\n              ],\n              \"desc\": \"<p>Decodes and returns a string from buffer data encoded with <code>encoding</code>\\n(defaults to <code>&#39;utf8&#39;</code>) beginning at <code>start</code> (defaults to <code>0</code>) and ending at\\n<code>end</code> (defaults to <code>buffer.length</code>).\\n\\n</p>\\n<p>See <code>buffer.write()</code> example, above.\\n\\n\\n</p>\\n\"\n            },\n            {\n              \"textRaw\": \"buf.toJSON()\",\n              \"type\": \"method\",\n              \"name\": \"toJSON\",\n              \"desc\": \"<p>Returns a JSON-representation of the Buffer instance, which is identical to the\\noutput for JSON Arrays. <code>JSON.stringify</code> implicitly calls this function when\\nstringifying a Buffer instance.\\n\\n</p>\\n<p>Example:\\n\\n</p>\\n<pre><code>var buf = new Buffer(&#39;test&#39;);\\nvar json = JSON.stringify(buf);\\n\\nconsole.log(json);\\n// &#39;[116,101,115,116]&#39;\\n\\nvar copy = new Buffer(JSON.parse(json));\\n\\nconsole.log(copy);\\n// &lt;Buffer 74 65 73 74&gt;</code></pre>\\n\",\n              \"signatures\": [\n                {\n                  \"params\": []\n                }\n              ]\n            },\n            {\n              \"textRaw\": \"buf.copy(targetBuffer, [targetStart], [sourceStart], [sourceEnd])\",\n              \"type\": \"method\",\n              \"name\": \"copy\",\n              \"signatures\": [\n                {\n                  \"params\": [\n                    {\n                      \"textRaw\": \"`targetBuffer` Buffer object - Buffer to copy into \",\n                      \"name\": \"targetBuffer\",\n                      \"desc\": \"Buffer object - Buffer to copy into\"\n                    },\n                    {\n                      \"textRaw\": \"`targetStart` Number, Optional, Default: 0 \",\n                      \"name\": \"targetStart\",\n                      \"desc\": \"Number, Optional, Default: 0\",\n                      \"optional\": true\n                    },\n                    {\n                      \"textRaw\": \"`sourceStart` Number, Optional, Default: 0 \",\n                      \"name\": \"sourceStart\",\n                      \"desc\": \"Number, Optional, Default: 0\",\n                      \"optional\": true\n                    },\n                    {\n                      \"textRaw\": \"`sourceEnd` Number, Optional, Default: `buffer.length` \",\n                      \"name\": \"sourceEnd\",\n                      \"desc\": \"Number, Optional, Default: `buffer.length`\",\n                      \"optional\": true\n                    }\n                  ]\n                },\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"targetBuffer\"\n                    },\n                    {\n                      \"name\": \"targetStart\",\n                      \"optional\": true\n                    },\n                    {\n                      \"name\": \"sourceStart\",\n                      \"optional\": true\n                    },\n                    {\n                      \"name\": \"sourceEnd\",\n                      \"optional\": true\n                    }\n                  ]\n                }\n              ],\n              \"desc\": \"<p>Does copy between buffers. The source and target regions can be overlapped.\\n<code>targetStart</code> and <code>sourceStart</code> default to <code>0</code>.\\n<code>sourceEnd</code> defaults to <code>buffer.length</code>.\\n\\n</p>\\n<p>All values passed that are <code>undefined</code>/<code>NaN</code> or are out of bounds are set equal\\nto their respective defaults.\\n\\n</p>\\n<p>Example: build two Buffers, then copy <code>buf1</code> from byte 16 through byte 19\\ninto <code>buf2</code>, starting at the 8th byte in <code>buf2</code>.\\n\\n</p>\\n<pre><code>buf1 = new Buffer(26);\\nbuf2 = new Buffer(26);\\n\\nfor (var i = 0 ; i &lt; 26 ; i++) {\\n  buf1[i] = i + 97; // 97 is ASCII a\\n  buf2[i] = 33; // ASCII !\\n}\\n\\nbuf1.copy(buf2, 8, 16, 20);\\nconsole.log(buf2.toString(&#39;ascii&#39;, 0, 25));\\n\\n// !!!!!!!!qrst!!!!!!!!!!!!!</code></pre>\\n\"\n            },\n            {\n              \"textRaw\": \"buf.slice([start], [end])\",\n              \"type\": \"method\",\n              \"name\": \"slice\",\n              \"signatures\": [\n                {\n                  \"params\": [\n                    {\n                      \"textRaw\": \"`start` Number, Optional, Default: 0 \",\n                      \"name\": \"start\",\n                      \"desc\": \"Number, Optional, Default: 0\",\n                      \"optional\": true\n                    },\n                    {\n                      \"textRaw\": \"`end` Number, Optional, Default: `buffer.length` \",\n                      \"name\": \"end\",\n                      \"desc\": \"Number, Optional, Default: `buffer.length`\",\n                      \"optional\": true\n                    }\n                  ]\n                },\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"start\",\n                      \"optional\": true\n                    },\n                    {\n                      \"name\": \"end\",\n                      \"optional\": true\n                    }\n                  ]\n                }\n              ],\n              \"desc\": \"<p>Returns a new buffer which references the same memory as the old, but offset\\nand cropped by the <code>start</code> (defaults to <code>0</code>) and <code>end</code> (defaults to\\n<code>buffer.length</code>) indexes.  Negative indexes start from the end of the buffer.\\n\\n</p>\\n<p><strong>Modifying the new buffer slice will modify memory in the original buffer!</strong>\\n\\n</p>\\n<p>Example: build a Buffer with the ASCII alphabet, take a slice, then modify one\\nbyte from the original Buffer.\\n\\n</p>\\n<pre><code>var buf1 = new Buffer(26);\\n\\nfor (var i = 0 ; i &lt; 26 ; i++) {\\n  buf1[i] = i + 97; // 97 is ASCII a\\n}\\n\\nvar buf2 = buf1.slice(0, 3);\\nconsole.log(buf2.toString(&#39;ascii&#39;, 0, buf2.length));\\nbuf1[0] = 33;\\nconsole.log(buf2.toString(&#39;ascii&#39;, 0, buf2.length));\\n\\n// abc\\n// !bc</code></pre>\\n\"\n            },\n            {\n              \"textRaw\": \"buf.readUInt8(offset, [noAssert])\",\n              \"type\": \"method\",\n              \"name\": \"readUInt8\",\n              \"signatures\": [\n                {\n                  \"return\": {\n                    \"textRaw\": \"Return: Number \",\n                    \"name\": \"return\",\n                    \"desc\": \"Number\"\n                  },\n                  \"params\": [\n                    {\n                      \"textRaw\": \"`offset` Number \",\n                      \"name\": \"offset\",\n                      \"desc\": \"Number\"\n                    },\n                    {\n                      \"textRaw\": \"`noAssert` Boolean, Optional, Default: false \",\n                      \"name\": \"noAssert\",\n                      \"desc\": \"Boolean, Optional, Default: false\",\n                      \"optional\": true\n                    }\n                  ]\n                },\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"offset\"\n                    },\n                    {\n                      \"name\": \"noAssert\",\n                      \"optional\": true\n                    }\n                  ]\n                }\n              ],\n              \"desc\": \"<p>Reads an unsigned 8 bit integer from the buffer at the specified offset.\\n\\n</p>\\n<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>\\nmay be beyond the end of the buffer. Defaults to <code>false</code>.\\n\\n</p>\\n<p>Example:\\n\\n</p>\\n<pre><code>var buf = new Buffer(4);\\n\\nbuf[0] = 0x3;\\nbuf[1] = 0x4;\\nbuf[2] = 0x23;\\nbuf[3] = 0x42;\\n\\nfor (ii = 0; ii &lt; buf.length; ii++) {\\n  console.log(buf.readUInt8(ii));\\n}\\n\\n// 0x3\\n// 0x4\\n// 0x23\\n// 0x42</code></pre>\\n\"\n            },\n            {\n              \"textRaw\": \"buf.readUInt16LE(offset, [noAssert])\",\n              \"type\": \"method\",\n              \"name\": \"readUInt16LE\",\n              \"signatures\": [\n                {\n                  \"return\": {\n                    \"textRaw\": \"Return: Number \",\n                    \"name\": \"return\",\n                    \"desc\": \"Number\"\n                  },\n                  \"params\": [\n                    {\n                      \"textRaw\": \"`offset` Number \",\n                      \"name\": \"offset\",\n                      \"desc\": \"Number\"\n                    },\n                    {\n                      \"textRaw\": \"`noAssert` Boolean, Optional, Default: false \",\n                      \"name\": \"noAssert\",\n                      \"desc\": \"Boolean, Optional, Default: false\",\n                      \"optional\": true\n                    }\n                  ]\n                },\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"offset\"\n                    },\n                    {\n                      \"name\": \"noAssert\",\n                      \"optional\": true\n                    }\n                  ]\n                },\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"offset\"\n                    },\n                    {\n                      \"name\": \"noAssert\",\n                      \"optional\": true\n                    }\n                  ]\n                }\n              ],\n              \"desc\": \"<p>Reads an unsigned 16 bit integer from the buffer at the specified offset with\\nspecified endian format.\\n\\n</p>\\n<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>\\nmay be beyond the end of the buffer. Defaults to <code>false</code>.\\n\\n</p>\\n<p>Example:\\n\\n</p>\\n<pre><code>var buf = new Buffer(4);\\n\\nbuf[0] = 0x3;\\nbuf[1] = 0x4;\\nbuf[2] = 0x23;\\nbuf[3] = 0x42;\\n\\nconsole.log(buf.readUInt16BE(0));\\nconsole.log(buf.readUInt16LE(0));\\nconsole.log(buf.readUInt16BE(1));\\nconsole.log(buf.readUInt16LE(1));\\nconsole.log(buf.readUInt16BE(2));\\nconsole.log(buf.readUInt16LE(2));\\n\\n// 0x0304\\n// 0x0403\\n// 0x0423\\n// 0x2304\\n// 0x2342\\n// 0x4223</code></pre>\\n\"\n            },\n            {\n              \"textRaw\": \"buf.readUInt16BE(offset, [noAssert])\",\n              \"type\": \"method\",\n              \"name\": \"readUInt16BE\",\n              \"signatures\": [\n                {\n                  \"return\": {\n                    \"textRaw\": \"Return: Number \",\n                    \"name\": \"return\",\n                    \"desc\": \"Number\"\n                  },\n                  \"params\": [\n                    {\n                      \"textRaw\": \"`offset` Number \",\n                      \"name\": \"offset\",\n                      \"desc\": \"Number\"\n                    },\n                    {\n                      \"textRaw\": \"`noAssert` Boolean, Optional, Default: false \",\n                      \"name\": \"noAssert\",\n                      \"desc\": \"Boolean, Optional, Default: false\",\n                      \"optional\": true\n                    }\n                  ]\n                },\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"offset\"\n                    },\n                    {\n                      \"name\": \"noAssert\",\n                      \"optional\": true\n                    }\n                  ]\n                }\n              ],\n              \"desc\": \"<p>Reads an unsigned 16 bit integer from the buffer at the specified offset with\\nspecified endian format.\\n\\n</p>\\n<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>\\nmay be beyond the end of the buffer. Defaults to <code>false</code>.\\n\\n</p>\\n<p>Example:\\n\\n</p>\\n<pre><code>var buf = new Buffer(4);\\n\\nbuf[0] = 0x3;\\nbuf[1] = 0x4;\\nbuf[2] = 0x23;\\nbuf[3] = 0x42;\\n\\nconsole.log(buf.readUInt16BE(0));\\nconsole.log(buf.readUInt16LE(0));\\nconsole.log(buf.readUInt16BE(1));\\nconsole.log(buf.readUInt16LE(1));\\nconsole.log(buf.readUInt16BE(2));\\nconsole.log(buf.readUInt16LE(2));\\n\\n// 0x0304\\n// 0x0403\\n// 0x0423\\n// 0x2304\\n// 0x2342\\n// 0x4223</code></pre>\\n\"\n            },\n            {\n              \"textRaw\": \"buf.readUInt32LE(offset, [noAssert])\",\n              \"type\": \"method\",\n              \"name\": \"readUInt32LE\",\n              \"signatures\": [\n                {\n                  \"return\": {\n                    \"textRaw\": \"Return: Number \",\n                    \"name\": \"return\",\n                    \"desc\": \"Number\"\n                  },\n                  \"params\": [\n                    {\n                      \"textRaw\": \"`offset` Number \",\n                      \"name\": \"offset\",\n                      \"desc\": \"Number\"\n                    },\n                    {\n                      \"textRaw\": \"`noAssert` Boolean, Optional, Default: false \",\n                      \"name\": \"noAssert\",\n                      \"desc\": \"Boolean, Optional, Default: false\",\n                      \"optional\": true\n                    }\n                  ]\n                },\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"offset\"\n                    },\n                    {\n                      \"name\": \"noAssert\",\n                      \"optional\": true\n                    }\n                  ]\n                },\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"offset\"\n                    },\n                    {\n                      \"name\": \"noAssert\",\n                      \"optional\": true\n                    }\n                  ]\n                }\n              ],\n              \"desc\": \"<p>Reads an unsigned 32 bit integer from the buffer at the specified offset with\\nspecified endian format.\\n\\n</p>\\n<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>\\nmay be beyond the end of the buffer. Defaults to <code>false</code>.\\n\\n</p>\\n<p>Example:\\n\\n</p>\\n<pre><code>var buf = new Buffer(4);\\n\\nbuf[0] = 0x3;\\nbuf[1] = 0x4;\\nbuf[2] = 0x23;\\nbuf[3] = 0x42;\\n\\nconsole.log(buf.readUInt32BE(0));\\nconsole.log(buf.readUInt32LE(0));\\n\\n// 0x03042342\\n// 0x42230403</code></pre>\\n\"\n            },\n            {\n              \"textRaw\": \"buf.readUInt32BE(offset, [noAssert])\",\n              \"type\": \"method\",\n              \"name\": \"readUInt32BE\",\n              \"signatures\": [\n                {\n                  \"return\": {\n                    \"textRaw\": \"Return: Number \",\n                    \"name\": \"return\",\n                    \"desc\": \"Number\"\n                  },\n                  \"params\": [\n                    {\n                      \"textRaw\": \"`offset` Number \",\n                      \"name\": \"offset\",\n                      \"desc\": \"Number\"\n                    },\n                    {\n                      \"textRaw\": \"`noAssert` Boolean, Optional, Default: false \",\n                      \"name\": \"noAssert\",\n                      \"desc\": \"Boolean, Optional, Default: false\",\n                      \"optional\": true\n                    }\n                  ]\n                },\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"offset\"\n                    },\n                    {\n                      \"name\": \"noAssert\",\n                      \"optional\": true\n                    }\n                  ]\n                }\n              ],\n              \"desc\": \"<p>Reads an unsigned 32 bit integer from the buffer at the specified offset with\\nspecified endian format.\\n\\n</p>\\n<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>\\nmay be beyond the end of the buffer. Defaults to <code>false</code>.\\n\\n</p>\\n<p>Example:\\n\\n</p>\\n<pre><code>var buf = new Buffer(4);\\n\\nbuf[0] = 0x3;\\nbuf[1] = 0x4;\\nbuf[2] = 0x23;\\nbuf[3] = 0x42;\\n\\nconsole.log(buf.readUInt32BE(0));\\nconsole.log(buf.readUInt32LE(0));\\n\\n// 0x03042342\\n// 0x42230403</code></pre>\\n\"\n            },\n            {\n              \"textRaw\": \"buf.readInt8(offset, [noAssert])\",\n              \"type\": \"method\",\n              \"name\": \"readInt8\",\n              \"signatures\": [\n                {\n                  \"return\": {\n                    \"textRaw\": \"Return: Number \",\n                    \"name\": \"return\",\n                    \"desc\": \"Number\"\n                  },\n                  \"params\": [\n                    {\n                      \"textRaw\": \"`offset` Number \",\n                      \"name\": \"offset\",\n                      \"desc\": \"Number\"\n                    },\n                    {\n                      \"textRaw\": \"`noAssert` Boolean, Optional, Default: false \",\n                      \"name\": \"noAssert\",\n                      \"desc\": \"Boolean, Optional, Default: false\",\n                      \"optional\": true\n                    }\n                  ]\n                },\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"offset\"\n                    },\n                    {\n                      \"name\": \"noAssert\",\n                      \"optional\": true\n                    }\n                  ]\n                }\n              ],\n              \"desc\": \"<p>Reads a signed 8 bit integer from the buffer at the specified offset.\\n\\n</p>\\n<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>\\nmay be beyond the end of the buffer. Defaults to <code>false</code>.\\n\\n</p>\\n<p>Works as <code>buffer.readUInt8</code>, except buffer contents are treated as two&#39;s\\ncomplement signed values.\\n\\n</p>\\n\"\n            },\n            {\n              \"textRaw\": \"buf.readInt16LE(offset, [noAssert])\",\n              \"type\": \"method\",\n              \"name\": \"readInt16LE\",\n              \"signatures\": [\n                {\n                  \"return\": {\n                    \"textRaw\": \"Return: Number \",\n                    \"name\": \"return\",\n                    \"desc\": \"Number\"\n                  },\n                  \"params\": [\n                    {\n                      \"textRaw\": \"`offset` Number \",\n                      \"name\": \"offset\",\n                      \"desc\": \"Number\"\n                    },\n                    {\n                      \"textRaw\": \"`noAssert` Boolean, Optional, Default: false \",\n                      \"name\": \"noAssert\",\n                      \"desc\": \"Boolean, Optional, Default: false\",\n                      \"optional\": true\n                    }\n                  ]\n                },\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"offset\"\n                    },\n                    {\n                      \"name\": \"noAssert\",\n                      \"optional\": true\n                    }\n                  ]\n                },\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"offset\"\n                    },\n                    {\n                      \"name\": \"noAssert\",\n                      \"optional\": true\n                    }\n                  ]\n                }\n              ],\n              \"desc\": \"<p>Reads a signed 16 bit integer from the buffer at the specified offset with\\nspecified endian format.\\n\\n</p>\\n<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>\\nmay be beyond the end of the buffer. Defaults to <code>false</code>.\\n\\n</p>\\n<p>Works as <code>buffer.readUInt16*</code>, except buffer contents are treated as two&#39;s\\ncomplement signed values.\\n\\n</p>\\n\"\n            },\n            {\n              \"textRaw\": \"buf.readInt16BE(offset, [noAssert])\",\n              \"type\": \"method\",\n              \"name\": \"readInt16BE\",\n              \"signatures\": [\n                {\n                  \"return\": {\n                    \"textRaw\": \"Return: Number \",\n                    \"name\": \"return\",\n                    \"desc\": \"Number\"\n                  },\n                  \"params\": [\n                    {\n                      \"textRaw\": \"`offset` Number \",\n                      \"name\": \"offset\",\n                      \"desc\": \"Number\"\n                    },\n                    {\n                      \"textRaw\": \"`noAssert` Boolean, Optional, Default: false \",\n                      \"name\": \"noAssert\",\n                      \"desc\": \"Boolean, Optional, Default: false\",\n                      \"optional\": true\n                    }\n                  ]\n                },\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"offset\"\n                    },\n                    {\n                      \"name\": \"noAssert\",\n                      \"optional\": true\n                    }\n                  ]\n                }\n              ],\n              \"desc\": \"<p>Reads a signed 16 bit integer from the buffer at the specified offset with\\nspecified endian format.\\n\\n</p>\\n<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>\\nmay be beyond the end of the buffer. Defaults to <code>false</code>.\\n\\n</p>\\n<p>Works as <code>buffer.readUInt16*</code>, except buffer contents are treated as two&#39;s\\ncomplement signed values.\\n\\n</p>\\n\"\n            },\n            {\n              \"textRaw\": \"buf.readInt32LE(offset, [noAssert])\",\n              \"type\": \"method\",\n              \"name\": \"readInt32LE\",\n              \"signatures\": [\n                {\n                  \"return\": {\n                    \"textRaw\": \"Return: Number \",\n                    \"name\": \"return\",\n                    \"desc\": \"Number\"\n                  },\n                  \"params\": [\n                    {\n                      \"textRaw\": \"`offset` Number \",\n                      \"name\": \"offset\",\n                      \"desc\": \"Number\"\n                    },\n                    {\n                      \"textRaw\": \"`noAssert` Boolean, Optional, Default: false \",\n                      \"name\": \"noAssert\",\n                      \"desc\": \"Boolean, Optional, Default: false\",\n                      \"optional\": true\n                    }\n                  ]\n                },\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"offset\"\n                    },\n                    {\n                      \"name\": \"noAssert\",\n                      \"optional\": true\n                    }\n                  ]\n                },\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"offset\"\n                    },\n                    {\n                      \"name\": \"noAssert\",\n                      \"optional\": true\n                    }\n                  ]\n                }\n              ],\n              \"desc\": \"<p>Reads a signed 32 bit integer from the buffer at the specified offset with\\nspecified endian format.\\n\\n</p>\\n<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>\\nmay be beyond the end of the buffer. Defaults to <code>false</code>.\\n\\n</p>\\n<p>Works as <code>buffer.readUInt32*</code>, except buffer contents are treated as two&#39;s\\ncomplement signed values.\\n\\n</p>\\n\"\n            },\n            {\n              \"textRaw\": \"buf.readInt32BE(offset, [noAssert])\",\n              \"type\": \"method\",\n              \"name\": \"readInt32BE\",\n              \"signatures\": [\n                {\n                  \"return\": {\n                    \"textRaw\": \"Return: Number \",\n                    \"name\": \"return\",\n                    \"desc\": \"Number\"\n                  },\n                  \"params\": [\n                    {\n                      \"textRaw\": \"`offset` Number \",\n                      \"name\": \"offset\",\n                      \"desc\": \"Number\"\n                    },\n                    {\n                      \"textRaw\": \"`noAssert` Boolean, Optional, Default: false \",\n                      \"name\": \"noAssert\",\n                      \"desc\": \"Boolean, Optional, Default: false\",\n                      \"optional\": true\n                    }\n                  ]\n                },\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"offset\"\n                    },\n                    {\n                      \"name\": \"noAssert\",\n                      \"optional\": true\n                    }\n                  ]\n                }\n              ],\n              \"desc\": \"<p>Reads a signed 32 bit integer from the buffer at the specified offset with\\nspecified endian format.\\n\\n</p>\\n<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>\\nmay be beyond the end of the buffer. Defaults to <code>false</code>.\\n\\n</p>\\n<p>Works as <code>buffer.readUInt32*</code>, except buffer contents are treated as two&#39;s\\ncomplement signed values.\\n\\n</p>\\n\"\n            },\n            {\n              \"textRaw\": \"buf.readFloatLE(offset, [noAssert])\",\n              \"type\": \"method\",\n              \"name\": \"readFloatLE\",\n              \"signatures\": [\n                {\n                  \"return\": {\n                    \"textRaw\": \"Return: Number \",\n                    \"name\": \"return\",\n                    \"desc\": \"Number\"\n                  },\n                  \"params\": [\n                    {\n                      \"textRaw\": \"`offset` Number \",\n                      \"name\": \"offset\",\n                      \"desc\": \"Number\"\n                    },\n                    {\n                      \"textRaw\": \"`noAssert` Boolean, Optional, Default: false \",\n                      \"name\": \"noAssert\",\n                      \"desc\": \"Boolean, Optional, Default: false\",\n                      \"optional\": true\n                    }\n                  ]\n                },\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"offset\"\n                    },\n                    {\n                      \"name\": \"noAssert\",\n                      \"optional\": true\n                    }\n                  ]\n                },\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"offset\"\n                    },\n                    {\n                      \"name\": \"noAssert\",\n                      \"optional\": true\n                    }\n                  ]\n                }\n              ],\n              \"desc\": \"<p>Reads a 32 bit float from the buffer at the specified offset with specified\\nendian format.\\n\\n</p>\\n<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>\\nmay be beyond the end of the buffer. Defaults to <code>false</code>.\\n\\n</p>\\n<p>Example:\\n\\n</p>\\n<pre><code>var buf = new Buffer(4);\\n\\nbuf[0] = 0x00;\\nbuf[1] = 0x00;\\nbuf[2] = 0x80;\\nbuf[3] = 0x3f;\\n\\nconsole.log(buf.readFloatLE(0));\\n\\n// 0x01</code></pre>\\n\"\n            },\n            {\n              \"textRaw\": \"buf.readFloatBE(offset, [noAssert])\",\n              \"type\": \"method\",\n              \"name\": \"readFloatBE\",\n              \"signatures\": [\n                {\n                  \"return\": {\n                    \"textRaw\": \"Return: Number \",\n                    \"name\": \"return\",\n                    \"desc\": \"Number\"\n                  },\n                  \"params\": [\n                    {\n                      \"textRaw\": \"`offset` Number \",\n                      \"name\": \"offset\",\n                      \"desc\": \"Number\"\n                    },\n                    {\n                      \"textRaw\": \"`noAssert` Boolean, Optional, Default: false \",\n                      \"name\": \"noAssert\",\n                      \"desc\": \"Boolean, Optional, Default: false\",\n                      \"optional\": true\n                    }\n                  ]\n                },\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"offset\"\n                    },\n                    {\n                      \"name\": \"noAssert\",\n                      \"optional\": true\n                    }\n                  ]\n                }\n              ],\n              \"desc\": \"<p>Reads a 32 bit float from the buffer at the specified offset with specified\\nendian format.\\n\\n</p>\\n<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>\\nmay be beyond the end of the buffer. Defaults to <code>false</code>.\\n\\n</p>\\n<p>Example:\\n\\n</p>\\n<pre><code>var buf = new Buffer(4);\\n\\nbuf[0] = 0x00;\\nbuf[1] = 0x00;\\nbuf[2] = 0x80;\\nbuf[3] = 0x3f;\\n\\nconsole.log(buf.readFloatLE(0));\\n\\n// 0x01</code></pre>\\n\"\n            },\n            {\n              \"textRaw\": \"buf.readDoubleLE(offset, [noAssert])\",\n              \"type\": \"method\",\n              \"name\": \"readDoubleLE\",\n              \"signatures\": [\n                {\n                  \"return\": {\n                    \"textRaw\": \"Return: Number \",\n                    \"name\": \"return\",\n                    \"desc\": \"Number\"\n                  },\n                  \"params\": [\n                    {\n                      \"textRaw\": \"`offset` Number \",\n                      \"name\": \"offset\",\n                      \"desc\": \"Number\"\n                    },\n                    {\n                      \"textRaw\": \"`noAssert` Boolean, Optional, Default: false \",\n                      \"name\": \"noAssert\",\n                      \"desc\": \"Boolean, Optional, Default: false\",\n                      \"optional\": true\n                    }\n                  ]\n                },\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"offset\"\n                    },\n                    {\n                      \"name\": \"noAssert\",\n                      \"optional\": true\n                    }\n                  ]\n                },\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"offset\"\n                    },\n                    {\n                      \"name\": \"noAssert\",\n                      \"optional\": true\n                    }\n                  ]\n                }\n              ],\n              \"desc\": \"<p>Reads a 64 bit double from the buffer at the specified offset with specified\\nendian format.\\n\\n</p>\\n<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>\\nmay be beyond the end of the buffer. Defaults to <code>false</code>.\\n\\n</p>\\n<p>Example:\\n\\n</p>\\n<pre><code>var buf = new Buffer(8);\\n\\nbuf[0] = 0x55;\\nbuf[1] = 0x55;\\nbuf[2] = 0x55;\\nbuf[3] = 0x55;\\nbuf[4] = 0x55;\\nbuf[5] = 0x55;\\nbuf[6] = 0xd5;\\nbuf[7] = 0x3f;\\n\\nconsole.log(buf.readDoubleLE(0));\\n\\n// 0.3333333333333333</code></pre>\\n\"\n            },\n            {\n              \"textRaw\": \"buf.readDoubleBE(offset, [noAssert])\",\n              \"type\": \"method\",\n              \"name\": \"readDoubleBE\",\n              \"signatures\": [\n                {\n                  \"return\": {\n                    \"textRaw\": \"Return: Number \",\n                    \"name\": \"return\",\n                    \"desc\": \"Number\"\n                  },\n                  \"params\": [\n                    {\n                      \"textRaw\": \"`offset` Number \",\n                      \"name\": \"offset\",\n                      \"desc\": \"Number\"\n                    },\n                    {\n                      \"textRaw\": \"`noAssert` Boolean, Optional, Default: false \",\n                      \"name\": \"noAssert\",\n                      \"desc\": \"Boolean, Optional, Default: false\",\n                      \"optional\": true\n                    }\n                  ]\n                },\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"offset\"\n                    },\n                    {\n                      \"name\": \"noAssert\",\n                      \"optional\": true\n                    }\n                  ]\n                }\n              ],\n              \"desc\": \"<p>Reads a 64 bit double from the buffer at the specified offset with specified\\nendian format.\\n\\n</p>\\n<p>Set <code>noAssert</code> to true to skip validation of <code>offset</code>. This means that <code>offset</code>\\nmay be beyond the end of the buffer. Defaults to <code>false</code>.\\n\\n</p>\\n<p>Example:\\n\\n</p>\\n<pre><code>var buf = new Buffer(8);\\n\\nbuf[0] = 0x55;\\nbuf[1] = 0x55;\\nbuf[2] = 0x55;\\nbuf[3] = 0x55;\\nbuf[4] = 0x55;\\nbuf[5] = 0x55;\\nbuf[6] = 0xd5;\\nbuf[7] = 0x3f;\\n\\nconsole.log(buf.readDoubleLE(0));\\n\\n// 0.3333333333333333</code></pre>\\n\"\n            },\n            {\n              \"textRaw\": \"buf.writeUInt8(value, offset, [noAssert])\",\n              \"type\": \"method\",\n              \"name\": \"writeUInt8\",\n              \"signatures\": [\n                {\n                  \"params\": [\n                    {\n                      \"textRaw\": \"`value` Number \",\n                      \"name\": \"value\",\n                      \"desc\": \"Number\"\n                    },\n                    {\n                      \"textRaw\": \"`offset` Number \",\n                      \"name\": \"offset\",\n                      \"desc\": \"Number\"\n                    },\n                    {\n                      \"textRaw\": \"`noAssert` Boolean, Optional, Default: false \",\n                      \"name\": \"noAssert\",\n                      \"desc\": \"Boolean, Optional, Default: false\",\n                      \"optional\": true\n                    }\n                  ]\n                },\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"value\"\n                    },\n                    {\n                      \"name\": \"offset\"\n                    },\n                    {\n                      \"name\": \"noAssert\",\n                      \"optional\": true\n                    }\n                  ]\n                }\n              ],\n              \"desc\": \"<p>Writes <code>value</code> to the buffer at the specified offset. Note, <code>value</code> must be a\\nvalid unsigned 8 bit integer.\\n\\n</p>\\n<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means\\nthat <code>value</code> may be too large for the specific function and <code>offset</code> may be\\nbeyond the end of the buffer leading to the values being silently dropped. This\\nshould not be used unless you are certain of correctness. Defaults to <code>false</code>.\\n\\n</p>\\n<p>Example:\\n\\n</p>\\n<pre><code>var buf = new Buffer(4);\\nbuf.writeUInt8(0x3, 0);\\nbuf.writeUInt8(0x4, 1);\\nbuf.writeUInt8(0x23, 2);\\nbuf.writeUInt8(0x42, 3);\\n\\nconsole.log(buf);\\n\\n// &lt;Buffer 03 04 23 42&gt;</code></pre>\\n\"\n            },\n            {\n              \"textRaw\": \"buf.writeUInt16LE(value, offset, [noAssert])\",\n              \"type\": \"method\",\n              \"name\": \"writeUInt16LE\",\n              \"signatures\": [\n                {\n                  \"params\": [\n                    {\n                      \"textRaw\": \"`value` Number \",\n                      \"name\": \"value\",\n                      \"desc\": \"Number\"\n                    },\n                    {\n                      \"textRaw\": \"`offset` Number \",\n                      \"name\": \"offset\",\n                      \"desc\": \"Number\"\n                    },\n                    {\n                      \"textRaw\": \"`noAssert` Boolean, Optional, Default: false \",\n                      \"name\": \"noAssert\",\n                      \"desc\": \"Boolean, Optional, Default: false\",\n                      \"optional\": true\n                    }\n                  ]\n                },\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"value\"\n                    },\n                    {\n                      \"name\": \"offset\"\n                    },\n                    {\n                      \"name\": \"noAssert\",\n                      \"optional\": true\n                    }\n                  ]\n                },\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"value\"\n                    },\n                    {\n                      \"name\": \"offset\"\n                    },\n                    {\n                      \"name\": \"noAssert\",\n                      \"optional\": true\n                    }\n                  ]\n                }\n              ],\n              \"desc\": \"<p>Writes <code>value</code> to the buffer at the specified offset with specified endian\\nformat. Note, <code>value</code> must be a valid unsigned 16 bit integer.\\n\\n</p>\\n<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means\\nthat <code>value</code> may be too large for the specific function and <code>offset</code> may be\\nbeyond the end of the buffer leading to the values being silently dropped. This\\nshould not be used unless you are certain of correctness. Defaults to <code>false</code>.\\n\\n</p>\\n<p>Example:\\n\\n</p>\\n<pre><code>var buf = new Buffer(4);\\nbuf.writeUInt16BE(0xdead, 0);\\nbuf.writeUInt16BE(0xbeef, 2);\\n\\nconsole.log(buf);\\n\\nbuf.writeUInt16LE(0xdead, 0);\\nbuf.writeUInt16LE(0xbeef, 2);\\n\\nconsole.log(buf);\\n\\n// &lt;Buffer de ad be ef&gt;\\n// &lt;Buffer ad de ef be&gt;</code></pre>\\n\"\n            },\n            {\n              \"textRaw\": \"buf.writeUInt16BE(value, offset, [noAssert])\",\n              \"type\": \"method\",\n              \"name\": \"writeUInt16BE\",\n              \"signatures\": [\n                {\n                  \"params\": [\n                    {\n                      \"textRaw\": \"`value` Number \",\n                      \"name\": \"value\",\n                      \"desc\": \"Number\"\n                    },\n                    {\n                      \"textRaw\": \"`offset` Number \",\n                      \"name\": \"offset\",\n                      \"desc\": \"Number\"\n                    },\n                    {\n                      \"textRaw\": \"`noAssert` Boolean, Optional, Default: false \",\n                      \"name\": \"noAssert\",\n                      \"desc\": \"Boolean, Optional, Default: false\",\n                      \"optional\": true\n                    }\n                  ]\n                },\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"value\"\n                    },\n                    {\n                      \"name\": \"offset\"\n                    },\n                    {\n                      \"name\": \"noAssert\",\n                      \"optional\": true\n                    }\n                  ]\n                }\n              ],\n              \"desc\": \"<p>Writes <code>value</code> to the buffer at the specified offset with specified endian\\nformat. Note, <code>value</code> must be a valid unsigned 16 bit integer.\\n\\n</p>\\n<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means\\nthat <code>value</code> may be too large for the specific function and <code>offset</code> may be\\nbeyond the end of the buffer leading to the values being silently dropped. This\\nshould not be used unless you are certain of correctness. Defaults to <code>false</code>.\\n\\n</p>\\n<p>Example:\\n\\n</p>\\n<pre><code>var buf = new Buffer(4);\\nbuf.writeUInt16BE(0xdead, 0);\\nbuf.writeUInt16BE(0xbeef, 2);\\n\\nconsole.log(buf);\\n\\nbuf.writeUInt16LE(0xdead, 0);\\nbuf.writeUInt16LE(0xbeef, 2);\\n\\nconsole.log(buf);\\n\\n// &lt;Buffer de ad be ef&gt;\\n// &lt;Buffer ad de ef be&gt;</code></pre>\\n\"\n            },\n            {\n              \"textRaw\": \"buf.writeUInt32LE(value, offset, [noAssert])\",\n              \"type\": \"method\",\n              \"name\": \"writeUInt32LE\",\n              \"signatures\": [\n                {\n                  \"params\": [\n                    {\n                      \"textRaw\": \"`value` Number \",\n                      \"name\": \"value\",\n                      \"desc\": \"Number\"\n                    },\n                    {\n                      \"textRaw\": \"`offset` Number \",\n                      \"name\": \"offset\",\n                      \"desc\": \"Number\"\n                    },\n                    {\n                      \"textRaw\": \"`noAssert` Boolean, Optional, Default: false \",\n                      \"name\": \"noAssert\",\n                      \"desc\": \"Boolean, Optional, Default: false\",\n                      \"optional\": true\n                    }\n                  ]\n                },\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"value\"\n                    },\n                    {\n                      \"name\": \"offset\"\n                    },\n                    {\n                      \"name\": \"noAssert\",\n                      \"optional\": true\n                    }\n                  ]\n                },\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"value\"\n                    },\n                    {\n                      \"name\": \"offset\"\n                    },\n                    {\n                      \"name\": \"noAssert\",\n                      \"optional\": true\n                    }\n                  ]\n                }\n              ],\n              \"desc\": \"<p>Writes <code>value</code> to the buffer at the specified offset with specified endian\\nformat. Note, <code>value</code> must be a valid unsigned 32 bit integer.\\n\\n</p>\\n<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means\\nthat <code>value</code> may be too large for the specific function and <code>offset</code> may be\\nbeyond the end of the buffer leading to the values being silently dropped. This\\nshould not be used unless you are certain of correctness. Defaults to <code>false</code>.\\n\\n</p>\\n<p>Example:\\n\\n</p>\\n<pre><code>var buf = new Buffer(4);\\nbuf.writeUInt32BE(0xfeedface, 0);\\n\\nconsole.log(buf);\\n\\nbuf.writeUInt32LE(0xfeedface, 0);\\n\\nconsole.log(buf);\\n\\n// &lt;Buffer fe ed fa ce&gt;\\n// &lt;Buffer ce fa ed fe&gt;</code></pre>\\n\"\n            },\n            {\n              \"textRaw\": \"buf.writeUInt32BE(value, offset, [noAssert])\",\n              \"type\": \"method\",\n              \"name\": \"writeUInt32BE\",\n              \"signatures\": [\n                {\n                  \"params\": [\n                    {\n                      \"textRaw\": \"`value` Number \",\n                      \"name\": \"value\",\n                      \"desc\": \"Number\"\n                    },\n                    {\n                      \"textRaw\": \"`offset` Number \",\n                      \"name\": \"offset\",\n                      \"desc\": \"Number\"\n                    },\n                    {\n                      \"textRaw\": \"`noAssert` Boolean, Optional, Default: false \",\n                      \"name\": \"noAssert\",\n                      \"desc\": \"Boolean, Optional, Default: false\",\n                      \"optional\": true\n                    }\n                  ]\n                },\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"value\"\n                    },\n                    {\n                      \"name\": \"offset\"\n                    },\n                    {\n                      \"name\": \"noAssert\",\n                      \"optional\": true\n                    }\n                  ]\n                }\n              ],\n              \"desc\": \"<p>Writes <code>value</code> to the buffer at the specified offset with specified endian\\nformat. Note, <code>value</code> must be a valid unsigned 32 bit integer.\\n\\n</p>\\n<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means\\nthat <code>value</code> may be too large for the specific function and <code>offset</code> may be\\nbeyond the end of the buffer leading to the values being silently dropped. This\\nshould not be used unless you are certain of correctness. Defaults to <code>false</code>.\\n\\n</p>\\n<p>Example:\\n\\n</p>\\n<pre><code>var buf = new Buffer(4);\\nbuf.writeUInt32BE(0xfeedface, 0);\\n\\nconsole.log(buf);\\n\\nbuf.writeUInt32LE(0xfeedface, 0);\\n\\nconsole.log(buf);\\n\\n// &lt;Buffer fe ed fa ce&gt;\\n// &lt;Buffer ce fa ed fe&gt;</code></pre>\\n\"\n            },\n            {\n              \"textRaw\": \"buf.writeInt8(value, offset, [noAssert])\",\n              \"type\": \"method\",\n              \"name\": \"writeInt8\",\n              \"signatures\": [\n                {\n                  \"params\": [\n                    {\n                      \"textRaw\": \"`value` Number \",\n                      \"name\": \"value\",\n                      \"desc\": \"Number\"\n                    },\n                    {\n                      \"textRaw\": \"`offset` Number \",\n                      \"name\": \"offset\",\n                      \"desc\": \"Number\"\n                    },\n                    {\n                      \"textRaw\": \"`noAssert` Boolean, Optional, Default: false \",\n                      \"name\": \"noAssert\",\n                      \"desc\": \"Boolean, Optional, Default: false\",\n                      \"optional\": true\n                    }\n                  ]\n                },\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"value\"\n                    },\n                    {\n                      \"name\": \"offset\"\n                    },\n                    {\n                      \"name\": \"noAssert\",\n                      \"optional\": true\n                    }\n                  ]\n                }\n              ],\n              \"desc\": \"<p>Writes <code>value</code> to the buffer at the specified offset. Note, <code>value</code> must be a\\nvalid signed 8 bit integer.\\n\\n</p>\\n<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means\\nthat <code>value</code> may be too large for the specific function and <code>offset</code> may be\\nbeyond the end of the buffer leading to the values being silently dropped. This\\nshould not be used unless you are certain of correctness. Defaults to <code>false</code>.\\n\\n</p>\\n<p>Works as <code>buffer.writeUInt8</code>, except value is written out as a two&#39;s complement\\nsigned integer into <code>buffer</code>.\\n\\n</p>\\n\"\n            },\n            {\n              \"textRaw\": \"buf.writeInt16LE(value, offset, [noAssert])\",\n              \"type\": \"method\",\n              \"name\": \"writeInt16LE\",\n              \"signatures\": [\n                {\n                  \"params\": [\n                    {\n                      \"textRaw\": \"`value` Number \",\n                      \"name\": \"value\",\n                      \"desc\": \"Number\"\n                    },\n                    {\n                      \"textRaw\": \"`offset` Number \",\n                      \"name\": \"offset\",\n                      \"desc\": \"Number\"\n                    },\n                    {\n                      \"textRaw\": \"`noAssert` Boolean, Optional, Default: false \",\n                      \"name\": \"noAssert\",\n                      \"desc\": \"Boolean, Optional, Default: false\",\n                      \"optional\": true\n                    }\n                  ]\n                },\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"value\"\n                    },\n                    {\n                      \"name\": \"offset\"\n                    },\n                    {\n                      \"name\": \"noAssert\",\n                      \"optional\": true\n                    }\n                  ]\n                },\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"value\"\n                    },\n                    {\n                      \"name\": \"offset\"\n                    },\n                    {\n                      \"name\": \"noAssert\",\n                      \"optional\": true\n                    }\n                  ]\n                }\n              ],\n              \"desc\": \"<p>Writes <code>value</code> to the buffer at the specified offset with specified endian\\nformat. Note, <code>value</code> must be a valid signed 16 bit integer.\\n\\n</p>\\n<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means\\nthat <code>value</code> may be too large for the specific function and <code>offset</code> may be\\nbeyond the end of the buffer leading to the values being silently dropped. This\\nshould not be used unless you are certain of correctness. Defaults to <code>false</code>.\\n\\n</p>\\n<p>Works as <code>buffer.writeUInt16*</code>, except value is written out as a two&#39;s\\ncomplement signed integer into <code>buffer</code>.\\n\\n</p>\\n\"\n            },\n            {\n              \"textRaw\": \"buf.writeInt16BE(value, offset, [noAssert])\",\n              \"type\": \"method\",\n              \"name\": \"writeInt16BE\",\n              \"signatures\": [\n                {\n                  \"params\": [\n                    {\n                      \"textRaw\": \"`value` Number \",\n                      \"name\": \"value\",\n                      \"desc\": \"Number\"\n                    },\n                    {\n                      \"textRaw\": \"`offset` Number \",\n                      \"name\": \"offset\",\n                      \"desc\": \"Number\"\n                    },\n                    {\n                      \"textRaw\": \"`noAssert` Boolean, Optional, Default: false \",\n                      \"name\": \"noAssert\",\n                      \"desc\": \"Boolean, Optional, Default: false\",\n                      \"optional\": true\n                    }\n                  ]\n                },\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"value\"\n                    },\n                    {\n                      \"name\": \"offset\"\n                    },\n                    {\n                      \"name\": \"noAssert\",\n                      \"optional\": true\n                    }\n                  ]\n                }\n              ],\n              \"desc\": \"<p>Writes <code>value</code> to the buffer at the specified offset with specified endian\\nformat. Note, <code>value</code> must be a valid signed 16 bit integer.\\n\\n</p>\\n<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means\\nthat <code>value</code> may be too large for the specific function and <code>offset</code> may be\\nbeyond the end of the buffer leading to the values being silently dropped. This\\nshould not be used unless you are certain of correctness. Defaults to <code>false</code>.\\n\\n</p>\\n<p>Works as <code>buffer.writeUInt16*</code>, except value is written out as a two&#39;s\\ncomplement signed integer into <code>buffer</code>.\\n\\n</p>\\n\"\n            },\n            {\n              \"textRaw\": \"buf.writeInt32LE(value, offset, [noAssert])\",\n              \"type\": \"method\",\n              \"name\": \"writeInt32LE\",\n              \"signatures\": [\n                {\n                  \"params\": [\n                    {\n                      \"textRaw\": \"`value` Number \",\n                      \"name\": \"value\",\n                      \"desc\": \"Number\"\n                    },\n                    {\n                      \"textRaw\": \"`offset` Number \",\n                      \"name\": \"offset\",\n                      \"desc\": \"Number\"\n                    },\n                    {\n                      \"textRaw\": \"`noAssert` Boolean, Optional, Default: false \",\n                      \"name\": \"noAssert\",\n                      \"desc\": \"Boolean, Optional, Default: false\",\n                      \"optional\": true\n                    }\n                  ]\n                },\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"value\"\n                    },\n                    {\n                      \"name\": \"offset\"\n                    },\n                    {\n                      \"name\": \"noAssert\",\n                      \"optional\": true\n                    }\n                  ]\n                },\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"value\"\n                    },\n                    {\n                      \"name\": \"offset\"\n                    },\n                    {\n                      \"name\": \"noAssert\",\n                      \"optional\": true\n                    }\n                  ]\n                }\n              ],\n              \"desc\": \"<p>Writes <code>value</code> to the buffer at the specified offset with specified endian\\nformat. Note, <code>value</code> must be a valid signed 32 bit integer.\\n\\n</p>\\n<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means\\nthat <code>value</code> may be too large for the specific function and <code>offset</code> may be\\nbeyond the end of the buffer leading to the values being silently dropped. This\\nshould not be used unless you are certain of correctness. Defaults to <code>false</code>.\\n\\n</p>\\n<p>Works as <code>buffer.writeUInt32*</code>, except value is written out as a two&#39;s\\ncomplement signed integer into <code>buffer</code>.\\n\\n</p>\\n\"\n            },\n            {\n              \"textRaw\": \"buf.writeInt32BE(value, offset, [noAssert])\",\n              \"type\": \"method\",\n              \"name\": \"writeInt32BE\",\n              \"signatures\": [\n                {\n                  \"params\": [\n                    {\n                      \"textRaw\": \"`value` Number \",\n                      \"name\": \"value\",\n                      \"desc\": \"Number\"\n                    },\n                    {\n                      \"textRaw\": \"`offset` Number \",\n                      \"name\": \"offset\",\n                      \"desc\": \"Number\"\n                    },\n                    {\n                      \"textRaw\": \"`noAssert` Boolean, Optional, Default: false \",\n                      \"name\": \"noAssert\",\n                      \"desc\": \"Boolean, Optional, Default: false\",\n                      \"optional\": true\n                    }\n                  ]\n                },\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"value\"\n                    },\n                    {\n                      \"name\": \"offset\"\n                    },\n                    {\n                      \"name\": \"noAssert\",\n                      \"optional\": true\n                    }\n                  ]\n                }\n              ],\n              \"desc\": \"<p>Writes <code>value</code> to the buffer at the specified offset with specified endian\\nformat. Note, <code>value</code> must be a valid signed 32 bit integer.\\n\\n</p>\\n<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means\\nthat <code>value</code> may be too large for the specific function and <code>offset</code> may be\\nbeyond the end of the buffer leading to the values being silently dropped. This\\nshould not be used unless you are certain of correctness. Defaults to <code>false</code>.\\n\\n</p>\\n<p>Works as <code>buffer.writeUInt32*</code>, except value is written out as a two&#39;s\\ncomplement signed integer into <code>buffer</code>.\\n\\n</p>\\n\"\n            },\n            {\n              \"textRaw\": \"buf.writeFloatLE(value, offset, [noAssert])\",\n              \"type\": \"method\",\n              \"name\": \"writeFloatLE\",\n              \"signatures\": [\n                {\n                  \"params\": [\n                    {\n                      \"textRaw\": \"`value` Number \",\n                      \"name\": \"value\",\n                      \"desc\": \"Number\"\n                    },\n                    {\n                      \"textRaw\": \"`offset` Number \",\n                      \"name\": \"offset\",\n                      \"desc\": \"Number\"\n                    },\n                    {\n                      \"textRaw\": \"`noAssert` Boolean, Optional, Default: false \",\n                      \"name\": \"noAssert\",\n                      \"desc\": \"Boolean, Optional, Default: false\",\n                      \"optional\": true\n                    }\n                  ]\n                },\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"value\"\n                    },\n                    {\n                      \"name\": \"offset\"\n                    },\n                    {\n                      \"name\": \"noAssert\",\n                      \"optional\": true\n                    }\n                  ]\n                },\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"value\"\n                    },\n                    {\n                      \"name\": \"offset\"\n                    },\n                    {\n                      \"name\": \"noAssert\",\n                      \"optional\": true\n                    }\n                  ]\n                }\n              ],\n              \"desc\": \"<p>Writes <code>value</code> to the buffer at the specified offset with specified endian\\nformat. Note, behavior is unspecified if <code>value</code> is not a 32 bit float.\\n\\n</p>\\n<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means\\nthat <code>value</code> may be too large for the specific function and <code>offset</code> may be\\nbeyond the end of the buffer leading to the values being silently dropped. This\\nshould not be used unless you are certain of correctness. Defaults to <code>false</code>.\\n\\n</p>\\n<p>Example:\\n\\n</p>\\n<pre><code>var buf = new Buffer(4);\\nbuf.writeFloatBE(0xcafebabe, 0);\\n\\nconsole.log(buf);\\n\\nbuf.writeFloatLE(0xcafebabe, 0);\\n\\nconsole.log(buf);\\n\\n// &lt;Buffer 4f 4a fe bb&gt;\\n// &lt;Buffer bb fe 4a 4f&gt;</code></pre>\\n\"\n            },\n            {\n              \"textRaw\": \"buf.writeFloatBE(value, offset, [noAssert])\",\n              \"type\": \"method\",\n              \"name\": \"writeFloatBE\",\n              \"signatures\": [\n                {\n                  \"params\": [\n                    {\n                      \"textRaw\": \"`value` Number \",\n                      \"name\": \"value\",\n                      \"desc\": \"Number\"\n                    },\n                    {\n                      \"textRaw\": \"`offset` Number \",\n                      \"name\": \"offset\",\n                      \"desc\": \"Number\"\n                    },\n                    {\n                      \"textRaw\": \"`noAssert` Boolean, Optional, Default: false \",\n                      \"name\": \"noAssert\",\n                      \"desc\": \"Boolean, Optional, Default: false\",\n                      \"optional\": true\n                    }\n                  ]\n                },\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"value\"\n                    },\n                    {\n                      \"name\": \"offset\"\n                    },\n                    {\n                      \"name\": \"noAssert\",\n                      \"optional\": true\n                    }\n                  ]\n                }\n              ],\n              \"desc\": \"<p>Writes <code>value</code> to the buffer at the specified offset with specified endian\\nformat. Note, behavior is unspecified if <code>value</code> is not a 32 bit float.\\n\\n</p>\\n<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means\\nthat <code>value</code> may be too large for the specific function and <code>offset</code> may be\\nbeyond the end of the buffer leading to the values being silently dropped. This\\nshould not be used unless you are certain of correctness. Defaults to <code>false</code>.\\n\\n</p>\\n<p>Example:\\n\\n</p>\\n<pre><code>var buf = new Buffer(4);\\nbuf.writeFloatBE(0xcafebabe, 0);\\n\\nconsole.log(buf);\\n\\nbuf.writeFloatLE(0xcafebabe, 0);\\n\\nconsole.log(buf);\\n\\n// &lt;Buffer 4f 4a fe bb&gt;\\n// &lt;Buffer bb fe 4a 4f&gt;</code></pre>\\n\"\n            },\n            {\n              \"textRaw\": \"buf.writeDoubleLE(value, offset, [noAssert])\",\n              \"type\": \"method\",\n              \"name\": \"writeDoubleLE\",\n              \"signatures\": [\n                {\n                  \"params\": [\n                    {\n                      \"textRaw\": \"`value` Number \",\n                      \"name\": \"value\",\n                      \"desc\": \"Number\"\n                    },\n                    {\n                      \"textRaw\": \"`offset` Number \",\n                      \"name\": \"offset\",\n                      \"desc\": \"Number\"\n                    },\n                    {\n                      \"textRaw\": \"`noAssert` Boolean, Optional, Default: false \",\n                      \"name\": \"noAssert\",\n                      \"desc\": \"Boolean, Optional, Default: false\",\n                      \"optional\": true\n                    }\n                  ]\n                },\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"value\"\n                    },\n                    {\n                      \"name\": \"offset\"\n                    },\n                    {\n                      \"name\": \"noAssert\",\n                      \"optional\": true\n                    }\n                  ]\n                },\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"value\"\n                    },\n                    {\n                      \"name\": \"offset\"\n                    },\n                    {\n                      \"name\": \"noAssert\",\n                      \"optional\": true\n                    }\n                  ]\n                }\n              ],\n              \"desc\": \"<p>Writes <code>value</code> to the buffer at the specified offset with specified endian\\nformat. Note, <code>value</code> must be a valid 64 bit double.\\n\\n</p>\\n<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means\\nthat <code>value</code> may be too large for the specific function and <code>offset</code> may be\\nbeyond the end of the buffer leading to the values being silently dropped. This\\nshould not be used unless you are certain of correctness. Defaults to <code>false</code>.\\n\\n</p>\\n<p>Example:\\n\\n</p>\\n<pre><code>var buf = new Buffer(8);\\nbuf.writeDoubleBE(0xdeadbeefcafebabe, 0);\\n\\nconsole.log(buf);\\n\\nbuf.writeDoubleLE(0xdeadbeefcafebabe, 0);\\n\\nconsole.log(buf);\\n\\n// &lt;Buffer 43 eb d5 b7 dd f9 5f d7&gt;\\n// &lt;Buffer d7 5f f9 dd b7 d5 eb 43&gt;</code></pre>\\n\"\n            },\n            {\n              \"textRaw\": \"buf.writeDoubleBE(value, offset, [noAssert])\",\n              \"type\": \"method\",\n              \"name\": \"writeDoubleBE\",\n              \"signatures\": [\n                {\n                  \"params\": [\n                    {\n                      \"textRaw\": \"`value` Number \",\n                      \"name\": \"value\",\n                      \"desc\": \"Number\"\n                    },\n                    {\n                      \"textRaw\": \"`offset` Number \",\n                      \"name\": \"offset\",\n                      \"desc\": \"Number\"\n                    },\n                    {\n                      \"textRaw\": \"`noAssert` Boolean, Optional, Default: false \",\n                      \"name\": \"noAssert\",\n                      \"desc\": \"Boolean, Optional, Default: false\",\n                      \"optional\": true\n                    }\n                  ]\n                },\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"value\"\n                    },\n                    {\n                      \"name\": \"offset\"\n                    },\n                    {\n                      \"name\": \"noAssert\",\n                      \"optional\": true\n                    }\n                  ]\n                }\n              ],\n              \"desc\": \"<p>Writes <code>value</code> to the buffer at the specified offset with specified endian\\nformat. Note, <code>value</code> must be a valid 64 bit double.\\n\\n</p>\\n<p>Set <code>noAssert</code> to true to skip validation of <code>value</code> and <code>offset</code>. This means\\nthat <code>value</code> may be too large for the specific function and <code>offset</code> may be\\nbeyond the end of the buffer leading to the values being silently dropped. This\\nshould not be used unless you are certain of correctness. Defaults to <code>false</code>.\\n\\n</p>\\n<p>Example:\\n\\n</p>\\n<pre><code>var buf = new Buffer(8);\\nbuf.writeDoubleBE(0xdeadbeefcafebabe, 0);\\n\\nconsole.log(buf);\\n\\nbuf.writeDoubleLE(0xdeadbeefcafebabe, 0);\\n\\nconsole.log(buf);\\n\\n// &lt;Buffer 43 eb d5 b7 dd f9 5f d7&gt;\\n// &lt;Buffer d7 5f f9 dd b7 d5 eb 43&gt;</code></pre>\\n\"\n            },\n            {\n              \"textRaw\": \"buf.fill(value, [offset], [end])\",\n              \"type\": \"method\",\n              \"name\": \"fill\",\n              \"signatures\": [\n                {\n                  \"params\": [\n                    {\n                      \"textRaw\": \"`value` \",\n                      \"name\": \"value\"\n                    },\n                    {\n                      \"textRaw\": \"`offset` Number, Optional \",\n                      \"name\": \"offset\",\n                      \"optional\": true,\n                      \"desc\": \"Number\"\n                    },\n                    {\n                      \"textRaw\": \"`end` Number, Optional \",\n                      \"name\": \"end\",\n                      \"optional\": true,\n                      \"desc\": \"Number\"\n                    }\n                  ]\n                },\n                {\n                  \"params\": [\n                    {\n                      \"name\": \"value\"\n                    },\n                    {\n                      \"name\": \"offset\",\n                      \"optional\": true\n                    },\n                    {\n                      \"name\": \"end\",\n                      \"optional\": true\n                    }\n                  ]\n                }\n              ],\n              \"desc\": \"<p>Fills the buffer with the specified value. If the <code>offset</code> (defaults to <code>0</code>)\\nand <code>end</code> (defaults to <code>buffer.length</code>) are not given it will fill the entire\\nbuffer.\\n\\n</p>\\n<pre><code>var b = new Buffer(50);\\nb.fill(&quot;h&quot;);</code></pre>\\n\"\n            }\n          ],\n          \"properties\": [\n            {\n              \"textRaw\": \"buf[index]\",\n              \"name\": \"[index]\",\n              \"desc\": \"<p>Get and set the octet at <code>index</code>. The values refer to individual bytes,\\nso the legal range is between <code>0x00</code> and <code>0xFF</code> hex or <code>0</code> and <code>255</code>.\\n\\n</p>\\n<p>Example: copy an ASCII string into a buffer, one byte at a time:\\n\\n</p>\\n<pre><code>str = &quot;node.js&quot;;\\nbuf = new Buffer(str.length);\\n\\nfor (var i = 0; i &lt; str.length ; i++) {\\n  buf[i] = str.charCodeAt(i);\\n}\\n\\nconsole.log(buf);\\n\\n// node.js</code></pre>\\n\"\n            },\n            {\n              \"textRaw\": \"`length` Number \",\n              \"name\": \"length\",\n              \"desc\": \"<p>The size of the buffer in bytes.  Note that this is not necessarily the size\\nof the contents. <code>length</code> refers to the amount of memory allocated for the\\nbuffer object.  It does not change when the contents of the buffer are changed.\\n\\n</p>\\n<pre><code>buf = new Buffer(1234);\\n\\nconsole.log(buf.length);\\nbuf.write(&quot;some string&quot;, 0, &quot;ascii&quot;);\\nconsole.log(buf.length);\\n\\n// 1234\\n// 1234</code></pre>\\n\",\n              \"shortDesc\": \"Number\"\n            }\n          ],\n          \"signatures\": [\n            {\n              \"params\": [\n                {\n                  \"textRaw\": \"`size` Number \",\n                  \"name\": \"size\",\n                  \"desc\": \"Number\"\n                }\n              ],\n              \"desc\": \"<p>Allocates a new buffer of <code>size</code> octets.\\n\\n</p>\\n\"\n            },\n            {\n              \"params\": [\n                {\n                  \"name\": \"size\"\n                }\n              ],\n              \"desc\": \"<p>Allocates a new buffer of <code>size</code> octets.\\n\\n</p>\\n\"\n            },\n            {\n              \"params\": [\n                {\n                  \"textRaw\": \"`array` Array \",\n                  \"name\": \"array\",\n                  \"desc\": \"Array\"\n                }\n              ],\n              \"desc\": \"<p>Allocates a new buffer using an <code>array</code> of octets.\\n\\n</p>\\n\"\n            },\n            {\n              \"params\": [\n                {\n                  \"name\": \"array\"\n                }\n              ],\n              \"desc\": \"<p>Allocates a new buffer using an <code>array</code> of octets.\\n\\n</p>\\n\"\n            },\n            {\n              \"params\": [\n                {\n                  \"textRaw\": \"`str` String - string to encode. \",\n                  \"name\": \"str\",\n                  \"desc\": \"String - string to encode.\"\n                },\n                {\n                  \"textRaw\": \"`encoding` String - encoding to use, Optional. \",\n                  \"name\": \"encoding\",\n                  \"desc\": \"String - encoding to use, Optional.\",\n                  \"optional\": true\n                }\n              ],\n              \"desc\": \"<p>Allocates a new buffer containing the given <code>str</code>.\\n<code>encoding</code> defaults to <code>&#39;utf8&#39;</code>.\\n\\n</p>\\n\"\n            },\n            {\n              \"params\": [\n                {\n                  \"name\": \"str\"\n                },\n                {\n                  \"name\": \"encoding\",\n                  \"optional\": true\n                }\n              ],\n              \"desc\": \"<p>Allocates a new buffer containing the given <code>str</code>.\\n<code>encoding</code> defaults to <code>&#39;utf8&#39;</code>.\\n\\n</p>\\n\"\n            }\n          ]\n        },\n        {\n          \"textRaw\": \"Class: SlowBuffer\",\n          \"type\": \"class\",\n          \"name\": \"SlowBuffer\",\n          \"desc\": \"<p>This class is primarily for internal use.  JavaScript programs should\\nuse Buffer instead of using SlowBuffer.\\n\\n</p>\\n<p>In order to avoid the overhead of allocating many C++ Buffer objects for\\nsmall blocks of memory in the lifetime of a server, Node allocates memory\\nin 8Kb (8192 byte) chunks.  If a buffer is smaller than this size, then it\\nwill be backed by a parent SlowBuffer object.  If it is larger than this,\\nthen Node will allocate a SlowBuffer slab for it directly.\\n</p>\\n\"\n        }\n      ],\n      \"properties\": [\n        {\n          \"textRaw\": \"`INSPECT_MAX_BYTES` Number, Default: 50 \",\n          \"name\": \"INSPECT_MAX_BYTES\",\n          \"desc\": \"<p>How many bytes will be returned when <code>buffer.inspect()</code> is called. This can\\nbe overridden by user modules.\\n\\n</p>\\n<p>Note that this is a property on the buffer module returned by\\n<code>require(&#39;buffer&#39;)</code>, not on the Buffer global, or a buffer instance.\\n\\n</p>\\n\",\n          \"shortDesc\": \"Number, Default: 50\"\n        }\n      ],\n      \"type\": \"module\",\n      \"displayName\": \"Buffer\"\n    }\n  ]\n}\n"}{"source":"http://nodejs.org/api/globals.json","title":"Globals","content":"{\n  \"source\": \"doc/api/globals.markdown\",\n  \"globals\": [\n    {\n      \"textRaw\": \"global\",\n      \"name\": \"global\",\n      \"type\": \"global\",\n      \"desc\": \"<p>In browsers, the top-level scope is the global scope. That means that in\\nbrowsers if you&#39;re in the global scope <code>var something</code> will define a global\\nvariable. In Node this is different. The top-level scope is not the global\\nscope; <code>var something</code> inside a Node module will be local to that module.\\n\\n</p>\\n\"\n    },\n    {\n      \"textRaw\": \"process\",\n      \"name\": \"process\",\n      \"type\": \"global\",\n      \"desc\": \"<p>The process object. See the [process object][] section.\\n\\n</p>\\n\"\n    },\n    {\n      \"textRaw\": \"console\",\n      \"name\": \"console\",\n      \"type\": \"global\",\n      \"desc\": \"<p>Used to print to stdout and stderr. See the [console][] section.\\n\\n</p>\\n\"\n    },\n    {\n      \"textRaw\": \"Class: Buffer\",\n      \"type\": \"global\",\n      \"name\": \"Buffer\",\n      \"desc\": \"<p>Used to handle binary data. See the [buffer section][]\\n\\n</p>\\n\"\n    },\n    {\n      \"textRaw\": \"clearInterval(t)\",\n      \"type\": \"global\",\n      \"name\": \"clearInterval\",\n      \"desc\": \"<p>Stop a timer that was previously created with <code>setInterval()</code>. The callback\\nwill not execute.\\n\\n</p>\\n<p>The timer functions are global variables. See the [timers][] section.\\n\\n</p>\\n\"\n    }\n  ],\n  \"vars\": [\n    {\n      \"textRaw\": \"require()\",\n      \"type\": \"var\",\n      \"name\": \"require\",\n      \"desc\": \"<p>To require modules. See the [Modules][] section.  <code>require</code> isn&#39;t actually a\\nglobal but rather local to each module.\\n\\n</p>\\n\",\n      \"methods\": [\n        {\n          \"textRaw\": \"require.resolve()\",\n          \"type\": \"method\",\n          \"name\": \"resolve\",\n          \"desc\": \"<p>Use the internal <code>require()</code> machinery to look up the location of a module,\\nbut rather than loading the module, just return the resolved filename.\\n\\n</p>\\n\",\n          \"signatures\": [\n            {\n              \"params\": []\n            }\n          ]\n        }\n      ],\n      \"properties\": [\n        {\n          \"textRaw\": \"`cache` {Object} \",\n          \"name\": \"cache\",\n          \"desc\": \"<p>Modules are cached in this object when they are required. By deleting a key\\nvalue from this object, the next <code>require</code> will reload the module.\\n\\n</p>\\n\"\n        },\n        {\n          \"textRaw\": \"`extensions` {Object} \",\n          \"name\": \"extensions\",\n          \"stability\": 0,\n          \"stabilityText\": \"Deprecated\",\n          \"desc\": \"<p>Instruct <code>require</code> on how to handle certain file extensions.\\n\\n</p>\\n<p>Process files with the extension <code>.sjs</code> as <code>.js</code>:\\n\\n</p>\\n<pre><code>require.extensions[&#39;.sjs&#39;] = require.extensions[&#39;.js&#39;];</code></pre>\\n<p><strong>Deprecated</strong>  In the past, this list has been used to load\\nnon-JavaScript modules into Node by compiling them on-demand.\\nHowever, in practice, there are much better ways to do this, such as\\nloading modules via some other Node program, or compiling them to\\nJavaScript ahead of time.\\n\\n</p>\\n<p>Since the Module system is locked, this feature will probably never go\\naway.  However, it may have subtle bugs and complexities that are best\\nleft untouched.\\n\\n</p>\\n\"\n        }\n      ]\n    },\n    {\n      \"textRaw\": \"__filename\",\n      \"name\": \"__filename\",\n      \"type\": \"var\",\n      \"desc\": \"<p>The filename of the code being executed.  This is the resolved absolute path\\nof this code file.  For a main program this is not necessarily the same\\nfilename used in the command line.  The value inside a module is the path\\nto that module file.\\n\\n</p>\\n<p>Example: running <code>node example.js</code> from <code>/Users/mjr</code>\\n\\n</p>\\n<pre><code>console.log(__filename);\\n// /Users/mjr/example.js</code></pre>\\n<p><code>__filename</code> isn&#39;t actually a global but rather local to each module.\\n\\n</p>\\n\"\n    },\n    {\n      \"textRaw\": \"__dirname\",\n      \"name\": \"__dirname\",\n      \"type\": \"var\",\n      \"desc\": \"<p>The name of the directory that the currently executing script resides in.\\n\\n</p>\\n<p>Example: running <code>node example.js</code> from <code>/Users/mjr</code>\\n\\n</p>\\n<pre><code>console.log(__dirname);\\n// /Users/mjr</code></pre>\\n<p><code>__dirname</code> isn&#39;t actually a global but rather local to each module.\\n\\n\\n</p>\\n\"\n    },\n    {\n      \"textRaw\": \"module\",\n      \"name\": \"module\",\n      \"type\": \"var\",\n      \"desc\": \"<p>A reference to the current module. In particular\\n<code>module.exports</code> is used for defining what a module exports and makes\\navailable through <code>require()</code>.\\n\\n</p>\\n<p><code>module</code> isn&#39;t actually a global but rather local to each module.\\n\\n</p>\\n<p>See the [module system documentation][] for more information.\\n\\n</p>\\n\"\n    },\n    {\n      \"textRaw\": \"exports\",\n      \"name\": \"exports\",\n      \"type\": \"var\",\n      \"desc\": \"<p>A reference to the <code>module.exports</code> that is shorter to type.\\nSee [module system documentation][] for details on when to use <code>exports</code> and\\nwhen to use <code>module.exports</code>.\\n\\n</p>\\n<p><code>exports</code> isn&#39;t actually a global but rather local to each module.\\n\\n</p>\\n<p>See the [module system documentation][] for more information.\\n\\n</p>\\n<p>See the [module section][] for more information.\\n\\n</p>\\n\"\n    }\n  ],\n  \"methods\": [\n    {\n      \"textRaw\": \"setTimeout(cb, ms)\",\n      \"type\": \"method\",\n      \"name\": \"setTimeout\",\n      \"desc\": \"<p>Run callback <code>cb</code> after <em>at least</em> <code>ms</code> milliseconds. The actual delay depends\\non external factors like OS timer granularity and system load.\\n\\n</p>\\n<p>The timeout must be in the range of 1-2,147,483,647 inclusive. If the value is\\noutside that range, it&#39;s changed to 1 millisecond. Broadly speaking, a timer\\ncannot span more than 24.8 days.\\n\\n</p>\\n<p>Returns an opaque value that represents the timer.\\n\\n</p>\\n\",\n      \"signatures\": [\n        {\n          \"params\": [\n            {\n              \"name\": \"cb\"\n            },\n            {\n              \"name\": \"ms\"\n            }\n          ]\n        }\n      ]\n    },\n    {\n      \"textRaw\": \"clearTimeout(t)\",\n      \"type\": \"method\",\n      \"name\": \"clearTimeout\",\n      \"desc\": \"<p>Stop a timer that was previously created with <code>setTimeout()</code>. The callback will\\nnot execute.\\n\\n</p>\\n\",\n      \"signatures\": [\n        {\n          \"params\": [\n            {\n              \"name\": \"t\"\n            }\n          ]\n        }\n      ]\n    },\n    {\n      \"textRaw\": \"setInterval(cb, ms)\",\n      \"type\": \"method\",\n      \"name\": \"setInterval\",\n      \"desc\": \"<p>Run callback <code>cb</code> repeatedly every <code>ms</code> milliseconds. Note that the actual\\ninterval may vary, depending on external factors like OS timer granularity and\\nsystem load. It&#39;s never less than <code>ms</code> but it may be longer.\\n\\n</p>\\n<p>The interval must be in the range of 1-2,147,483,647 inclusive. If the value is\\noutside that range, it&#39;s changed to 1 millisecond. Broadly speaking, a timer\\ncannot span more than 24.8 days.\\n\\n</p>\\n<p>Returns an opaque value that represents the timer.\\n\\n</p>\\n\",\n      \"signatures\": [\n        {\n          \"params\": [\n            {\n              \"name\": \"cb\"\n            },\n            {\n              \"name\": \"ms\"\n            }\n          ]\n        }\n      ]\n    }\n  ],\n  \"miscs\": [\n    {\n      \"textRaw\": \"Global Objects\",\n      \"name\": \"Global Objects\",\n      \"type\": \"misc\",\n      \"desc\": \"<p>These objects are available in all modules. Some of these objects aren&#39;t\\nactually in the global scope but in the module scope - this will be noted.\\n\\n</p>\\n\",\n      \"globals\": [\n        {\n          \"textRaw\": \"global\",\n          \"name\": \"global\",\n          \"type\": \"global\",\n          \"desc\": \"<p>In browsers, the top-level scope is the global scope. That means that in\\nbrowsers if you&#39;re in the global scope <code>var something</code> will define a global\\nvariable. In Node this is different. The top-level scope is not the global\\nscope; <code>var something</code> inside a Node module will be local to that module.\\n\\n</p>\\n\"\n        },\n        {\n          \"textRaw\": \"process\",\n          \"name\": \"process\",\n          \"type\": \"global\",\n          \"desc\": \"<p>The process object. See the [process object][] section.\\n\\n</p>\\n\"\n        },\n        {\n          \"textRaw\": \"console\",\n          \"name\": \"console\",\n          \"type\": \"global\",\n          \"desc\": \"<p>Used to print to stdout and stderr. See the [console][] section.\\n\\n</p>\\n\"\n        },\n        {\n          \"textRaw\": \"Class: Buffer\",\n          \"type\": \"global\",\n          \"name\": \"Buffer\",\n          \"desc\": \"<p>Used to handle binary data. See the [buffer section][]\\n\\n</p>\\n\"\n        },\n        {\n          \"textRaw\": \"clearInterval(t)\",\n          \"type\": \"global\",\n          \"name\": \"clearInterval\",\n          \"desc\": \"<p>Stop a timer that was previously created with <code>setInterval()</code>. The callback\\nwill not execute.\\n\\n</p>\\n<p>The timer functions are global variables. See the [timers][] section.\\n\\n</p>\\n\"\n        }\n      ],\n      \"vars\": [\n        {\n          \"textRaw\": \"require()\",\n          \"type\": \"var\",\n          \"name\": \"require\",\n          \"desc\": \"<p>To require modules. See the [Modules][] section.  <code>require</code> isn&#39;t actually a\\nglobal but rather local to each module.\\n\\n</p>\\n\",\n          \"methods\": [\n            {\n              \"textRaw\": \"require.resolve()\",\n              \"type\": \"method\",\n              \"name\": \"resolve\",\n              \"desc\": \"<p>Use the internal <code>require()</code> machinery to look up the location of a module,\\nbut rather than loading the module, just return the resolved filename.\\n\\n</p>\\n\",\n              \"signatures\": [\n                {\n                  \"params\": []\n                }\n              ]\n            }\n          ],\n          \"properties\": [\n            {\n              \"textRaw\": \"`cache` {Object} \",\n              \"name\": \"cache\",\n              \"desc\": \"<p>Modules are cached in this object when they are required. By deleting a key\\nvalue from this object, the next <code>require</code> will reload the module.\\n\\n</p>\\n\"\n            },\n            {\n              \"textRaw\": \"`extensions` {Object} \",\n              \"name\": \"extensions\",\n              \"stability\": 0,\n              \"stabilityText\": \"Deprecated\",\n              \"desc\": \"<p>Instruct <code>require</code> on how to handle certain file extensions.\\n\\n</p>\\n<p>Process files with the extension <code>.sjs</code> as <code>.js</code>:\\n\\n</p>\\n<pre><code>require.extensions[&#39;.sjs&#39;] = require.extensions[&#39;.js&#39;];</code></pre>\\n<p><strong>Deprecated</strong>  In the past, this list has been used to load\\nnon-JavaScript modules into Node by compiling them on-demand.\\nHowever, in practice, there are much better ways to do this, such as\\nloading modules via some other Node program, or compiling them to\\nJavaScript ahead of time.\\n\\n</p>\\n<p>Since the Module system is locked, this feature will probably never go\\naway.  However, it may have subtle bugs and complexities that are best\\nleft untouched.\\n\\n</p>\\n\"\n            }\n          ]\n        },\n        {\n          \"textRaw\": \"__filename\",\n          \"name\": \"__filename\",\n          \"type\": \"var\",\n          \"desc\": \"<p>The filename of the code being executed.  This is the resolved absolute path\\nof this code file.  For a main program this is not necessarily the same\\nfilename used in the command line.  The value inside a module is the path\\nto that module file.\\n\\n</p>\\n<p>Example: running <code>node example.js</code> from <code>/Users/mjr</code>\\n\\n</p>\\n<pre><code>console.log(__filename);\\n// /Users/mjr/example.js</code></pre>\\n<p><code>__filename</code> isn&#39;t actually a global but rather local to each module.\\n\\n</p>\\n\"\n        },\n        {\n          \"textRaw\": \"__dirname\",\n          \"name\": \"__dirname\",\n          \"type\": \"var\",\n          \"desc\": \"<p>The name of the directory that the currently executing script resides in.\\n\\n</p>\\n<p>Example: running <code>node example.js</code> from <code>/Users/mjr</code>\\n\\n</p>\\n<pre><code>console.log(__dirname);\\n// /Users/mjr</code></pre>\\n<p><code>__dirname</code> isn&#39;t actually a global but rather local to each module.\\n\\n\\n</p>\\n\"\n        },\n        {\n          \"textRaw\": \"module\",\n          \"name\": \"module\",\n          \"type\": \"var\",\n          \"desc\": \"<p>A reference to the current module. In particular\\n<code>module.exports</code> is used for defining what a module exports and makes\\navailable through <code>require()</code>.\\n\\n</p>\\n<p><code>module</code> isn&#39;t actually a global but rather local to each module.\\n\\n</p>\\n<p>See the [module system documentation][] for more information.\\n\\n</p>\\n\"\n        },\n        {\n          \"textRaw\": \"exports\",\n          \"name\": \"exports\",\n          \"type\": \"var\",\n          \"desc\": \"<p>A reference to the <code>module.exports</code> that is shorter to type.\\nSee [module system documentation][] for details on when to use <code>exports</code> and\\nwhen to use <code>module.exports</code>.\\n\\n</p>\\n<p><code>exports</code> isn&#39;t actually a global but rather local to each module.\\n\\n</p>\\n<p>See the [module system documentation][] for more information.\\n\\n</p>\\n<p>See the [module section][] for more information.\\n\\n</p>\\n\"\n        }\n      ],\n      \"methods\": [\n        {\n          \"textRaw\": \"setTimeout(cb, ms)\",\n          \"type\": \"method\",\n          \"name\": \"setTimeout\",\n          \"desc\": \"<p>Run callback <code>cb</code> after <em>at least</em> <code>ms</code> milliseconds. The actual delay depends\\non external factors like OS timer granularity and system load.\\n\\n</p>\\n<p>The timeout must be in the range of 1-2,147,483,647 inclusive. If the value is\\noutside that range, it&#39;s changed to 1 millisecond. Broadly speaking, a timer\\ncannot span more than 24.8 days.\\n\\n</p>\\n<p>Returns an opaque value that represents the timer.\\n\\n</p>\\n\",\n          \"signatures\": [\n            {\n              \"params\": [\n                {\n                  \"name\": \"cb\"\n                },\n                {\n                  \"name\": \"ms\"\n                }\n              ]\n            }\n          ]\n        },\n        {\n          \"textRaw\": \"clearTimeout(t)\",\n          \"type\": \"method\",\n          \"name\": \"clearTimeout\",\n          \"desc\": \"<p>Stop a timer that was previously created with <code>setTimeout()</code>. The callback will\\nnot execute.\\n\\n</p>\\n\",\n          \"signatures\": [\n            {\n              \"params\": [\n                {\n                  \"name\": \"t\"\n                }\n              ]\n            }\n          ]\n        },\n        {\n          \"textRaw\": \"setInterval(cb, ms)\",\n          \"type\": \"method\",\n          \"name\": \"setInterval\",\n          \"desc\": \"<p>Run callback <code>cb</code> repeatedly every <code>ms</code> milliseconds. Note that the actual\\ninterval may vary, depending on external factors like OS timer granularity and\\nsystem load. It&#39;s never less than <code>ms</code> but it may be longer.\\n\\n</p>\\n<p>The interval must be in the range of 1-2,147,483,647 inclusive. If the value is\\noutside that range, it&#39;s changed to 1 millisecond. Broadly speaking, a timer\\ncannot span more than 24.8 days.\\n\\n</p>\\n<p>Returns an opaque value that represents the timer.\\n\\n</p>\\n\",\n          \"signatures\": [\n            {\n              \"params\": [\n                {\n                  \"name\": \"cb\"\n                },\n                {\n                  \"name\": \"ms\"\n                }\n              ]\n            }\n          ]\n        }\n      ]\n    }\n  ]\n}\n"}{"source":"http://nodejs.org/api/os.json","title":"OS","content":"{\n  \"source\": \"doc/api/os.markdown\",\n  \"modules\": [\n    {\n      \"textRaw\": \"os\",\n      \"name\": \"os\",\n      \"stability\": 4,\n      \"stabilityText\": \"API Frozen\",\n      \"desc\": \"<p>Provides a few basic operating-system related utility functions.\\n\\n</p>\\n<p>Use <code>require(&#39;os&#39;)</code> to access this module.\\n\\n</p>\\n\",\n      \"methods\": [\n        {\n          \"textRaw\": \"os.tmpdir()\",\n          \"type\": \"method\",\n          \"name\": \"tmpdir\",\n          \"desc\": \"<p>Returns the operating system&#39;s default directory for temp files.\\n\\n</p>\\n\",\n          \"signatures\": [\n            {\n              \"params\": []\n            }\n          ]\n        },\n        {\n          \"textRaw\": \"os.endianness()\",\n          \"type\": \"method\",\n          \"name\": \"endianness\",\n          \"desc\": \"<p>Returns the endianness of the CPU. Possible values are <code>&quot;BE&quot;</code> or <code>&quot;LE&quot;</code>.\\n\\n</p>\\n\",\n          \"signatures\": [\n            {\n              \"params\": []\n            }\n          ]\n        },\n        {\n          \"textRaw\": \"os.hostname()\",\n          \"type\": \"method\",\n          \"name\": \"hostname\",\n          \"desc\": \"<p>Returns the hostname of the operating system.\\n\\n</p>\\n\",\n          \"signatures\": [\n            {\n              \"params\": []\n            }\n          ]\n        },\n        {\n          \"textRaw\": \"os.type()\",\n          \"type\": \"method\",\n          \"name\": \"type\",\n          \"desc\": \"<p>Returns the operating system name.\\n\\n</p>\\n\",\n          \"signatures\": [\n            {\n              \"params\": []\n            }\n          ]\n        },\n        {\n          \"textRaw\": \"os.platform()\",\n          \"type\": \"method\",\n          \"name\": \"platform\",\n          \"desc\": \"<p>Returns the operating system platform.\\n\\n</p>\\n\",\n          \"signatures\": [\n            {\n              \"params\": []\n            }\n          ]\n        },\n        {\n          \"textRaw\": \"os.arch()\",\n          \"type\": \"method\",\n          \"name\": \"arch\",\n          \"desc\": \"<p>Returns the operating system CPU architecture.\\n\\n</p>\\n\",\n          \"signatures\": [\n            {\n              \"params\": []\n            }\n          ]\n        },\n        {\n          \"textRaw\": \"os.release()\",\n          \"type\": \"method\",\n          \"name\": \"release\",\n          \"desc\": \"<p>Returns the operating system release.\\n\\n</p>\\n\",\n          \"signatures\": [\n            {\n              \"params\": []\n            }\n          ]\n        },\n        {\n          \"textRaw\": \"os.uptime()\",\n          \"type\": \"method\",\n          \"name\": \"uptime\",\n          \"desc\": \"<p>Returns the system uptime in seconds.\\n\\n</p>\\n\",\n          \"signatures\": [\n            {\n              \"params\": []\n            }\n          ]\n        },\n        {\n          \"textRaw\": \"os.loadavg()\",\n          \"type\": \"method\",\n          \"name\": \"loadavg\",\n          \"desc\": \"<p>Returns an array containing the 1, 5, and 15 minute load averages.\\n\\n</p>\\n<p>The load average is a measure of system activity, calculated by the operating\\nsystem and expressed as a fractional number.  As a rule of thumb, the load\\naverage should ideally be less than the number of logical CPUs in the system.\\n\\n</p>\\n<p>The load average is a very UNIX-y concept; there is no real equivalent on\\nWindows platforms.  That is why this function always returns <code>[0, 0, 0]</code> on\\nWindows.\\n\\n</p>\\n\",\n          \"signatures\": [\n            {\n              \"params\": []\n            }\n          ]\n        },\n        {\n          \"textRaw\": \"os.totalmem()\",\n          \"type\": \"method\",\n          \"name\": \"totalmem\",\n          \"desc\": \"<p>Returns the total amount of system memory in bytes.\\n\\n</p>\\n\",\n          \"signatures\": [\n            {\n              \"params\": []\n            }\n          ]\n        },\n        {\n          \"textRaw\": \"os.freemem()\",\n          \"type\": \"method\",\n          \"name\": \"freemem\",\n          \"desc\": \"<p>Returns the amount of free system memory in bytes.\\n\\n</p>\\n\",\n          \"signatures\": [\n            {\n              \"params\": []\n            }\n          ]\n        },\n        {\n          \"textRaw\": \"os.cpus()\",\n          \"type\": \"method\",\n          \"name\": \"cpus\",\n          \"desc\": \"<p>Returns an array of objects containing information about each CPU/core\\ninstalled: model, speed (in MHz), and times (an object containing the number of\\nmilliseconds the CPU/core spent in: user, nice, sys, idle, and irq).\\n\\n</p>\\n<p>Example inspection of os.cpus:\\n\\n</p>\\n<pre><code>[ { model: &#39;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&#39;,\\n    speed: 2926,\\n    times:\\n     { user: 252020,\\n       nice: 0,\\n       sys: 30340,\\n       idle: 1070356870,\\n       irq: 0 } },\\n  { model: &#39;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&#39;,\\n    speed: 2926,\\n    times:\\n     { user: 306960,\\n       nice: 0,\\n       sys: 26980,\\n       idle: 1071569080,\\n       irq: 0 } },\\n  { model: &#39;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&#39;,\\n    speed: 2926,\\n    times:\\n     { user: 248450,\\n       nice: 0,\\n       sys: 21750,\\n       idle: 1070919370,\\n       irq: 0 } },\\n  { model: &#39;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&#39;,\\n    speed: 2926,\\n    times:\\n     { user: 256880,\\n       nice: 0,\\n       sys: 19430,\\n       idle: 1070905480,\\n       irq: 20 } },\\n  { model: &#39;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&#39;,\\n    speed: 2926,\\n    times:\\n     { user: 511580,\\n       nice: 20,\\n       sys: 40900,\\n       idle: 1070842510,\\n       irq: 0 } },\\n  { model: &#39;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&#39;,\\n    speed: 2926,\\n    times:\\n     { user: 291660,\\n       nice: 0,\\n       sys: 34360,\\n       idle: 1070888000,\\n       irq: 10 } },\\n  { model: &#39;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&#39;,\\n    speed: 2926,\\n    times:\\n     { user: 308260,\\n       nice: 0,\\n       sys: 55410,\\n       idle: 1071129970,\\n       irq: 880 } },\\n  { model: &#39;Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz&#39;,\\n    speed: 2926,\\n    times:\\n     { user: 266450,\\n       nice: 1480,\\n       sys: 34920,\\n       idle: 1072572010,\\n       irq: 30 } } ]</code></pre>\\n\",\n          \"signatures\": [\n            {\n              \"params\": []\n            }\n          ]\n        },\n        {\n          \"textRaw\": \"os.networkInterfaces()\",\n          \"type\": \"method\",\n          \"name\": \"networkInterfaces\",\n          \"desc\": \"<p>Get a list of network interfaces:\\n\\n</p>\\n<pre><code>{ lo0: \\n   [ { address: &#39;::1&#39;, family: &#39;IPv6&#39;, internal: true },\\n     { address: &#39;fe80::1&#39;, family: &#39;IPv6&#39;, internal: true },\\n     { address: &#39;127.0.0.1&#39;, family: &#39;IPv4&#39;, internal: true } ],\\n  en1: \\n   [ { address: &#39;fe80::cabc:c8ff:feef:f996&#39;, family: &#39;IPv6&#39;,\\n       internal: false },\\n     { address: &#39;10.0.1.123&#39;, family: &#39;IPv4&#39;, internal: false } ],\\n  vmnet1: [ { address: &#39;10.99.99.254&#39;, family: &#39;IPv4&#39;, internal: false } ],\\n  vmnet8: [ { address: &#39;10.88.88.1&#39;, family: &#39;IPv4&#39;, internal: false } ],\\n  ppp0: [ { address: &#39;10.2.0.231&#39;, family: &#39;IPv4&#39;, internal: false } ] }</code></pre>\\n\",\n          \"signatures\": [\n            {\n              \"params\": []\n            }\n          ]\n        }\n      ],\n      \"properties\": [\n        {\n          \"textRaw\": \"os.EOL\",\n          \"name\": \"EOL\",\n          \"desc\": \"<p>A constant defining the appropriate End-of-line marker for the operating system.\\n</p>\\n\"\n        }\n      ],\n      \"type\": \"module\",\n      \"displayName\": \"os\"\n    }\n  ]\n}\n"}